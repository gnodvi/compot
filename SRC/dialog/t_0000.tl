# -*-   mode: tcl  ; coding: koi8   -*- ----------------------------------------


# # UDP !!!!!!!!!!!!!!!!!!!
# #
# package require udp

# #-------------------------------------------------------------------------------
# proc cd_to_script_dir {} {

#   cd [file normalize [file dirname [info script]]]

# }

##-------------------------------------------------------------------------------
# Программный фреймворк ВССУ (Виртуальная Cхема СУ) выполняет функции:

# --------------------------------------------------------------------------------

# 1) на этапе проетирования СУ: отладка прототипов протоколов и справочная 
#    система по принятым уже протоколам;

#   - прототипы протоколов (dict)
#   - прототипы всех модулей, только для отладки, т.е. "поверки" этих протоколов
#   - по умолчанию: самый тривиальный вариант, затем иерархично усложяется,
#     отладить механизм наследования и т.д.

# --------------------------------------------------------------------------------

# 2) на этапе отладки СУ: агрегирование в одной схеме выходных консольных данных
#    от одновременно работающих модулей;

#   - при запуске стороннего модуля, он должен подменять работающий по умолчанию,
#     т.е. подменяется стандартным IMPORT_MODULE, с указанием адреса UDP для
#     приема?

# --------------------------------------------------------------------------------

# 3) на этапе штатной работы СУ: фреймворк выступает в качестве модуля 
#    документирования в том числе, частично сохраняя в базу данных фреймы ГПИ 
#    (графического 
#    пользовательского интерфейса) с возможность повторного просмотра работы СУ.

#   - данные (текстовый вывод от консолей приложений и их ужатый образ экрана)
#     записываются в базу и затем синхронно для всех модулей проигрываются!

#-------------------------------------------------------------------------------

set ::points [list]

#-------------------------------------------------------------------------------
proc get_123_geom_NEW {&x0 &y0 &w0 &h0  &x1 &y1 &w1 &h1  &x2 &y2 &w2 &h2} {

  USE_REFS

  set W_scr [winfo screenwidth  .]   ;# 1680 (для рабочего), 1920 (для стендового) 
  set H_scr [winfo screenheight .]   ;# 1050 (для рабочего), 1080 (для стендового) 

  puts ""
  puts "W_scr = $W_scr"
  puts "H_scr = $H_scr"

  set W_koef [expr $W_scr / 1920.0]
  set H_koef [expr $H_scr / 1080.0]

  puts ""
  puts "W_koef = $W_koef"
  puts "H_koef = $H_koef"

  set x_win [expr int(270 * $W_koef)]
  set y_win [expr int( 20 * $W_koef)]

  set w_win [expr int(690 * $W_koef)] ;# было 670
  set h_win [expr int(460 * $H_koef)]


  set h_add  40  ;# дополнительная высота сдвига (заголовок + рамка + зазор)
  set w_add  20  ;# 
    
  #if {$W < 1920} {
  #set koeff 4
  #} else {
  #  set koeff 5
  #}
  
  # верхнее левое большое окно
  # 
  set x1    $x_win
  set y1    $y_win
  set w1    $w_win ;# [expr int(160 * $koeff)]
  set h1    $h_win ;# [expr int(120 * $koeff)]
  
#   puts ""
#   puts "x1 = $x1"
#   puts "y1 = $y1"
#   puts ""

  # нижнее левое "сенсорное" окно
  # 
  set x0    $x1
  set y0    [expr $y1 + $h1 + $h_add] 
  set w0    $w_win ;# 480 ;# [expr int(120 * $koeff)]
  set h0    $h_win ;# 280 ;# [expr int( 70 * $koeff)]
  
  # верхнее правое большое окно
  # 
  set x2    [expr $x1 + $w1 + $w_add] 
  set y2    $y1
  set w2    $w1
  set h2    $h1

#   puts ""
#   puts "x1 = $x1"
#   puts "y1 = $y1"
#   puts ""

}
#-------------------------------------------------------------------------------
#
################################################################################

