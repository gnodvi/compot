# -*-   mode: text coding: koi8   -*- ------------------------------------------
--------------------------------------------------------------------------------

В процессе создания фреймворка COMPOT в целях тестирования и получения полезных 
научно-технгических результатов придерживаемся планов по разделам

--------------------------------------------------------------------------------


1. src/optima
 
  a) Fs_fitness_list должен побеждать в соревнованиях!
     gp_evolution, соответсвенно, должна работать через ga_evolution, но с
     Fs_fitness_list

  b) повторить новосибирские тесты для пары простых функций и с их подсчетом
     процентов достижения результатов.
     О.Г.Монахов, Э.А.Монахова "Параллельный алгоритм многовариантного
     эволюционного синтеза нелинейных моделей", 2017

    l~.tl TEST TEST_xx  -seed @ -lpop 20 -nums -1 -print 2 -vers 0 -func 'x **
    2' -list 'dup * +'
 
    слишком много полностью штрафных программ (в которых, возможно, один
    оператор только не выполнился) - надо сделать вариант "мягкого
    вычисления", т.е. 
       - перед выполнением каждого оператора сохраняем стек
       - если  выкидывает ошибку, то перехватываем ее и просто пропускаем
         оператор, восстанавливая стек.
         (r-1111.tl: r -> r_onw)

    Также это должно улучшить и работу версии с ga_evolution и фиксированной
    длиной хромосом, но там есть и своя какая-то проблема с вырождением:

    l~.tl TEST TEST_xx  -seed @ -lpop 20 -nums -1 -print 2 -vers 1 -func 'x **
    2' -list 'dup * +'
 
  с) подумать какой возможен вариант задания -func и -list в командной строке,
     чтобы можно было эти команды выплнять из моей системы тестирования ./OUT 

  d) после получения устоййчивого результата по многочлены 4-й степени тупым
     генетическим перебором, двигаемся дальше:
     
    - переводим gp_evolution полностью на систему item (программа в виде dict)
    - ga_evolution и gp_evolution приводим к общему виду  через параметры
    - включить в общую схему все другие алгоритмы (пчелы, сруск, диф-ный, отжиг,
      и т.д.,) как частные случаи механизма адаптации.

    - вводим систему блоков-библиотек, адаптируя операторы скрещивания и мутации
      и использую статистическое описание истории использования блоков.
    
    В итоге, поиск должен начинаться как случайный генетический и по мере накопления
    статистики использования блоков, становиться все осмысленнее и точнее.
    Сами адгоритмы поиска тоже должны подвергаться настроке через параметры,
    возможно используя, например,  алгоритмы глубоко оьучения, которые в свою
    очередь могуть являться настраиваемыми JOY-программами.


2. src/common

   - тип RECORD сделать для Dict/Jim и все остальное тоже!


3. ext/jimtcl

   - Makefile and patches for QNX (желательно через GIT).
   - новая версия с упорядоченным словарем dict.


4. src/dialog

   - все перевести на мою систему Dict/Tk.
   - подумать о прикручивании своей старой библиотеки yzone к JimTcl.

5. src/test-s/origin

   - игра Жизнь - заменить Snit на Dict/Tk, ввести правило "дальнодействия",
     т.е. разнети оценку и эффектор (через ребро, например), последовательное
     выполнение, и скрытые слои графов.
   - старый си-варинт и соответсвующий вариант мета убрать совсем? или,
     наоборот, оставить и сделать основой?

6) Пакет должен легко компилироваться и запускаться на тесты без сторонних
   библиотек (убрать asdf-l в lisper, он мне нужен редко и пока временно)

--------------------------------------------------------------------------------

