<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "HTTP://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="HTTP://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb" >
<head>
<title>
Dyalog APL - Subset of the Joy language.
</title>
<link rel="stylesheet" type="text/css" href="xhtml.css"/>
<meta http-equiv="Content-Language" content="en-gb"/>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="author" content="The D-Functionistas"/>
<meta name="description" content="Dyalog APL"/>
<meta name="generator" content=""/>
<meta name="keywords" content="apl,algorithms,computation,computers,computing,dfns,'direct definition',dyalog"/>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28909969-2 ']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>
<body>
<pre>
<span class=F>joy</span>←{                                             ⍝ Subset of the Joy language.
                                                  ⍝ (Manfred von Thun)
    <span class=F>eval</span>←{                                        ⍝ op list evaluation
        <span class=N>stk</span> <span class=N>I</span>(<span class=N>op</span> <span class=N>ops</span>)←⍵                           ⍝ stack and next operator
        <span class=N>(</span>⊂<span class=N>op)</span>∊⊃⍺:⍺ <span class=F>prt</span> <span class=N>stk</span> <span class=N>I((</span>⍺ <span class=F>dref</span> <span class=N>op)</span><span class=F>cat</span> <span class=N>ops)</span>  ⍝ name dereference from dict ⍺
        <span class=N>f</span>(<span class=N>fr</span> <span class=N>rr</span>)←<span class=N>f</span> <span class=N>r</span>←<span class=N>stk</span>                          ⍝ top two stack items
        <span class=F>c</span>←{<span class=N>op</span>≡⍵~' '}                              ⍝ case: match ignoring blanks

        <span class=F>c</span>'dip    ':⍺<span class=F>(</span>'*⌷'<span class=D>rgs</span>{⍺ <span class=F>prt</span> <span class=N>rr</span> <span class=N>I(f</span> <span class=F>cat</span> <span class=N>fr</span> <span class=N>ops)</span>}<span class=F>)</span>⍵ ⍝    [f] b → f b
        <span class=F>c</span>'cons   ':⍺<span class=F>(</span>'*⌷'<span class=D>rgs</span>{⍺ <span class=F>prt</span><span class=N>((fr</span> <span class=N>f)rr)I</span> <span class=N>ops</span>}<span class=F>)</span>⍵     ⍝    a [b] → [a b]
        <span class=F>c</span>'i      ':⍺<span class=F>(</span>'⌷'<span class=D>rgs</span>{⍺ <span class=F>prt</span> <span class=N>r</span> <span class=N>I(f</span> <span class=F>cat</span> <span class=N>ops)</span>}<span class=F>)</span>⍵      ⍝      [f] → f
        <span class=F>c</span>'swap   ':⍺<span class=F>(</span>'**'<span class=D>rgs</span>{⍺ <span class=F>prt</span><span class=N>(fr(f</span> <span class=N>rr))I</span> <span class=N>ops</span>}<span class=F>)</span>⍵     ⍝      a b → b a
        <span class=F>c</span>'branch ':⍺<span class=F>(</span>'∧⌷⌷'<span class=D>rgs</span> <span class=F>branch)</span>⍵                   ⍝ c[t] [f] → c:t⋄f
        <span class=F>c</span>'stack  ':⍺ <span class=F>prt</span><span class=N>(stk</span> <span class=N>stk)I</span> <span class=N>ops</span>                   ⍝      a b → a b [b a]
        <span class=F>c</span>'unstack':⍺<span class=F>(</span>'⌷'<span class=D>rgs</span>{⍺ <span class=F>prt</span> <span class=N>f</span> <span class=N>I</span> <span class=N>ops</span>}<span class=F>)</span>⍵             ⍝  c [a b] → b a
        <span class=F>c</span>'concat ':⍺<span class=F>(</span>'⌷⌷'<span class=D>rgs</span>{⍺ <span class=F>prt</span><span class=N>((fr</span> <span class=F>cat</span> <span class=N>f)rr)I</span> <span class=N>ops</span>}<span class=F>)</span>⍵ ⍝   [a][b] → [a b]
        <span class=F>c</span>'uncons ':⍺<span class=F>(</span>'⍞'<span class=D>rgs</span> <span class=F>uncons)</span>⍵                     ⍝    [a b] → a [b]
        <span class=F>c</span>'small  ':⍺<span class=F>(</span>'*'<span class=D>rgs</span><span class=F>(</span>1 <span class=M>smallish</span><span class=F>))</span>⍵                ⍝            ∊ 0[]1[a]
        <span class=F>c</span>'pop    ':⍺<span class=F>(</span>'*'<span class=D>rgs</span>{⍺ <span class=F>prt</span> <span class=N>r</span> <span class=N>I</span> <span class=N>ops</span>}<span class=F>)</span>⍵             ⍝      a b → a
        <span class=F>c</span>'null   ':⍺<span class=F>(</span>'*'<span class=D>rgs</span><span class=F>(</span>0 <span class=M>smallish</span><span class=F>))</span>⍵                ⍝            ∊ 0[]
        <span class=F>c</span>'pred   ':⍺<span class=F>(</span>'1'<span class=D>rgs</span>{⍺ <span class=F>prt</span><span class=N>((</span>¯1 <span class=F>adj</span> <span class=N>f)r)I</span> <span class=N>ops</span>}<span class=F>)</span>⍵   ⍝        n → --n
        <span class=F>c</span>'succ   ':⍺<span class=F>(</span>'0'<span class=D>rgs</span>{⍺ <span class=F>prt</span><span class=N>((</span>1 <span class=F>adj</span> <span class=N>f)r)I</span> <span class=N>ops</span>}<span class=F>)</span>⍵    ⍝        n → ++n
        <span class=F>c</span>'dup    ':⍺<span class=F>(</span>'*'<span class=D>rgs</span>{⍺ <span class=F>prt</span><span class=N>(f(f</span> <span class=N>r))I</span> <span class=N>ops</span>}<span class=F>)</span>⍵        ⍝      a b → a b b
        <span class=F>c</span>'swons  ':⍺<span class=F>(</span>'⌷*'<span class=D>rgs</span>{⍺ <span class=F>prt</span><span class=N>((f</span> <span class=N>fr)rr)I</span> <span class=N>ops</span>}<span class=F>)</span>⍵     ⍝    [a] b → [b a]
        <span class=F>c</span>'reverse':⍺<span class=F>(</span>'⌷'<span class=D>rgs</span>{⍺ <span class=F>prt</span><span class=N>((</span>'∘'<span class=F>rev</span> <span class=N>f)r)I</span> <span class=N>ops</span>}<span class=F>)</span>⍵   ⍝    [a b] → [b a]
        <span class=F>c</span>'step   ':⍺<span class=F>(</span>'⌷⌷'<span class=D>rgs</span> <span class=F>step)</span>⍵                      ⍝ [a b][f] → a f b f
        <span class=F>c</span>'times  ':⍺<span class=F>(</span>'0⌷'<span class=D>rgs</span> <span class=F>times)</span>⍵                     ⍝    n [f] → f --n [f]
        <span class=F>c</span>'id     ':⍺ <span class=F>prt</span> <span class=N>stk</span> <span class=N>I</span> <span class=N>ops</span>                       ⍝        a → a
        <span class=F>c</span>'primrec':⍺<span class=F>(</span>'*⌷⌷'<span class=D>rgs</span> <span class=F>primrec)</span>⍵                  ⍝ primitive recursion
        <span class=F>c</span>'binrec ':⍺<span class=F>(</span>'⌷⌷⌷⌷'<span class=D>rgs</span> <span class=F>binrec)</span>⍵                  ⍝ binary recursion
        ∨/<span class=F>c</span>¨⊃<span class=N>arith</span>:⍺<span class=F>(</span>'00'<span class=D>rgs</span> <span class=F>arth)</span>⍵                      ⍝ arithmetic functions
        ∨/<span class=F>c</span>¨⊃<span class=N>relat</span>:⍺<span class=F>(</span>'00'<span class=D>rgs</span> <span class=F>rels)</span>⍵                      ⍝ relational functions
        <span class=F>c</span>'DEFINE ':⍺ <span class=F>define</span> <span class=N>stk</span> <span class=N>I</span> <span class=N>ops</span>                    ⍝ a == ..; b == ..; .
        <span class=F>c</span>'quit   ':<span class=N>stk</span> <span class=N>I</span>'∘'                              ⍝ exit returning stack
        ⍺ <span class=F>prt</span><span class=N>(op</span> <span class=N>stk)I</span> <span class=N>ops</span>                               ⍝ default: op → stack
    }                                                    ⍝ :: Repl (see below)

    ⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝ primitive operators and define:

    <span class=F>uncons</span>←{                                ⍝ uncons: separation of first item
        (<span class=N>stk</span>(<span class=N>hd</span> <span class=N>tl</span>))<span class=N>I</span>(<span class=N>op</span> <span class=N>ops</span>)←⍵             ⍝     [a b c]
        ⍺ <span class=F>prt</span><span class=N>(tl(hd</span> <span class=N>stk))I</span> <span class=N>ops</span>              ⍝ →   a [b c]
    }                                       ⍝ :: Oper

    <span class=F>step</span>←{                                  ⍝ step: op applied to list items
        (<span class=N>stk</span> <span class=N>list</span> <span class=N>seq</span>)<span class=N>I</span>(<span class=N>op</span> <span class=N>ops</span>)←⍵           ⍝ [a b] [ops] │ step
        <span class=N>list</span>≡'∘':⍺ <span class=F>prt</span> <span class=N>stk</span> <span class=N>I</span> <span class=N>ops</span>            ⍝ null list: done
        <span class=N>hd</span> <span class=N>tl</span>←<span class=N>list</span>                          ⍝ head and tail of list
        <span class=N>nxt</span>←<span class=N>seq</span> <span class=F>cat</span> <span class=N>tl(seq(op</span> <span class=N>ops))</span>         ⍝ recursive call on step
        ⍺ <span class=F>prt</span><span class=N>(hd</span> <span class=N>stk)I</span> <span class=N>nxt</span>                  ⍝ → a │ ops [b] [ops] step
    }                                       ⍝ :: Oper

    <span class=F>times</span>←{                                 ⍝ times: iteration
        (<span class=N>stk</span> <span class=N>count</span> <span class=N>seq</span>)<span class=N>I</span>(<span class=N>op</span> <span class=N>ops</span>)←⍵          ⍝ count and operand sequence
        <span class=N>count</span>≡,'0':⍺ <span class=F>prt</span> <span class=N>stk</span> <span class=N>I</span> <span class=N>ops</span>          ⍝ 0 [seq]│ →  │
        <span class=N>pred</span>←¯1 <span class=F>adj</span> <span class=N>count</span>                   ⍝ --n
        <span class=N>nxt</span>←<span class=N>seq</span> <span class=F>cat</span> <span class=N>pred(seq(op</span> <span class=N>ops))</span>       ⍝ next iteration
        ⍺ <span class=F>prt</span> <span class=N>stk</span> <span class=N>I</span> <span class=N>nxt</span>                     ⍝ n [seq]│ →  │seq --n[seq]times
    }                                       ⍝ :: Oper

    <span class=F>branch</span>←{                                ⍝  true [t] [f] → t
        (<span class=N>stk</span> <span class=N>torf</span> <span class=N>t</span> <span class=N>f</span>)<span class=N>I</span>(<span class=N>op</span> <span class=N>ops</span>)←⍵           ⍝ false [t] [f] → f
        ''≡<span class=N>seq</span>←<span class=N>torf</span> <span class=F>pick</span> <span class=N>f</span> <span class=N>t</span>:⍺ <span class=F>error</span> ⍵      ⍝ neither true nor false: error
        ⍺ <span class=F>prt</span> <span class=N>stk</span> <span class=N>I(seq</span> <span class=F>cat</span> <span class=N>ops)</span>            ⍝ eval of selected branch
    }                                       ⍝ :: Oper

    <span class=M>smallish</span>←<span class=M>{</span>                              ⍝ 0-null or 1-small
        (<span class=N>stk</span> <span class=N>val</span>)<span class=N>I</span>(<span class=N>op</span> <span class=N>ops</span>)←⍵                ⍝ stack and ops
        <span class=F>null</span> <span class=N>val</span>:⍺ <span class=F>prt</span><span class=N>(</span>'true'<span class=N>stk)I</span> <span class=N>ops</span>      ⍝ 0 or []: true
        ⍺⍺=0:⍺ <span class=F>prt</span><span class=N>(</span>'false'<span class=N>stk)I</span> <span class=N>ops</span>         ⍝ null: fails
        <span class=N>small</span>←<span class=F>bool</span><span class=N>(val</span>≡,'1'<span class=N>)</span>∨'∘'≡⊃⌽<span class=N>val</span>      ⍝ 1 or [val]: true
        ⍺ <span class=F>prt</span><span class=N>(small</span> <span class=N>stk)I</span> <span class=N>ops</span>               ⍝ true or false
    <span class=M>}</span>                                       ⍝ ⍺⍺ ∇∇ :: Oper

    <span class=F>arth</span>←{                                  ⍝ primitive arithmetic: + - * / ...
        (<span class=N>stk</span> <span class=N>m</span> <span class=N>n</span>)<span class=N>I</span>(<span class=N>op</span> <span class=N>ops</span>)←⍵                ⍝ m &amp; n are numeric values
        <span class=F>neg</span>←{<span class=N>(</span>,'1'<span class=N>)</span>≡⍺&lt;<span class=M>nats</span> ⍵}⍣<span class=N>(op</span>≡,'-'<span class=N>)</span>     ⍝ negative number test
        1≡<span class=N>m</span> <span class=F>neg</span> <span class=N>n</span>:⍺ <span class=F>error</span> ⍵                 ⍝ negative: error
        <span class=N>op</span> <span class=N>n</span>∧.≡,¨'/0':⍺ <span class=F>error</span> ⍵             ⍝ divide-by-0: error
        <span class=r>fn</span>←⍎<span class=N>arith</span> <span class=F>dref</span> <span class=N>op</span>                   ⍝ equivalent APL function
        ⍺ <span class=F>prt</span><span class=N>((m</span> <span class=r>fn</span> <span class=M>nats</span> <span class=N>n)stk)I</span> <span class=N>ops</span>        ⍝ m n│+ → (m+n)│ etc
    }                                       ⍝ :: Oper

    <span class=F>rels</span>←{                                  ⍝ primitive relational: &lt; &lt;= = ...
        (<span class=N>stk</span> <span class=N>m</span> <span class=N>n</span>)<span class=N>I</span>(<span class=N>op</span> <span class=N>ops</span>)←⍵                ⍝ m &amp; n are numeric values
        <span class=r>fn</span>←⍎<span class=N>relat</span> <span class=F>dref</span> <span class=N>op</span>                   ⍝ equivalent APL function
        ⍺ <span class=F>prt</span><span class=N>(</span><span class=r>(</span><span class=F>bool</span>⍎<span class=N>m</span> <span class=r>fn</span> <span class=M>nats</span> <span class=N>n</span><span class=r>)</span><span class=N>stk)I</span> <span class=N>ops</span>   ⍝ m n│&lt; → (m&lt;n)│ etc
    }                                       ⍝ :: Oper

    <span class=F>primrec</span>←{                               ⍝ primitive recursion
        (<span class=N>stk</span> <span class=N>val</span> <span class=N>acc</span> <span class=N>seq</span>)<span class=N>I</span>(<span class=N>op</span> <span class=N>ops</span>)←⍵        ⍝ stack and operators
        <span class=F>null</span> <span class=N>val</span>:⍺ <span class=F>prt</span><span class=N>(acc</span> <span class=F>cat</span> <span class=N>stk)I</span> <span class=N>ops</span>    ⍝ null[acc][seq] → acc
        '?'≡<span class=N>hd</span> <span class=N>tl</span>←{                         ⍝ deconstruction of value ⍵:
            <span class=F>num</span> ⍵:⍵<span class=N>(</span>¯1 <span class=F>adj</span> ⍵<span class=N>)</span>               ⍝ number: self and predecessor
            <span class=F>atom</span> ⍵:'?' ⋄ ⍵                  ⍝ list:   head and tail
        }<span class=N>val</span>:⍺ <span class=F>error</span> ⍵                      ⍝ no prior: error
        <span class=N>stk</span>←<span class=F>list</span> <span class=N>seq</span> <span class=N>acc</span> <span class=N>tl</span> <span class=N>stk</span>             ⍝ tail[acc][seq]│
        <span class=N>nxt</span>←<span class=F>list</span> <span class=N>op</span> <span class=N>hd</span>'swap'<span class=N>(seq</span> <span class=F>cat</span> <span class=N>ops)</span>   ⍝   │primrec head swap seq ...
        ⍺ <span class=F>prt</span> <span class=N>stk</span> <span class=N>I</span> <span class=N>nxt</span>                     ⍝ recurse
    }                                       ⍝ :: Oper

    <span class=F>binrec</span>←{                                ⍝ binary recursion
        (<span class=N>stk</span> <span class=N>T</span> <span class=N>B</span> <span class=N>F</span> <span class=N>J</span>)<span class=N>I</span>(<span class=N>op</span> <span class=N>ops</span>)←⍵            ⍝ test, base, fork, join
        <span class=N>sub</span>←<span class=F>list</span> <span class=N>T</span> <span class=N>B</span> <span class=N>F</span> <span class=N>J</span> <span class=N>op</span>'∘'              ⍝ sub == [T] [B] [F] [J] binrec
        <span class=N>lft</span>←<span class=F>list</span> <span class=N>sub</span>'dip' '∘'               ⍝ lft == [sub]dip
        <span class=N>rec</span>←↑<span class=F>cat</span>/<span class=N>F</span> <span class=N>lft</span> <span class=N>sub</span> <span class=N>J</span>                ⍝ rec == [F] lft sub J
        <span class=N>nxt</span>←<span class=F>list</span> <span class=N>T</span> <span class=N>B</span> <span class=N>rec</span>'ifte'<span class=N>ops</span>           ⍝ nxt == [T] [B] [rec] ifte ...
        ⍺ <span class=F>prt</span> <span class=N>stk</span> <span class=N>I</span> <span class=N>nxt</span>                     ⍝ recurse
    }                                       ⍝ :: Oper

    <span class=F>define</span>←{                                ⍝ extended dictionary
        <span class=N>_</span> <span class=N>_</span>(<span class=N>_</span>(<span class=N>eq</span> <span class=N>rrr</span>))←<span class=N>stk</span> <span class=N>I</span>(<span class=N>name</span> <span class=N>rr</span>)←⍵     ⍝ name == defn .
        <span class=N>name</span>≡,'.':⍺ <span class=F>prt</span> <span class=N>stk</span> <span class=N>I</span> <span class=N>rr</span>            ⍝ null defn: 'DEFINE == .'
        ~<span class=N>eq</span>≡'==':⍺ <span class=F>err</span> ⍵                    ⍝ missing ==
        <span class=N>body</span> <span class=N>ops</span> <span class=N>term</span>←'∘'{                  ⍝ defn body and remainder
            ⍵≡'∘':⍺ ∇<span class=N>(</span>,'.'<span class=N>)</span>⍵                ⍝ end of tokens: gratuitous dot
            <span class=N>f</span> <span class=N>r</span>←⍵                           ⍝ first and remaining tokens
            ~<span class=N>(</span>⊂<span class=N>f)</span>∊,¨'.;':<span class=N>f</span> ⍺ ∇ <span class=N>r</span>            ⍝ more: accumulated defn
            <span class=N>(</span>'∘'<span class=F>rev</span> ⍺<span class=N>)r</span> <span class=N>f</span>                   ⍝ end of defn
        }<span class=N>rrr</span>                                ⍝ body of definition
        <span class=N>dict</span>←↓<span class=N>name</span> <span class=N>body</span>,↑⍺                  ⍝ extended dictionary
        <span class=N>term</span>≡,';':<span class=N>dict</span> ∇ <span class=N>stk</span> <span class=N>I</span> <span class=N>ops</span>          ⍝ more defs: a=b; c=d;...
        <span class=N>dict</span> <span class=F>prt</span> <span class=N>stk</span> <span class=N>I</span> <span class=N>ops</span>                  ⍝ evaluation of remaining ops
    }                                       ⍝ :: Repl

    <span class=F>error</span>←{                                 ⍝ primitive operator error
        <span class=N>sargs</span> <span class=N>I</span> <span class=N>ops</span>←⍵                       ⍝ state with uncurried args
        <span class=N>stk</span> <span class=N>args</span>←<span class=N>(</span>⊃<span class=N>sargs)(</span>1↓<span class=N>sargs)</span>          ⍝ stack and arg-vector
        <span class=N>arity</span>←¯1+⍴<span class=N>sargs</span>                     ⍝ number of args
        ⍺ <span class=F>err</span>{⍵ <span class=N>I</span> <span class=N>ops</span>}<span class=N>arity</span>{                ⍝ print error &amp; continue
            ⍺=0:<span class=N>stk</span>                         ⍝ end of arg vector
            <span class=N>(</span>⊃⍵<span class=N>)((</span>⍺-1<span class=N>)</span>∇ 1↓⍵<span class=N>)</span>                ⍝ first and remainder
        }⌽<span class=N>sargs</span>                             ⍝ reversed for stack
    }                                       ⍝ :: Oper

    ⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝ support functions:

    <span class=F>adj</span>←{                                   ⍝ ⍺-adjacent number, succ or pred
        ⍵≡,⊃⍺⌽'??0':'?'                     ⍝ 0 pred: error
        <span class=N>w</span> <span class=N>f</span>←<span class=N>(</span>0⌈⍺<span class=N>)</span>⌽'09'                      ⍝ wrap and fill digits
        <span class=N>n</span>←-+/∧\<span class=N>w</span>=⌽⍵                         ⍝ number of trailing wrap digits
        <span class=N>h</span>←<span class=N>n</span>↓⍵                               ⍝ leading non-wrap digits
        <span class=N>d</span>←<span class=N>(</span>⎕D⍳⊃⌽<span class=N>h)</span>⊃<span class=N>(</span>⍺⌽⎕D<span class=N>)</span>,'1'               ⍝ carried-to digit
        <span class=N>v</span>←<span class=N>(</span>¯1↓<span class=N>h)</span>,<span class=N>d</span>,<span class=N>(</span>-<span class=N>n)</span>/<span class=N>f</span>                   ⍝ adjacent number
        <span class=N>((n</span>≠0<span class=N>)</span>∧'0'≡⊃<span class=N>v)</span>↓<span class=N>v</span>                    ⍝   normalised
    }                                       ⍝ :: num ← dirn ∇ num

    <span class=F>dump</span>←{                                  ⍝ formatted dump of machine state ⍵
        <span class=N>stk</span> <span class=N>I</span> <span class=N>ops</span>←⍵                         ⍝ final machine state
        <span class=N>fstk</span> <span class=N>fops</span>←<span class=N>stk</span> <span class=F>fmts</span> <span class=N>ops</span>              ⍝ format of stack and op stream
        <span class=N>fstk</span>,<span class=N>(</span>×⍴<span class=N>fops)</span>/'│',<span class=N>fops</span>              ⍝ stack[│any remaining operators]
    }                                       ⍝ :: ⍞ ← ∇ State

    <span class=F>fmt</span>←{                                   ⍝ format of cons list
        ⍵≡'∘':''                            ⍝ end of list: done
        <span class=N>f</span> <span class=N>r</span>←⍵                               ⍝ first and rest
        <span class=F>join</span>←{⍺,<span class=N>(</span>⍵≡''<span class=N>)</span>↓' ',⍵}               ⍝ blank separated
        <span class=F>atom</span> <span class=N>f</span>:<span class=N>(</span>⍕<span class=N>f)</span><span class=F>join</span> ∇ <span class=N>r</span>                 ⍝ format of atom
        '[',<span class=N>(</span>∇ <span class=N>f)</span>,']'<span class=F>join</span> ∇ <span class=N>r</span>               ⍝ format of list
    }                                       ⍝ :: ⍞ ← ∇ List

    <span class=D>rgs</span>←<span class=D>{</span>                                   ⍝ valence and type checking
        <span class=N>stk</span> <span class=N>I</span> <span class=N>ops</span>←⍵                         ⍝ machine state
        ~<span class=r>(</span><span class=F>list</span>⌽'∘',⍺⍺<span class=r>)</span>{                     ⍝ ⍺⍺ is pattern vector
            ⍺≡'∘':1                         ⍝ all patterns matched: ok
            ⍵≡'∘':0                         ⍝ too few args: fails
            (<span class=N>p</span> <span class=N>q</span>)(<span class=N>f</span> <span class=N>r</span>)←⍺ ⍵                  ⍝ next patn and value
            ~<span class=N>q</span> ∇ <span class=N>r</span>:0                        ⍝ following patterns fail
            '*'=<span class=N>p</span>:1                         ⍝ * matches anything
            '⌷'=<span class=N>p</span>:~<span class=F>atom</span> <span class=N>f</span>                   ⍝ ⌷ matches list
            '0'=<span class=N>p</span>:<span class=F>num</span> <span class=N>f</span>                     ⍝ 0 matches number
            '1'=<span class=N>p</span>:<span class=N>(</span><span class=F>num</span> <span class=N>f)</span>∧~<span class=N>f</span>≡,'0'           ⍝ 1 matches non-zero number
            '∧'=<span class=N>p</span>:<span class=F>tval</span> <span class=N>f</span>                    ⍝ ∧ matches true, false
            '⍞'=<span class=N>p</span>:<span class=N>(</span>~<span class=F>atom</span> <span class=N>f)</span>∧~<span class=N>f</span>≡'∘'          ⍝ ⍞ matches non-empty list
        }<span class=N>stk</span>:⍺ <span class=F>err</span> ⍵                        ⍝ bad args: error
        ⍺ ⍵⍵{⍵ <span class=N>I</span> <span class=N>ops</span>}<span class=r>(</span>≢⍺⍺<span class=r>)</span><span class=F>pop</span> <span class=N>stk</span>           ⍝ stack, arg vector
    <span class=D>}</span>                                       ⍝ Patn ∇∇ Oper :: Oper

    <span class=F>lex</span>←{                                   ⍝ word list from source vector
        <span class=N>wsp</span>←⎕UCS 13 32 133                  ⍝ version-proof white space.
        <span class=N>wht</span>←1,⍵∊<span class=N>wsp</span>                         ⍝ mask for white-space separation
        <span class=N>tk1</span>←{⍵∨¯1⌽⍵}<span class=N>(</span>⍵∊'[];.⊢⊣'<span class=N>)</span>,0          ⍝ mask for single-char tokens
        <span class=N>wds</span>←~∘<span class=N>(</span>⊂''<span class=N>)</span>~∘<span class=N>wsp</span>¨<span class=N>(wht</span>∨<span class=N>tk1)</span>⊂⍵,' '    ⍝ char-vector words
        <span class=N>cnd</span>←'(*' '*)'<span class=F>depth</span> <span class=N>wds</span>              ⍝ comment nesting depth
        0&gt;⊃⌽<span class=N>cnd</span>:'∘'                         ⍝ too many closing *)s: ignore line
        <span class=N>toks</span>←<span class=N>(</span>{⍵⍱¯1⌽⍵}×<span class=N>cnd)</span>/<span class=N>wds</span>             ⍝ uncommented
        0=⍴<span class=N>toks</span>:'∘'                         ⍝ null token list.
        <span class=N>deps</span>←'[]'<span class=F>depth</span> <span class=N>toks</span>                 ⍝ bracket-depth for each token
        0=⊃⌽<span class=N>deps</span>:<span class=F>toklist</span> <span class=N>toks</span>               ⍝ brackets balance: list of tokens
        <span class=N>ok</span>←+/∨\⌽<span class=N>deps</span>=0                      ⍝ number of leading good tokens
        <span class=N>bad</span>←<span class=F>list</span> <span class=N>ok</span>↓<span class=N>toks</span>,'∘'                ⍝ trailing bad tokens
        <span class=N>(</span><span class=F>toklist</span> <span class=N>ok</span>↑<span class=N>toks)</span><span class=F>cat</span>'┼'<span class=N>bad</span>          ⍝   separated by error token
    }                                       ⍝ :: Oseq ← ∇ ⍞

    <span class=F>toklist</span>←{                               ⍝ list from vector of tokens
        '∘'<span class=F>rev</span>'∘'{                          ⍝ reverse of list from token vector
            ⍵≡'∘':⍺                         ⍝ list exhausted: done
            <span class=N>f</span> <span class=N>r</span>←⍵                           ⍝ first and rest
            <span class=N>f</span>≡,']':⍺ <span class=N>r</span>                      ⍝ ] list and remainder
            ~<span class=N>f</span>≡,'[':<span class=N>(f</span> ⍺<span class=N>)</span>∇ <span class=N>r</span>                ⍝ atom
            <span class=N>ls</span> <span class=N>rem</span>←'∘'∇ <span class=N>r</span>                   ⍝ [ sublist
            <span class=N>(</span>'∘'<span class=F>rev</span> <span class=N>ls)</span>⍺ ∇ <span class=N>rem</span>              ⍝ reverse of sublist
        }<span class=F>list</span> ⍵,'∘'                         ⍝ embedding of sublists
    }                                       ⍝ :: List Word ← ∇ [Word]

    <span class=N>offset</span>←⌊⎕PW÷4                           ⍝ initial offet of │-separator
    ⍺←0                                     ⍝ repl: prompt for input.

    <span class=F>prt</span>←⍺<span class=M>{</span>                                  ⍝ print machine state
        (<span class=N>f</span> <span class=N>r</span>)<span class=N>_</span>(<span class=N>_</span> <span class=N>rr</span>)←<span class=N>estk</span> <span class=N>I</span> <span class=N>ops</span>←⍵           ⍝ machine state
        <span class=N>f</span>≡,'⊢':⍺ ∇ <span class=N>r(</span>-|<span class=N>I)ops</span>                ⍝ ⊢: tracing on:  -ive I
        <span class=N>f</span>≡,'⊣':⍺ <span class=F>eval</span> <span class=N>r(</span>+|<span class=N>I)ops</span>             ⍝ ⊣: tracing off: +ive I
        <span class=N>more</span>←<span class=N>f</span> <span class=N>ops</span>⍱.≡'┼∘'                   ⍝ unless error or no operators
        <span class=N>more</span>∧<span class=N>I</span>≥0:⍺ <span class=F>eval</span> ⍵                   ⍝   and not tracing: continue
        <span class=N>stk</span>←<span class=N>(f</span>≡'┼'<span class=N>)</span><span class=F>tail</span> <span class=N>estk</span>                ⍝ stack without error token
        <span class=N>fstk</span> <span class=N>fops</span>←<span class=N>stk</span> <span class=F>fmts</span> <span class=N>ops</span>              ⍝ formatted stack and ops
        <span class=N>fill</span>←<span class=N>(</span>|<span class=N>I)</span>⍴<span class=N>(I</span>≥0<span class=N>)</span>↓'·'                 ⍝ traced line filled with ···
        <span class=F>trim</span>←{<span class=N>((</span>⎕PW-1<span class=N>)</span>⌊⍴⍵<span class=N>)</span>↑⍵}               ⍝ trim at print-width
        <span class=N>pmt</span>←<span class=F>trim</span><span class=N>((</span>-|<span class=N>I)</span>↑<span class=N>fill</span>,<span class=N>fstk)</span>,'│',<span class=N>fops</span>  ⍝ prompt with machine state
        <span class=N>more</span>∧<span class=N>I</span>&lt;0:⍺ <span class=F>eval</span> <span class=N>stk</span> <span class=N>I</span> <span class=N>ops</span>⊣⎕←<span class=N>pmt</span>     ⍝ tracing: continue
        ~⍺⍺:<span class=N>stk</span> <span class=N>I</span> <span class=N>ops</span>                       ⍝ not repl: quit on read
        ⍞←<span class=N>pmt</span>                               ⍝ display machine state
        ⍺ <span class=F>read</span> <span class=N>stk</span> <span class=N>I</span> <span class=N>rr</span>                     ⍝ else: read more opers
    <span class=M>}</span>                                       ⍝ ⍺⍺ ∇∇ :: Repl

    <span class=F>read</span>←{                                  ⍝ read of operator stream
        <span class=N>stk</span> <span class=N>I</span> <span class=N>_</span>←⍵                           ⍝ ops stream is empty
        <span class=N>buff</span>←⍞                              ⍝ char vector buffer
        <span class=N>J</span>←+/∧\<span class=N>buff</span>≠'│'                      ⍝ possibly changed │-offset
        <span class=N>ops</span>←<span class=F>lex</span><span class=N>(J</span>+1<span class=N>)</span>↓<span class=N>buff</span>                   ⍝ next expression to evaluate
        ⍺ <span class=F>eval</span> <span class=N>stk(J</span>××<span class=N>I)ops</span>                 ⍝ stack and operators
    }                                       ⍝ :: Repl

    <span class=F>depth</span>←{+\1 ¯1 0[<span class=N>(</span>,¨⍺<span class=N>)</span>⍳⍵]}               ⍝ ⍺-nesting depth
    <span class=F>atom</span>←{<span class=N>(</span>~'∘'∊⍵<span class=N>)</span>∧1=≡,⍵}                   ⍝ is an atom?
    <span class=F>num</span>←{∧/⍵∊⎕D}                            ⍝ is a number?
    <span class=F>tval</span>←{<span class=N>(</span>⊂⍵<span class=N>)</span>∊'true' 'false'}              ⍝ is a truth-value?
    <span class=F>null</span>←{<span class=N>(</span>⊂⍵<span class=N>)</span>∊<span class=N>(</span>,'0'<span class=N>)</span>'∘'}                   ⍝ is null?
    <span class=F>tail</span>←{⍺=0:⍵ ⋄ <span class=N>(</span>⍺-1<span class=N>)</span>∇ <span class=N>t</span>⊣<span class=N>h</span> <span class=N>t</span>←⍵}           ⍝ ⍺-tail of list
    <span class=F>bool</span>←{⊃⍵⌽'false' 'true'}                ⍝ 0 1 → 'false' 'true'
    <span class=F>pick</span>←{<span class=N>(</span>'false' 'true'⍳⊂⍺<span class=N>)</span>⊃⍵,⊂''}        ⍝ 'false' 'true'⊃ ⍵
    <span class=F>rev</span>←{⍵≡'∘':⍺ ⋄ <span class=N>f</span> <span class=N>r</span>←⍵ ⋄ <span class=N>f</span> ⍺ ∇ <span class=N>r</span>}         ⍝ reversed list: (⌽⍵),⍺
    <span class=F>cat</span>←{⍺≡'∘':⍵ ⋄ <span class=N>f</span> <span class=N>r</span>←⍺ ⋄ <span class=N>f(r</span> ∇ ⍵<span class=N>)</span>}        ⍝ list catenation: ⍺,⍵
    <span class=F>pop</span>←{⍺=0:⊂⍵ ⋄ <span class=N>f</span> <span class=N>r</span>←⍵ ⋄ <span class=N>((</span>⍺-1<span class=N>)</span>∇ <span class=N>r)</span>,⊂<span class=N>f</span>}    ⍝ ⍺ items and tail from stack ⍵
    <span class=F>dref</span>←{<span class=N>names</span> <span class=N>vals</span>←⍺ ⋄ <span class=N>(names</span>⍳⊂⍵<span class=N>)</span>⊃<span class=N>vals</span>}   ⍝ value for name ⍵ in dictionary ⍺
    <span class=N>relat</span>←<span class=N>(</span>,¨'&lt;=&gt;','&lt;!&gt;',¨'='<span class=N>)</span>'&lt;=&gt;≤≠≥'      ⍝ relational functions
    <span class=N>arith</span>←<span class=N>(</span>,¨'+-*/|'<span class=N>)</span>'+-×÷|'                ⍝ arithmetic functions
    <span class=F>err</span>←{<span class=N>stk</span> <span class=N>I</span> <span class=N>ops</span>←⍵ ⋄ ⍺ <span class=F>prt</span><span class=N>(</span>'┼'<span class=N>stk)I</span> <span class=N>ops</span>}  ⍝ error token in op stream
    <span class=F>fmts</span>←{<span class=N>(</span><span class=F>fmt</span>'∘'<span class=F>rev</span> ⍺<span class=N>)(</span><span class=F>fmt</span> ⍵<span class=N>)</span>}             ⍝ format of stack and operators
    <span class=F>list</span>←{↑{⍺ ⍵}/⍵}                         ⍝ list from vector ⍵

    ⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝⍝ coded-in-joy operators

    <span class=F>dump</span> ⍬ ⍬ <span class=F>eval</span>{'∘'<span class=N>offset</span> ⍵}<span class=F>lex</span>{          ⍝ defined operators:
        'DEFINE                                                         ',⍵}{
        'popd     == [pop]dip ;                                         ',⍵}{
        'pop2     == pop pop ;                                          ',⍵}{
        'dupd     == [dup]dip ;                                         ',⍵}{
        'unit     == []cons ;                                           ',⍵}{
        'swapd    == [swap]dip ;                                        ',⍵}{
        'dip2     == [dip]cons dip ;                                    ',⍵}{
        'dip3     == [dip2]cons dip ;                                   ',⍵}{
        'rollup   == swap swapd ;                                       ',⍵}{
        'rolldown == swapd swap ;                                       ',⍵}{
        'rotate   == rollup swap ;                                      ',⍵}{
        'swoncat  == swap concat ;                                      ',⍵}{
        'shunt    == [swons]step ;                                      ',⍵}{
        'infra    == [reverse]dip concat [stack]dip swap                ',⍵}{
        '            [[[]unstack]dip i stack]dip                        ',⍵}{
        '            swap [unstack]dip reverse ;                        ',⍵}{
        'linrec   == [] 4[cons]times dup [4[uncons]times]dip            ',⍵}{
        '            [rolldown]dip concat [pop]dip [linrec]concat       ',⍵}{
        '            swoncat ifte ;                                     ',⍵}{
        'cleave   == [nullary]dip dip swap ;                            ',⍵}{
        'rem      == swap | ;                                           ',⍵}{
        'div      == dupd dup rollup rem [/]dip ;                       ',⍵}{
        'not      == [false][true]branch ;                              ',⍵}{
        'size     == 0 swap [pop succ]step ;                            ',⍵}{
        'ifte     == [nullary]dip2 branch ;                             ',⍵}{
        'fold     == swapd step ;                                       ',⍵}{
        'map      == [[]]dip2                                           ',⍵}{
        '            unit [unary]concat                                 ',⍵}{
        '            unit [dip cons]concat                              ',⍵}{
        '            [swap]swoncat step reverse ;                       ',⍵}{
        'append   == reverse cons reverse ;                             ',⍵}{
        'split    == [[][]]dip2                                         ',⍵}{
        '            [dip2]cons [rollup]swoncat [rolldown]concat        ',⍵}{
        '            [[swons][[swap]dip swons swap]ifte] cons           ',⍵}{
        '            step reverse swap reverse ;                        ',⍵}{
        'filter   == split pop ;                                        ',⍵}{
        'nullary  == stack [i]dip cons unstack swap pop ;               ',⍵}{
        'unary    == stack [i]dip cons unstack [pop2]dip ;              ',⍵}{
        'cond     == [small]nullary [i i] [uncons [uncons]dip           ',⍵}{
        '            [[nullary]dip]dip [cond]cons branch]branch ;       ',⍵}{
        'enconcat == swapd cons concat .                                ',⍵}⍵

    ⍝ Type definitions:
    ⍝     joy   ::  ⍞ ← ∇ ⍞                 ⍝ type of this function
    ⍝    Repl   :=  State ← Dict ∇ State    ⍝ state reduction
    ⍝    Oper   :=  State ← Dict ∇ Sargs    ⍝ primitive operator
    ⍝   Sargs   :=  Stack, [Value]          ⍝ vector: (⊂stack),args
    ⍝    Dict   :=  [Name] [Oseq]           ⍝ name-value association tuple
    ⍝   State   :=  Stack Disp Oseq         ⍝ machine state
    ⍝    Disp   :=  offset                  ⍝ (-ive during tracing)
    ⍝    List ⍵ :=  '∘' | ⍵ (List ⍵)        ⍝ f(fr(frr ...))
    ⍝    Oseq   :=  List Word               ⍝ operator sequence
    ⍝   Stack   :=  List Value              ⍝ value stack
    ⍝   Value   :=  Word | List Value       ⍝ value
    ⍝    Name   :=  ⍞                       ⍝ name
    ⍝    Patn   :=  ⍞                       ⍝ operator argument pattern
    ⍝    Word   :=  ⍞                       ⍝ character vector
}
<a href="code_colours.htm">code_colours</a>

<a href="s_joy.htm">test script</a>

Back to: <a href="n_joy.htm">notes</a>

Back to: <a href="http://dfns.dyalog.com/index.htm">Workspaces</a>
</pre>
</body>
</html>
