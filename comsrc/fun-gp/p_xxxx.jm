# -*-   mode: tcl  ; coding: koi8   -*- ----------------------------------------

#!/bin/sh
# \
exec jimsh "$0" ${1+"$@"}
#
#-------------------------------------------------------------------------------
#

#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# source "p-test.jm"
#-------------------------------------------------------------------------------

# -*-   mode: tcl  ; coding: koi8   -*- ----------------------------------------

#!/bin/sh
# \
exec jimsh "$0" ${1+"$@"}

#-------------------------------------------------------------------------------
# Josef Knecht @ Copyright 
#-------------------------------------------------------------------------------

set auto_path [linsert $auto_path 0 "COMMON"]

# set auto_path [linsert $auto_path 0 $COMPOT/src/common] ;# for JIM
# set auto_path [linsert $auto_path 0 $COMPOT/src/random] ;# for JIM

#------------------------------------------

package require compot::common 


source "p-corE.tl"
source "p-corF.tl"


# /*******************************************************************************
#   ga_x_tester.c

# *******************************************************************************/


#-------------------------------------------------------------------------------
proc P1 {x} {

  return [expr {$x}]
}
#-------------------------------------------------------------------------------
proc P2 {x} {

  # #define SQU(x)         ((x)*(x))	     /* Square */

  return [expr {$x * $x}]
}
#-------------------------------------------------------------------------------
proc P3 {x} {

  # #define CUBE(x)        ((x)*(x)*(x))     /* Cube */

  return [expr {$x * $x * $x}]
}
#-------------------------------------------------------------------------------
proc P4 {x} {

  # #define FOURTH_POW(x)  ((x)*(x)*(x)*(x)) /* Guess ;) */

  return [expr {$x * $x * $x * $x}]
}
#-------------------------------------------------------------------------------
proc P5 {x} {

  # #define FIFTH_POW(x)   ((x)*(x)*(x)*(x)*(x))  /*  - " - */

  return [expr {$x * $x * $x * $x * $x}]
}
#-------------------------------------------------------------------------------
proc SIN {x} {

  return [expr { sin ($x) }]
}
#-------------------------------------------------------------------------------
proc COS {x} {

  return [expr { cos ($x) }]
}
#-------------------------------------------------------------------------------
# //  synopsis:	Fitness function.

# /* static */ boolean 
# _test_score (population *pop, entity *this_entity)

#-------------------------------------------------------------------------------
proc test_calc_fitness {this_entity task funclist} {

  set isreverse [GET $task "isreverse"]


  #   set A(0) [item_get_chromo_gen $this_entity  0] 
  #   set A(1) [item_get_chromo_gen $this_entity  1] 
  #   set A(2) [item_get_chromo_gen $this_entity  2] 
  #   set A(3) [item_get_chromo_gen $this_entity  3] 
  
  #   set F(0) [P1       [expr      {0.75 - $A(0) }]]
  #   set F(1) [P2       [expr      {0.95 - $A(1) }]]
  #   set F(2) [P3       [expr      {0.23 - $A(2) }]]
  #   set F(3) [P4       [expr      {0.71 - $A(3) }]]
  
  #   set fitness [expr { abs($F(0)) + abs($F(1)) + abs($F(2)) + abs($F(3)) }]

  set ind 0
  set fit 0

  foreach l $funclist {

    set X [item_get_chromo_gen $this_entity  $ind] 

    #puts "test_calc_fitness: X($ind) = $X"

    set F [lindex $l 0]
    set B [lindex $l 1]

    set ret [$F  [expr  { $B - $X }]]

    set fit [+ $fit [expr { abs($ret) } ]]
    incr ind
  }

  set fitness $fit

  # т.е чем больше - тем хуже !
  # fit_tobest = MIN, движемся к нулю справа  : 0 <-- 
 
  if {$isreverse} {
    set fitness [expr {-  $fitness}] 
    #
    # а теперь наоборот должно быть 
    # fit_tobest = MAX, движемся к нулю сдева  : --> 0 
  }
 
  return $fitness
}
#-------------------------------------------------------------------------------

set ::funclist_4 {"P1 0.75" "P2 0.95" "P3 0.23" "P4 0.71"} 
set ::funclist_5 {"P1 0.75" "P2 0.95" "P3 0.23" "P4 0.71" "P5 0.50"} 
set ::funclist_9 {"SIN 0.10" "P2 0.20" "P3 0.30" "P4 0.40" "P5 0.50" 
  "P1 0.60" "P2 0.70" "P3 0.80" "P4 0.90" } 

#-------------------------------------------------------------------------------
proc get_targets_list {len_chromo} {

  set tlist {}
  #set tlist {0.75  0.95  0.23  0.71}
  set flist "::funclist_${len_chromo}" 

  foreach l [set $flist] {

    set B [lindex $l 1]
    lappend tlist $B
  }
  
  return $tlist
}
#-------------------------------------------------------------------------------
proc test_score {this_entity  task} {


  set len_chromo [GET $task "len_chromo"]  
  set flist      "::funclist_${len_chromo}" 

  #puts "len_chromo = $len_chromo, flist = $flist"

  set fitness [test_calc_fitness $this_entity $task [set $flist]]

  return $fitness
}
#-------------------------------------------------------------------------------
# Seed genetic data.
# 
#-------------------------------------------------------------------------------
proc test_seed {pop task adam} {

  set len_chromo [GET $task "len_chromo"]  

  #   item_set_chromo_gen $adam 0  [random_double 2.0]
  #   item_set_chromo_gen $adam 1  [random_double 2.0]
  #   item_set_chromo_gen $adam 2  [random_double 2.0]
  #   item_set_chromo_gen $adam 3  [random_double 2.0]

  for {set i 0} {$i < $len_chromo} {incr i} {

    item_set_chromo_gen $adam $i  [random_double 2.0]
  }

  return true;
}
#-------------------------------------------------------------------------------
# synopsis:	Generation callback
#
# //------------------------------------------------------------------------------
proc _test_generation_callback {generation pop} {

  set best [pop_get_entity_ $pop  0]
  
  set best_chromo [item_get_mainsrc $best]
  set best_fit    [item_get_fitn       $best]
  
#   set A [lindex $best_chromo 0]
#   set B [lindex $best_chromo 1]
#   set C [lindex $best_chromo 2]
#   set D [lindex $best_chromo 3]
  
  print_one_line  [format "%3d" $generation]  $best_fit $best_chromo
  
  return true;
}
# //------------------------------------------------------------------------------
# //  synopsis:	Generation callback
# //------------------------------------------------------------------------------
proc test_generation_callback {generation pop} {

  
  # /*
  #  * Write top ranked solution every tenth generation.  Note, that this
  #  * is not neccesarily the best solution because DE doesn't require
  #  * the population to be sorted, as genetic algorithms usually do.
  #  */
  
  if {[expr {$generation % 10}] == 0} {

    _test_generation_callback $generation $pop
  }
  
  return true
}
# //------------------------------------------------------------------------------

# //  Synopsis:	Test program for GAUL's basic genetic algorithm.
# //
# //		This program aims to solve a function of the form
# //		(0.75-A) + (0.95-B)^2 + (0.23-C)^3 + (0.71-D)^4 = 0

# //------------------------------------------------------------------------------
proc test_ga {argv task} {


  set seed_proc "test_seed"
  set step_proc "_test_generation_callback"

  super_ga $task $seed_proc $step_proc {*}$argv

  return
}
# //------------------------------------------------------------------------------
# //  synopsis:     Calculate gradients analytically.
# //------------------------------------------------------------------------------
# double 
# _test_analytical_gradient (population *pop, entity *this_entity, double *params, double *grad)
# //------------------------------------------------------------------------------
proc test_analytical_gradient {pop this_entity params &grad} \
{

  USE_REFS

  #   double    grms = 0.0;	 /* RMS gradient. */
  set grms  0.0

  #   double    A, B, C, D;	 /* The parameters. */
  #   double    g0, g1, g2, g3;
  
  #   if (! pop)         die ("Null pointer to population structure passed.");
  #   if (! this_entity) die ("Null pointer to entity structure passed.");
  
  set A [lindex $params 0]
  set B [lindex $params 1]
  set C [lindex $params 2]
  set D [lindex $params 3]
  
  #   g0 = A > 0.75+TINY ? -1.0 : ( A < 0.75-TINY ? 1.0 : 0.0 );

  if {$A > [expr {0.75 + $::TINY}]} {
    set g0  -1.0 

  } else {

    if {$A < [expr {0.75 - $::TINY}]} {
      set tmp 1.0
    } else {
      set tmp 0.0
    }
    set g0 $tmp  
  }

  set g1 [expr {0.95 - $B}]

  #   g2 = C > 0.23 ? -P2(0.23 - C) : P2(0.23 - C);

  if {$C > 0.23} {
    set g2 -[P2 [expr {0.23 - $C}]]
  } else {
    set g2  [P2 [expr {0.23 - $C}]]
  }

  set g3 [P3 [expr {0.71 - $D}]] ;# тут бы макросами может сделать?
  

  #   grad[0] = g0 ;
  #   grad[1] = g1 ;
  #   grad[2] = g2 ;
  #   grad[3] = g3 ;

  set grad {}

  lappend grad $g0
  lappend grad $g1
  lappend grad $g2
  lappend grad $g3
  
  set grms [expr {sqrt ($g0 * $g0 + $g1 * $g1 + $g2 * $g2 + $g3 * $g3)}]

  return $grms
}
# //------------------------------------------------------------------------------
# //  synopsis:	Generation callback
# //------------------------------------------------------------------------------
# boolean 
# _test_iteration_callback (int iteration, entity *solution)
# //------------------------------------------------------------------------------
proc test_iteration_callback {iteration solution} \
{

  set ch [item_get_mainsrc $solution]
  set fi [item_get_fitn    $solution]

#   set A [lindex $ch 0]
#   set B [lindex $ch 1]
#   set C [lindex $ch 2]
#   set D [lindex $ch 3]
  
  print_one_line  [format "%3d" $iteration]  $fi $ch

  return true
}
# ------------------------------------------------------------------------------
proc test_sd2 {argv task} \
{

  set population_size  ""
  set max_iterations   ""
  set len_chromo       ""

  #global argv
  #set argv [lrange $argv 1 end]

  set print [parse_opts_NEW  $argv population_size max_iterations len_chromo  50 1000 4]

  SET $task "len_chromo" $len_chromo

  if {$print} {
    puts ""
    puts stderr "main_sd2 ....... 1 "
  }

  #   pop = ga_genesis_double (
  #        50,			     /* const int              population_size      */
  #        1,			     /* const int              num_chromo           */
  #        4,			     /* const int              len_chromo           */
  #        NULL,		     /* GAgeneration_hook      generation_hook      */
  #        _test_iteration_callback, /* GAiteration_hook       iteration_hook       */
  #        NULL,	             /* GAdata_destructor      data_destructor      */
  #        NULL,	             /* GAdata_ref_incrementor data_ref_incrementor */
  #        _test_score,		     /* GAevaluate             evaluate             */
  #        _test_seed,		     /* GAseed                 seed                 */
  #        NULL,		     /* GAadapt                adapt                */
  #        NULL,		     /* GAselect_one           select_one           */
  #        NULL,		     /* GAselect_two           select_two           */
  #        NULL,		     /* GAmutate               mutate               */
  #        NULL,		     /* GAcrossover            crossover            */
  #        NULL,	             /* GAreplace              replace              */
  #        NULL		             /* vpointer	       User data            */
  #        );
  

  set pop [ga_genesis_main                  \
	   $task \
           $population_size		      \
           1			              \
           4			              \
           NULL			              \
           test_iteration_callback            \
           NULL			              \
           NULL			              \
           test_seed	 	              \
           NULL			              \
           NULL	                              \
           NULL	                              \
           NULL                               \
           NULL                               \
           NULL			              \
           NULL			              \
          ]

    puts stderr "main_sd2 ....... 2 "

  #   ga_population_set_gradient_parameters (
  #        pop,				/* population		*pop           */
  #        NULL,			/* const GAto_double	to_double      */
  #        NULL,			/* const GAfrom_double	from_double    */
  #        _test_analytical_gradient,	/* const GAgradient	gradient       */
  #        0,				/* const int		num_dimensions */
  #        0.1				/* const double		step_size      */
  #        );
  
  ga_population_set_gradient_parameters  \
          $pop		                 \
          NULL			         \
          NULL			         \
          test_analytical_gradient       \
          0			         \
          0.1				
          
  puts stderr "main_sd2 ....... 3 "

  # почему тут надо так искуссствено?
  # 
  #ga_population_seed $pop


  # Evaluate and sort the initial population members (i.e. select best of 
  # 50 random solutions.
  #
  ga_population_score_and_sort  $pop $task
  
  puts stderr "main_sd2 ....... 4 "

  if {$print} {
    puts stderr "main_sd2 ....... 5 "
    puts stderr "pop = $pop"
    
    $pop print
    pop_print $pop

    puts stderr "main_sd2 ....... 6 "
    puts ""
  }

  # Use the best population member.
  # 
  #set solution [ga_get_entity_from_rank  $pop 0]
  #
  # сделаем пока так, а то не понятно, как там возвращается и зачем
  # 
  set solution NULL
  
  #   ga_steepestascent_double (
  #        pop,				/* population		*pop           */
  #        solution,			/* entity		*solution      */
  #        1000				/* const int		max_iterations */
  #        );
  
  ga_steepestascent_double $task  \
          $pop		        \
          $solution             \
          $max_iterations       \
         
  
  #   ga_extinction (pop);  
  #  exit (EXIT_SUCCESS);

  if {$print} {
    puts ""
  }

  return
}
# /*******************************************************************************
#   test_de.c

#   Synopsis:	Test program for GAUL's differential evolution algorithm.

# 		This program aims to solve a function of the form
# 		(0.75-A) + (0.95-B)^2 + (0.23-C)^3 + (0.71-D)^4 = 0

# *******************************************************************************/

# struct strategies_t
# {
#   char			*label; 
#   ga_de_strategy_type	strategy;
#   ga_de_crossover_type	crossover;
#   int			num_perturbed;
#   double		crossover_factor;
#   double		weighting_factor;
#   double		weighting_factor2;
# };


# static struct strategies_t strategy[]={
# ....
# { NULL, 0, 0, 0, 0.0, 0.0 } };


# это едиинчный тест для отладки
# 
set ::strategy_test {
  { "DE/best/1/bin"            GA_DE_STRATEGY_BEST        GA_DE_CROSSOVER_BINOMIAL     1  0.8  0.5  0.5 }
  { "DE/rand-to-best/1/bin"    GA_DE_STRATEGY_RANDTOBEST  GA_DE_CROSSOVER_BINOMIAL     1  0.8  0.5  0.5 }
}

set ::strategy_best {
  { "DE/best/1/bin"            GA_DE_STRATEGY_BEST        GA_DE_CROSSOVER_BINOMIAL     1  0.8  0.5  0.5 }
}

# это полный список тестов (оригинальный)
# 
set ::strategy_full_origin {

  { "DE/best/1/exp (DE0)"      GA_DE_STRATEGY_BEST        GA_DE_CROSSOVER_EXPONENTIAL  1  0.8  0.5  0.5 }
  { "DE/best/1/exp (DE0)"      GA_DE_STRATEGY_BEST        GA_DE_CROSSOVER_EXPONENTIAL  1  0.8  2.0  0.0 }
  { "DE/best/2/exp"            GA_DE_STRATEGY_BEST        GA_DE_CROSSOVER_EXPONENTIAL  2  0.8  0.5  0.5 }
  { "DE/best/2/exp"            GA_DE_STRATEGY_BEST        GA_DE_CROSSOVER_EXPONENTIAL  2  0.8  2.0  0.0 }
  { "'DE/best/3/exp'"          GA_DE_STRATEGY_BEST        GA_DE_CROSSOVER_EXPONENTIAL  3  0.8  0.5  0.5 }
  { "'DE/best/3/exp'"          GA_DE_STRATEGY_BEST        GA_DE_CROSSOVER_EXPONENTIAL  3  0.8  2.0  0.0 }
  { "DE/rand/1/exp (DE1)"      GA_DE_STRATEGY_RAND        GA_DE_CROSSOVER_EXPONENTIAL  1  0.8  0.5  0.5 }
  { "DE/rand/1/exp (DE1)"      GA_DE_STRATEGY_RAND        GA_DE_CROSSOVER_EXPONENTIAL  1  0.8  2.0  0.0 }
  { "DE/rand/2/exp"            GA_DE_STRATEGY_RAND        GA_DE_CROSSOVER_EXPONENTIAL  2  0.8  0.5  0.5 }
  { "DE/rand/2/exp"            GA_DE_STRATEGY_RAND        GA_DE_CROSSOVER_EXPONENTIAL  2  0.8  2.0  0.0 }
  { "'DE/rand/3/exp'"          GA_DE_STRATEGY_RAND        GA_DE_CROSSOVER_EXPONENTIAL  3  0.8  0.5  0.5 }
  { "'DE/rand/3/exp'"          GA_DE_STRATEGY_RAND        GA_DE_CROSSOVER_EXPONENTIAL  3  0.8  2.0  0.0 }
  { "DE/rand-to-best/1/exp"    GA_DE_STRATEGY_RANDTOBEST  GA_DE_CROSSOVER_EXPONENTIAL  1  0.8  0.5  0.5 }
  { "DE/rand-to-best/1/exp"    GA_DE_STRATEGY_RANDTOBEST  GA_DE_CROSSOVER_EXPONENTIAL  1  0.8  2.0  0.0 }
  { "'DE/rand-to-best/2/exp'"  GA_DE_STRATEGY_RANDTOBEST  GA_DE_CROSSOVER_EXPONENTIAL  2  0.8  0.5  0.5 }
  { "'DE/rand-to-best/2/exp'"  GA_DE_STRATEGY_RANDTOBEST  GA_DE_CROSSOVER_EXPONENTIAL  2  0.8  2.0  0.0 }

  { "DE/best/1/bin"            GA_DE_STRATEGY_BEST        GA_DE_CROSSOVER_BINOMIAL     1  0.8  0.5  0.5 }
  { "DE/best/1/bin"            GA_DE_STRATEGY_BEST        GA_DE_CROSSOVER_BINOMIAL     1  0.8  2.0  0.0 }
  { "DE/best/2/bin"            GA_DE_STRATEGY_BEST        GA_DE_CROSSOVER_BINOMIAL     2  0.8  0.5  0.5 }
  { "DE/best/2/bin"            GA_DE_STRATEGY_BEST        GA_DE_CROSSOVER_BINOMIAL     2  0.8  2.0  0.0 }
  { "'DE/best/3/bin'"          GA_DE_STRATEGY_BEST        GA_DE_CROSSOVER_BINOMIAL     3  0.8  0.5  0.5 }
  { "'DE/best/3/bin'"          GA_DE_STRATEGY_BEST        GA_DE_CROSSOVER_BINOMIAL     3  0.8  2.0  0.0 }
  { "DE/rand/1/bin"            GA_DE_STRATEGY_RAND        GA_DE_CROSSOVER_BINOMIAL     1  0.8  0.5  0.5 }
  { "DE/rand/1/bin"            GA_DE_STRATEGY_RAND        GA_DE_CROSSOVER_BINOMIAL     1  0.8  2.0  0.0 }
  { "DE/rand/2/bin"            GA_DE_STRATEGY_RAND        GA_DE_CROSSOVER_BINOMIAL     2  0.8  0.5  0.5 }
  { "DE/rand/2/bin"            GA_DE_STRATEGY_RAND        GA_DE_CROSSOVER_BINOMIAL     2  0.8  2.0  0.0 }
  { "'DE/rand/3/bin'"          GA_DE_STRATEGY_RAND        GA_DE_CROSSOVER_BINOMIAL     3  0.8  0.5  0.5 }
  { "'DE/rand/3/bin'"          GA_DE_STRATEGY_RAND        GA_DE_CROSSOVER_BINOMIAL     3  0.8  2.0  0.0 }
  { "DE/rand-to-best/1/bin"    GA_DE_STRATEGY_RANDTOBEST  GA_DE_CROSSOVER_BINOMIAL     1  0.8  0.5  0.5 }
  { "DE/rand-to-best/1/bin"    GA_DE_STRATEGY_RANDTOBEST  GA_DE_CROSSOVER_BINOMIAL     1  0.8  2.0  0.0 }
  { "'DE/rand-to-best/2/bin'"  GA_DE_STRATEGY_RANDTOBEST  GA_DE_CROSSOVER_BINOMIAL     2  0.8  0.5  0.5 }
  { "'DE/rand-to-best/2/bin'"  GA_DE_STRATEGY_RANDTOBEST  GA_DE_CROSSOVER_BINOMIAL     2  0.8  2.0  0.0 }
}



# //------------------------------------------------------------------------------
# void 
# test_de (/* int argc, char **argv */)

#-------------------------------------------------------------------------------
proc test_de_all {argv task strategy_list} {


  set population_size  "" 
  set max_generations  ""
  set len_chromo       ""

  set print [parse_opts_NEW  $argv population_size max_generations len_chromo  40 50 4]

  SET $task "len_chromo" $len_chromo

  set seed_proc "test_seed"
  set step_proc "test_generation_callback"

  
  foreach s $strategy_list {

    set pop [de_run_one  $task $s "" $population_size $max_generations $len_chromo $print \
               $seed_proc $step_proc \
              ]

    set best 0

    set best_entity [pop_get_entity_         $pop  $best]
    set best_fit    [pop_get_entity_fitness_ $pop  $best]

    set best_chromo [item_get_mainsrc $best_entity]

    print_one_line  "Final"  $best_fit $best_chromo
    
  }


  return
}
#-------------------------------------------------------------------------------
proc test_sc {argv task} {

  set seed_proc "test_seed"
  set step_proc "test_generation_callback"

  set pop [super_de $task $seed_proc $step_proc {*}$argv] ;# !!!!!!!!!!!!!!!!


  set best 0
  
  set best_entity [pop_get_entity_         $pop  $best]
  set best_fit    [pop_get_entity_fitness_ $pop  $best]
  
  set best_chromo [item_get_mainsrc $best_entity]
  
  print_one_line  "Final"  $best_fit $best_chromo
  
  
  return
}
# //------------------------------------------------------------------------------
# //------------------------------------------------------------------------------
proc test_main {} {


  global argc argv argv0

  #global strategy_full_origin strategy_test

  if  {$argc == 0} { 
    puts "argc == 0"
    exit
  }
  
  set mode [lindex $argv 0] ;# имя выч. задачи

  set task     [task_create  -fit_func "test_score" -fit_tobest "MIN" -isreverse 0 -fit_error 0.001 ]
  set task_rev [task_create  -fit_func "test_score" -fit_tobest "MAX" -isreverse 1 -fit_error 0.001 ]
    
  global argv
  set argv [lrange $argv 1 end]

  set len_chromo   [dict_parse $argv  "-lsrc" 4]

  set tlist [get_targets_list $len_chromo] 

  puts ""
  print_one_line  "Target"  +0  $tlist ;#  {0.75  0.95  0.23  0.71}
  puts ""

  #-------------------------------------------------------

  if     {$mode == "ga"    }   { test_ga      $argv $task     } \
  elseif {$mode == "ga_REV"}   { test_ga      $argv $task_rev } \
  elseif {$mode == "de_full"}  { test_de_all  $argv $task_rev  $::strategy_full_origin } \
  elseif {$mode == "de_test"}  { test_de_all  $argv $task_rev  $::strategy_test        } \
  elseif {$mode == "de"     }  { test_de_all  $argv $task_rev  $::strategy_best        } \
  elseif {$mode == "sd2"}      { test_sd2     $argv $task_rev } \
  elseif {$mode == "sc"}       { test_sc      $argv $task_rev } \
  else {
    puts ""
    puts "ERROR mode = $mode"
    puts ""
  }
  #-------------------------------------------------------

  puts ""
  print_one_line  "Target"  +0  $tlist ;#   {0.75  0.95  0.23  0.71} 
  puts ""

}
# //------------------------------------------------------------------------------

#test_main

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
# 
# 0.75  0.95  0.23  0.71 
# 
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1

# //------------------------------------------------------------------------------
# //------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# source "p_stru.tl"
#-------------------------------------------------------------------------------


# -*-   mode: tcl  ; coding: koi8   -*- ----------------------------------------

#!/bin/sh
# \
exec tclsh "$0" ${1+"$@"}


#-------------------------------------------------------------------------------
# Josef Knecht @ Copyright 
#-------------------------------------------------------------------------------


# set COMPOT "./COMPOT" 

# set auto_path [linsert $auto_path 0 $COMPOT]

# set auto_path [linsert $auto_path 0 $COMPOT/COM/common] ;# for JIM

#lappend auto_path \
  [file join [file dirname [info script]] "."] ;# "COM" "../common"


#-------------------------------------------------------------------------------

set auto_path [linsert $auto_path 0 "COMMON"]
package require compot::common 

if {$::__JIM__} {

} else {

  #package require tcltest
  package require TclOO

}

#------------------------------------------

source "p-corE.tl"
source "p-corF.tl"

#source "p-diff.tl"
#source "p-detw.tl"
#
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------

# /*   ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~  */

# /* i=  32  ch=    */
# /* i=  33  ch= !  */
# /* i=  34  ch= "  */
# /* i=  35  ch= #  */
# /* i=  36  ch= $  */
# /* i=  37  ch= %  */
# /* i=  38  ch= &  */
# /* i=  39  ch= '  */
# /* i=  40  ch= (  */
# /* i=  41  ch= )  */
# /* i=  42  ch= *  */
# /* i=  43  ch= +  */
# /* i=  44  ch= ,  */
# /* i=  45  ch= -  */
# /* i=  46  ch= .  */
# /* i=  47  ch= /  */
# /* i=  48  ch= 0  */
# /* i=  49  ch= 1  */
# /* i=  50  ch= 2  */
# /* i=  51  ch= 3  */
# /* i=  52  ch= 4  */
# /* i=  53  ch= 5  */
# /* i=  54  ch= 6  */
# /* i=  55  ch= 7  */
# /* i=  56  ch= 8  */
# /* i=  57  ch= 9  */
# /* i=  58  ch= :  */
# /* i=  59  ch= ;  */
# /* i=  60  ch= <  */
# /* i=  61  ch= =  */
# /* i=  62  ch= >  */
# /* i=  63  ch= ?  */
# /* i=  64  ch= @  */
# /* i=  65  ch= A  */
# /* i=  66  ch= B  */
# /* i=  67  ch= C  */
# /* i=  68  ch= D  */
# /* i=  69  ch= E  */
# /* i=  70  ch= F  */
# /* i=  71  ch= G  */
# /* i=  72  ch= H  */
# /* i=  73  ch= I  */
# /* i=  74  ch= J  */
# /* i=  75  ch= K  */
# /* i=  76  ch= L  */
# /* i=  77  ch= M  */
# /* i=  78  ch= N  */
# /* i=  79  ch= O  */
# /* i=  80  ch= P  */
# /* i=  81  ch= Q  */
# /* i=  82  ch= R  */
# /* i=  83  ch= S  */
# /* i=  84  ch= T  */
# /* i=  85  ch= U  */
# /* i=  86  ch= V  */
# /* i=  87  ch= W  */
# /* i=  88  ch= X  */
# /* i=  89  ch= Y  */
# /* i=  90  ch= Z  */
# /* i=  91  ch= [  */
# /* i=  92  ch= \  */
# /* i=  93  ch= ]  */
# /* i=  94  ch= ^  */
# /* i=  95  ch= _  */
# /* i=  96  ch= `  */
# /* i=  97  ch= a  */
# /* i=  98  ch= b  */
# /* i=  99  ch= c  */
# /* i= 100  ch= d  */
# /* i= 101  ch= e  */
# /* i= 102  ch= f  */
# /* i= 103  ch= g  */
# /* i= 104  ch= h  */
# /* i= 105  ch= i  */
# /* i= 106  ch= j  */
# /* i= 107  ch= k  */
# /* i= 108  ch= l  */
# /* i= 109  ch= m  */
# /* i= 110  ch= n  */
# /* i= 111  ch= o  */
# /* i= 112  ch= p  */
# /* i= 113  ch= q  */
# /* i= 114  ch= r  */
# /* i= 115  ch= s  */
# /* i= 116  ch= t  */
# /* i= 117  ch= u  */
# /* i= 118  ch= v  */
# /* i= 119  ch= w  */
# /* i= 120  ch= x  */
# /* i= 121  ch= y  */
# /* i= 122  ch= z  */
# /* i= 123  ch= {  */
# /* i= 124  ch= |  */
# /* i= 125  ch= }  */
# /* i= 126  ch= ~  */

# //------------------------------------------------------------------------------
#   struggle_ALL.c

#   Synopsis:	Test/example program.

# This program aims to generate the final sentence from
# Chapter 3 of Darwin's "The Origin of Species",
# entitled "Struggle for Existence".

# /*
#  * The solution string.
#  */

# set ::target_text_full  "When we reflect on this struggle, we may console ourselves with the full belief, that the war of nature is not incessant, that no fear is felt, that death is generally prompt, and that the vigorous, the healthy, and the happy survive and multiply."

#set ::target_text  "When we reflect on this struggle"
# //------------------------------------------------------------------------------

#if {$::NEWTEST} {
#set ::allele_min_integer  48 ;# ('1') 
#set ::allele_max_integer 126 ;# ('~') 
#} else {
#set ::allele_min_integer__  32 ;# (' ') 
#set ::allele_max_integer__ 126 ;# ('~') 

#}

set ::target_text  "1 2 2 3 3 3 4 4 4 4 5 5 5 5 5"

set ::gp_list      "1 2 3 4 5 6 7 8 9"

comm_random_seed 10


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc LTARGET {} {

  set len [llength $::target_text]

  return $len
}
#------------------------------------------------------------------------------
# TODO: упростить

set ::FS_fitness_min_integer  32 ;# (' ') 
set ::FS_fitness_max_integer 126 ;# ('~') 

#------------------------------------------------------------------------------
proc FS_fitness_one_calc_add {fit  char_calc_decm char_true_decm} {


  set abs [expr {abs ($char_calc_decm - $char_true_decm)}]

  ##if {$char_calc_decm == $char_true_decm} {}
  if {$abs == 0} {

    set fit [expr {$fit + 1.0}]
    # если   совпадают, просто увеличиваем на 1

    #puts "FS_fitness_one_calc_add: abs == 0"
    #exit
  }
  
  set char_min $::FS_fitness_min_integer
  set char_max $::FS_fitness_max_integer

  set size_all   [- $char_max $char_min] 
  set size_all_half [/ $size_all 2.0] 


  set fit_add [expr {1.0 * ($char_max - $abs) / $size_all_half}]

  set fit [+ $fit $fit_add] 


  # подсчет идет в пространстве кодовых значений символов
  # 
  # добавляем признак, что уже ближе? холодно-теплее-горячо ?

  # чем больше, тем лучше (приближаясь к некому значению)
  # fit_tobest = MAX ?
  
  return $fit
}
# ------------------------------------------------------------------------------

#set ::fit_target 53.1
set ::fit_target 55.213

#------------------------------------------------------------------------------if
# 
proc FS_fitness {item_text_calc task} {

  set fit 0.0
  
  set len [item_get_chromo_len  $item_text_calc] 

  set text_true [GET $task "target_text"]


  # Loop over alleles in chromosome.
  
  for {set k 0} {$k < $len} {incr k} {
  
    set char_true  [lindex  $text_true  $k]

    set char_true_decm  [scan   $char_true "%c"] ;# по символу берем его номер

    if {0} {
      puts "char_true      = $char_true"
      puts "char_true_decm = $char_true_decm"
      puts "char_true_decm2= [scan $char_true "%Ld"]"

      exit
    }

    set char_calc_decm  [item_get_chromo_gen  $item_text_calc  $k]

    #if {$::CHROMOLIST} { 
    set char_calc_decm [scan $char_calc_decm "%c"]  ;# десятичные коды символьных цифр
    #}


    set fit [FS_fitness_one_calc_add  $fit  $char_calc_decm $char_true_decm]
  }

  # #   if {$::ISNEW} {
  # #     #puts stderr ".................................. 001"
  # #     #set fi [expr {abs (53.1 - $fi)}]
  
  # #     #set fi [expr {$fi - 39}]  ;# это еще нормально для ga_select_two_sus
  # #     #set fi [expr {$fi - 40}]   ;# а это уже с ошибкой
  # #     #set fi [expr {$fi - 53.1}]   
  # #   }  

  return $fit
}
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------

#  struggle.c
# 
#  This program is fairly lean, showing how little
#  application code is needed.
#  This example is explained in docs/html/tutorial/simple.html
# 
# ------------------------------------------------------------------------------
# proc  strlen {str} {

#   return [string length $str]
# }
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc make_task_for_STRU {args} {

  set vers [dict_parse $args "-vers" 0]

  if {$vers == 0} {
    
    set fitness_func  "FS_fitness"
    set fit_target    $::fit_target
  }

  if {$vers == 1} {
    
    set fitness_func   "FITPROC_list_FS"

    # т.е. тоже больше фитнес - лучше, но мы приближаемся сдева к точносу 0 !!
    set fit_target     0    
  } 


  # а теперь
  #
  
  set size    [dict_parse $args "-size"  [LTARGET]] 
  set pmin 1  ;# 2 выбираем длину блоков повторов из этого интервала: от
  set pmax 4  ;# 3 и до 

  set task_local [task_create  -fit_func $fitness_func \
              -fit_tobest "MAX"       \
              -fit_target $fit_target \
              -fit_error 0.01         \
              -gp_list $::gp_list -target_text $::target_text \
              -size $size -pmin $pmin -pmax $pmax \
              ]  


  #set task [dict_parse $args "-task" $task_local]
  set task $task_local

  SET $task "fitness_func" $fitness_func
  SET $task "fit_target"   $fit_target
  
  return $task
}
# ------------------------------------------------------------------------------
proc do_print_best {pop name} \
{

  set best_entity [ga_get_entity_from_rank $pop 0]
  set best_fitnes [item_get_fitn           $best_entity] 

  #puts [format "The final solution with %s evolution with score %f was:" $name $best_fitnes]
  puts -nonewline [format "Best solution %s, score = %5.2f : " $name $best_fitnes]

  #   beststring = ga_chromosome_char_to_string (pop, ga_get_entity_from_rank (pop, 0), 
  #                                              beststring, &beststrlen);
  #   printf ("%s\n", beststring);
  #   printf ("\n");

  item_print_ch $best_entity ""
  puts ""

  set generation [GET $pop "generation"] ;# сколько было генераций
  puts "generation = $generation"

  puts [format "Total number of fitness evaluations: %ld" $::eval_count]

  puts ""

}
# ------------------------------------------------------------------------------
# g:g_stru.jm,_01_test,-lpop,20,-nums,-1 ................ FAILED

# ------------------------------------------------------------------------------
proc _01_test {} {

  global argc argv argv0
  set argv [lrange $argv 1 end]

  puts stderr "argv = $argv"

  set population_size [dict_parse $argv "-lpop" 10]
  set max_generations [dict_parse $argv "-nums" 10]

  set vers            [dict_parse $argv "-vers"  0]

  set target_text     [dict_parse $argv "-list"  $::target_text]
  set len_chromo      [dict_parse $argv "-size"  [LTARGET]] 
 
  puts ""
  puts "lpop  = $population_size"  ;# колич-во ботов
  puts "size  = $len_chromo" 
  puts "nums  = $max_generations"  ;# шагов эволюции  
  puts ""

  set ::is_print 1 ;# TODO: здесь уж слишком много печати, надо гибче?
  set print $::is_print

  comm_random_seed 10 ;#$i
  
  #---------------------------------------------------------------------

  set task  [make_task_for_STRU -vers $vers]

  SET $task target_text $target_text 
  
  set obj \
    [BOT01 new  -lpop $population_size -lsrc $len_chromo -task $task -vers $vers] 

  if {$vers == 1} {
    set pop [GET $obj "pop"]
    SET $pop  select_one   "ga_select_one_bestof2"
    SET $pop  select_two   "ga_select_two_bestof2"
  }

  set ret [calc_BOT01 $obj {*}$argv -print $print]

  #---------------------------------------------------------------------
  
  do_print_stop_criteria  $ret $max_generations

  puts ""
  
  set pop [GET $obj pop]
   
  do_print_best $pop ""
  

  return
}
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------

dict_class_create  BOT02 {BOT} {

  ;# _это_перечисление_переменных
  
} {
  # а это конструктор класса 

  set pop1 [pop1_create  {*}$args]
  
  SET $pop1  elitism  GA_ELITISM_PARENTS_SURVIVE ;# всех оставдяем !
  SET $pop1  select_one  "ga_select_one_bestof2"
  SET $pop1  select_two  "ga_select_two_bestof2"  
  
  SET $obj "pop" $pop1
}

# ------------------------------------------------------------------------------
# //  struggle_generation_hook()
# //  synopsis:	This function is called by the main GA routine at the
# //		beginning of every generation.

  set ::sum_best_fitnesses 0.0  


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc _3_struggle_generation_hook {generation pop} \
{

  set fi [pop_get_entity_fitness_ $pop  0]

  set ::sum_best_fitnesses [expr {$::sum_best_fitnesses + $fi}]
  
  # Display statistics every 20th generation.
  # 
  
  if {[expr {$generation % 20}] == 0} {

    #puts [format "Generation = %d " $generation]
    #puts [format "Number of evaluations = %ld" $::eval_count]
    #puts [format "Best fitness = %f" $fi]

    set average ""
    set stddev  ""

    ga_fitness_mean_stddev  $pop  average stddev
    
    #puts [format "Mean fitness = %f, with standard deviation = %f" $average $stddev]

    #if {$generation > 0} {
    #  puts [format "Average best fitness for entire run = %f" \
    \#          [expr {$::sum_best_fitnesses / $generation}]]
    #}

    #puts ""
  }
  
  return $::true ;#  /* TRUE indicates that evolution should continue. */
}
# //------------------------------------------------------------------------------
# //  struggle3.c
# //
# //		This program demonstrates the use of custom GA
# //		termination criteria.  It also provides an example of
# //		how to collate some simple statistics.
# //
#-------------------------------------------------------------------------------
proc parse_opts_2 {&par1    &par2 
                def_par1 def_par2 } {

  USE_REFS

  global argc argv argv0

  set print 0

  if  {$argc == 1} { 
    # вызов без параметров, только с одним mode
    
    set par1  $def_par1
    set par2  $def_par2
 
  } else {

    set par1 [lindex $argv 1]
    set par2 [lindex $argv 2]

    if  {$argc == 4}    {
      set print 1
    }
  }

  set ::is_print $print

  return $print
}
# ------------------------------------------------------------------------------
proc allele_incr {adult allele incr_val}  \
{

  set oldval [item_get_chromo_gen $adult  $allele]

  item_set_chromo_gen $adult $allele [expr {$oldval + $incr_val}]

}
# ------------------------------------------------------------------------------
proc _3_struggle_adaptation {task pop child} \
{
  
  set eval_proc [GET $task "fit_func"]

  # We must generate a new solution by copying the original solution.
  # This function copys all genomic, and if appropriate, phenomic data.
  # It is never safe to adapt the solution in place.
  #

  set adult [ga_entity_clone $pop $child] ;# for Adapted solution
  
  set len [LTARGET]

  set allele [comm_random_int $len] ;# Randomly selected allele

  # ----------------------------------------------------
  #
  # Make point mutation.
  
  allele_incr $adult $allele +1
 
  pop_eval_item  $pop $adult $eval_proc $task
    
  if {[item_get_fitn $adult] > [item_get_fitn $child]} {
    return $adult
  }
  
  # ----------------------------------------------------
  # 
  #  Searching in that previous direction didn't help. 

  allele_incr $adult $allele -2
  
  pop_eval_item  $pop $adult $eval_proc $task
    
  if {[item_get_fitn $adult] > [item_get_fitn $child]} {
    return $adult
  }
  
  # ----------------------------------------------------

  #  We must already be at a maxima. 
  
  allele_incr $adult $allele +1

  #ent_set_fitness $adult [item_get_fitn $child]
  item_set_fitn  $adult [item_get_fitn $child]

  return $adult
}
# ------------------------------------------------------------------------------

dict_class_create  BOT03 {BOT} {

  ;# _это_перечисление_переменных
  
} {
  # а это конструктор класса 

  set len_chromo      [dict_parse $args "-lsrc" ] 
  set population_size [dict_parse $args "-lpop" ] 
  set task            [dict_parse $args "-task" ] 
    
  set seed_proc  "maintest_seed_proc"
  
  set mutate [mutate_create -mutate_proc ga_mutate_printable_singlepoint_drift]

  set pop  [ga_genesis_main                          \
	      $task \
              $population_size			     \
              1			                     \
              $len_chromo                            \
              _3_struggle_generation_hook	     \
              NULL			             \
              NULL			             \
              NULL                                   \
              $seed_proc                             \
              _3_struggle_adaptation	             \
              ga_select_one_bestof2	                     \
              ga_select_two_bestof2	                     \
              $mutate  \
              ga_crossover_char_allele_mixing        \
              NULL			             \
              NULL			             \
             ]

    #SET $pop ch_form "%c" ;# 
    SET $pop ch_form "%s " 
    
    ga_population_set_parameters \
      $pop	                 \
      GA_SCHEME_LAMARCK_CHILDREN \
      GA_ELITISM_PARENTS_DIE     \
      0.8			 \
      0.05		         \
      0.0      	          

    SET $obj "pop"  $pop

}
#-------------------------------------------------------------------
proc calc_BOT03 {obj args} {

  set task            [dict_parse $args "-task" [GET $obj task]] 
  set max_generations [dict_parse $args "-nums"] 
  
  set  pop [GET $obj pop]
  # 
  SET $pop "generation" 0
  SET $pop "itemlist"   {}
  
  set ret [ga_evolution  $task $pop $max_generations  {*}$args]  
  
  return $ret  
}
# //------------------------------------------------------------------------------
proc do_print_stop_criteria {ret max_generations} {


  puts "do_print_stop_criteria: ret = $ret, max_generations = $max_generations"
 
  if {$max_generations == -1 || $ret < $max_generations} {
    
    puts "The evolution was stopped: termination criteria "
  } else {
    puts "The evolution was stopped: maximum number of generations"
  }

}
# //------------------------------------------------------------------------------
proc _03_test {} \
{
  
  comm_random_seed 10 ;# 23091975
  
  set population_size 120
  set max_generations 1000

  set print [parse_opts_2  population_size max_generations \
               120 1000]
  
  #----------------------------------------------------------------------

  set len_chromo [LTARGET] 
  
  set task [make_task_for_STRU]

  puts ""
  puts "bnums  = $population_size"  ;# колич-во ботов
  puts "bsize  = $len_chromo" 
  puts "maxgs  = $max_generations"  ;# шагов эволюции  
  puts ""

  #set ::is_print 1 ;# TODO: здесь уж слишком много печати, надо гибче?
  #set print $::is_print

  #----------------------------------------------------------------------

  set obj \
    [BOT03 new  -lpop $population_size -lsrc $len_chromo -task $task] 


  set pop [GET $obj pop]

  set ret [ga_evolution  $task $pop $max_generations -print $print]  


  do_print_stop_criteria  $ret $max_generations

  puts ""
  
  do_print_best $pop ""


  return 1
}
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# proc _4_struggle_seed {pop adam} \
# {

#   ga_seed_printable_random $pop $adam


#   return $::true
# }
# ------------------------------------------------------------------------------
proc _4_struggle_mutate {pop task father son} \
{
 
  # похоже это тоже самое !?
  # 
  ga_mutate_printable_singlepoint_drift  $pop $task $father $son


  return
}
# ------------------------------------------------------------------------------
# synopsis:	A pair of crossover operators which will be called
# 		alternately through the use of cross definitions.
#
# т.е. вызываются попеременно
# //------------------------------------------------------------------------------
proc _4_the_other_struggle_crossover {pop task  father mother son daughter} \
{

  ga_crossover_char_singlepoints  $pop $task  $father $mother $son $daughter

  SET $pop crossover _4_struggle_crossover

  return
}
# //------------------------------------------------------------------------------
proc _4_struggle_crossover {pop task  father mother son daughter} \
{
  ga_crossover_char_doublepoints $pop $task  $father $mother $son $daughter

  SET $pop crossover _4_the_other_struggle_crossover

  return
}
# //------------------------------------------------------------------------------
# ------------------------------------------------------------------------------

dict_class_create  BOT04 {BOT} {

  ;# _это_перечисление_переменных

} {

  # если нет в args, то берем значение здесь
  # 
  set len_chromo      [dict_parse $args "-lsrc" ] 
  set population_size [dict_parse $args "-lpop" ] 
  set task            [dict_parse $args "-task" ] 
  
  set pop [GAUL new  \
             -lpop $population_size -lsrc $len_chromo]
  
  #SET $pop ch_form "%c" ;# 
  SET $pop ch_form "%s " ;# 
    
  #   /*
  #     * Define chromosome handling functions.
  #     * Normally these functions would only be set manually when
  #     * creating a custom chromosome type.
  #     */
  
  #   pop->chromosome_constructor = ga_chromosome_char_allocate;
  #   pop->chromosome_destructor  = ga_chromosome_char_deallocate;
  #   pop->chromosome_replicate   = ga_chromosome_char_replicate;
  #   pop->chromosome_to_bytes    = ga_chromosome_char_to_bytes;
  #   pop->chromosome_from_bytes  = ga_chromosome_char_from_bytes;
  #   pop->chromosome_to_string   = ga_chromosome_char_to_string;
  
  #   /* Define all the needed callback functions. */
  SET $pop generation_hook NULL
  #$pop configure -iteration_hook  NULL
  #   pop->data_destructor = NULL;
  #   pop->data_ref_incrementor = NULL;  
  
  set seed_proc  "maintest_seed_proc"
  
  
  SET $pop seedproc    $seed_proc      ;# /* Individual initialisation    */
  
  SET $pop adapt      _3_struggle_adaptation ;# /* Environmental adaptation operator */
  SET $pop select_one  ga_select_one_bestof2     ;# /* Mutation selection operator  */
  SET $pop select_two  ga_select_two_bestof2     ;# /* Crossover selection operator */
  SET $pop mutate     _4_struggle_mutate     ;# /* Mutation operator            */
  SET $pop crossover  _4_struggle_crossover  ;# /* Crossover operator           */
  
  #   /* Replacement operator. (Only used in steady-state evolution) */
  SET $pop replace NULL
  
  #   /*
  #     * Seed the initial population. (Could do this manually - it
  #     * just calls pop->seed() 100 times in this case.)
  #     */
  ga_population_seed $pop $task
  
  #   /*
  #     * Set the GA parameters.
  #     * Lamarkian evolution.
  #     * Parents may survive into next generation.
  #     * Crossover ratio = 0.9.
  #     * Mutation ratio = 0.1.
  #     * Migration ration = 0.0.
  #     *
  #     * Note that custom operator functions may choose to ignore these values.
  #     *
  #     * There are functions for setting these individually too.
  #     */
  #   ga_population_set_parameters (pop, GA_SCHEME_LAMARCK_CHILDREN, GA_ELITISM_PARENTS_DIE, 0.9, 0.1, 0.0);
    
  ga_population_set_parameters \
    $pop	               \
    GA_SCHEME_LAMARCK_CHILDREN \
    GA_ELITISM_PARENTS_DIE     \
    0.9			       \
    0.1		               \
    0.0      	          
  
  
  SET $obj "pop"  $pop
  
}

#---------------------------------------------------------
proc  calc_BOT04  {obj args} {
  
  
  set task            [dict_parse $args "-task" [GET $obj task]] 
  set max_generations [dict_parse $args "-nums"] 
  
  set  pop [GET $obj pop]
  # 
  SET $pop "generation" 0
  SET $pop "itemlist"  {}
  
  set ret [ga_evolution  $task $pop $max_generations  {*}$args]  
  
  return $ret
}
#---------------------------------------------------------

# //------------------------------------------------------------------------------
# //
# //  struggle4.c
# //
# //	This program demonstrates the use of custom GA
# //	operator functions.  The long-hand method is used
# //	to set up the population's genomic form, rather than
# //	and of the high-level utility functions.
# //
# //	This example is explained in docs/html/tutorial4.html
# //
# //------------------------------------------------------------------------------
proc _04_test {} \
{
  
  comm_random_seed 10 ;# 23091975
  

  set population_size ""
  set max_generations ""

  set print [parse_opts_2  population_size max_generations \
               100 500]
  
  set len_chromo [LTARGET] 

  #-----------------------------------------------------------------

  set task [make_task_for_STRU]

  puts ""
  puts "bnums  = $population_size"  ;# колич-во ботов
  puts "bsize  = $len_chromo" 
  puts "maxgs  = $max_generations"  ;# шагов эволюции  
  puts ""

  #set ::is_print 1 ;# TODO: здесь уж слишком много печати, надо гибче?
  #set print $::is_print

  #----------------------------------------------------------------------

  set obj \
    [BOT04 new  -lpop $population_size -lsrc $len_chromo -task $task] 

  set pop [GET $obj pop]

  RUN1 "calc_" $obj -nums $max_generations -task $task -print $print

  #-----------------------------------------------------------------

  do_print_best $pop ""

  return 1
}
# ------------------------------------------------------------------------------

dict_class_create  BOT05 {BOT} {

  ;# _это_перечисление_переменных

  pops ""

} {
  #---------------------------------------------------------

  #set obj [SELF]

  # если нет в args, то берем значение здесь
  # 
  set task  [GET $obj task]

  set len_chromo      [dict_parse $args "-lsrc" ] 
  set population_size [dict_parse $args "-lpop" ] 
  set num_pops        [dict_parse $args "-num_pops" 1]
  
  
  set seed_proc  "maintest_seed_proc"
  
  set mutate [mutate_create -mutate_proc ga_mutate_printable_singlepoint_drift]

  # все попы одинаковы?
  set pops ""
  
  for {set i 0} {$i < $num_pops} {incr i} {
    
    set pop  [ga_genesis_main                         \
                $task \
                $population_size	              \
                1			              \
                $len_chromo                           \
                NULL	                              \
                NULL			              \
                NULL			              \
                NULL                                  \
                $seed_proc                            \
                NULL	                              \
                ga_select_one_bestof2	              \
                ga_select_two_bestof2	              \
                $mutate \
                ga_crossover_char_allele_mixing       \
                NULL			              \
                NULL			              \
               ]
    
    SET $pop ch_form "%c" ;# 
    
    ga_population_set_parameters \
      $pop	                 \
      GA_SCHEME_DARWIN           \
      GA_ELITISM_PARENTS_DIE     \
      0.75			 \
      0.25		         \
      0.0001        
    
    lappend pops $pop ;# добавили популяцию в список !!
  }
  
  
  SET $obj "pops"  $pops
  
}

#---------------------------------------------------------
proc calc_BOT05 {obj args} {

  
  set task            [dict_parse $args "-task" [GET $obj task]] 
  set max_generations [dict_parse $args "-nums"] 
  
  set pops [GET $obj pops]
  
  set num_pops [llength $pops]
  
  set ret [ga_evolution_archipelago  $task $num_pops $pops  $max_generations ]
  
  return $ret
}
#---------------------------------------------------------
proc  final_BOT05 {obj args} {


  set pops [GET $obj pops]    
  set pop0 [lindex $pops 0]
  
  set num_generations [GET $pop0 "generation"] ;# сколько было генераций
  set ch_form         [GET $pop0 "ch_form"]
  
  set num_pops [llength $pops]
  
  for {set i 0} {$i < $num_pops} {incr i} {
    
    set pop [lindex $pops $i] 
    set best_entity     [ga_get_entity_from_rank $pop 0]
  }
  
  return [list $num_generations $best_entity $ch_form]
}
#---------------------------------------------------------

# //------------------------------------------------------------------------------
# //
# //  struggle4.c
# //
# //	This program demonstrates the use of custom GA
# //	operator functions.  The long-hand method is used
# //	to set up the population's genomic form, rather than
# //	and of the high-level utility functions.
# //
# //	This example is explained in docs/html/tutorial4.html
# //
# ------------------------------------------------------------------------------
# struggle5.c
# 
# This example shows the use of multiple populations
# (so called "archipelago" scheme).  This is
# the basic island model of evolution.
# 
# This example is explained in
# http://gaul.sourceforge.net/tutorial/island.html
# and
# http://gaul.sourceforge.net/tutorial/multiprocessor.html
# 

# Specify the number of populations (islands) to use.

set ::GA_STRUGGLE_NUM_POPS	5

# //------------------------------------------------------------------------------
proc _05_test {} \
{

  set num_pops        ""
  set population_size "" 
  set max_generations ""

  parse_opts_3   num_pops population_size max_generations  5 80 250

  comm_random_seed 10 ;# 42
  

  #----------------------------------------------------------------------

  set len_chromo [LTARGET] 
  
  set task [make_task_for_STRU]

  #----------------------------------------------------------------------

  set obj \
    [BOT05 new  -lpop $population_size -lsrc $len_chromo -task $task -num_pops $num_pops ] 

  set pops [GET $obj pops]

  RUN1 "calc_" $obj -nums $max_generations -task $task

  #----------------------------------------------------------------------

  for {set i 0} {$i < $num_pops} {incr i} {
  
    set pop [lindex $pops $i] 

    do_print_best $pop [format " on island %d " $i]
  }
  
  return 1
}
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------

dict_class_create  BOT06 {BOT} {

  ;# _это_перечисление_переменных

} {
  #---------------------------------------------------------

  #set obj [SELF]

  # если нет в args, то берем значение здесь
  # 
  set task   [GET $obj task]
  
  set len_chromo      [dict_parse $args "-lsrc" ] 
  set population_size [dict_parse $args "-lpop" ] 
  

  set seed_proc  "maintest_seed_proc"
        
  set mutate [mutate_create -mutate_proc ga_mutate_printable_singlepoint_drift]

  set pop  [ga_genesis_main                         \
              $task                                 \
              $population_size	                    \
              1			                    \
              $len_chromo                           \
              NULL	                            \
              NULL			            \
              NULL			            \
              NULL                                  \
              $seed_proc                            \
              NULL	                            \
              ga_select_one_bestof2	                    \
              ga_select_two_bestof2	                    \
              $mutate \
              ga_crossover_char_allele_mixing       \
              NULL			            \
              NULL			            \
             ]
  
  
  SET $pop ch_form "%c" ;# 
  
  ga_population_set_parameters \
    $pop	               \
    GA_SCHEME_DARWIN           \
    GA_ELITISM_PARENTS_DIE     \
    0.9			       \
    0.2		               \
    0.0      
  
  ga_population_set_deterministiccrowding_parameters  \
    $pop \
    "ga_compare_char_hamming"
  

  SET $obj "pop"  $pop
}

#---------------------------------------------------------
proc calc_BOT06 {obj args} {

  
  set task            [dict_parse $args "-task" [GET $obj task]] 
  set max_generations [dict_parse $args "-nums"] 
  
  set pop  [GET $obj pop]
  # 
  SET $pop "generation" 0
  SET $pop "itemlist"   {}
  
  ga_deterministiccrowding  $task $pop $max_generations

}
#---------------------------------------------------------


# //------------------------------------------------------------------------------
# //------------------------------------------------------------------------------
# //  struggle_dc.c
# //
# //	This program is almost identical to struggle, except it
# //	applies deterministic crowding instead of a genetic
# //	algorithm.
# //
# //	This example is explained in docs/html/tutorial/simple.html
# //
# //------------------------------------------------------------------------------
proc _dc_test {} \
{

  set        num_runs ""
  set population_size ""
  set max_generations ""

  parse_opts_3   num_runs population_size max_generations  3 120 500

  set ::is_print 1

  #----------------------------------------------------------------------
  #
  for {set i 0} {$i < $num_runs} {incr i} {
  
    comm_random_seed  [+ $i 10]
    
    set len_chromo [LTARGET] 
  
    set task [make_task_for_STRU]

    #----------------------------------------------------------

    set obj \
      [BOT06 new  -lpop $population_size -lsrc $len_chromo -task $task] 

    set pop [GET $obj pop]

    RUN1 "calc_" $obj -nums $max_generations -task $task

    #----------------------------------------------------------

    set best_entity [ga_get_entity_from_rank $pop 0]

    set best_fitnes [item_get_fitn $best_entity] 

    puts "The final solution with seed = $i was:"
    item_print_ch $best_entity ""

    puts ""

    puts ""
    puts [format "With score = %f " $best_fitnes]
    #puts ""
    
  }  
  #
  #----------------------------------------------------------------------

  return 1
}
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc make_pop_DARWIN {task population_size len_chromo} {


  set len_chromo [LTARGET] 
  
  comm_random_seed 10 ;# 23091975

  set seed_proc  "maintest_seed_proc"


  set mutate [mutate_create -mutate_proc ga_mutate_printable_singlepoint_drift]

  set popd [ga_genesis_main                          \
	      $task \
              $population_size			     \
              1			                     \
              $len_chromo                            \
              NULL		  	             \
              NULL			             \
              NULL			             \
              NULL                                   \
              $seed_proc                             \
              _3_struggle_adaptation	             \
              ga_select_one_bestof2	             \
              ga_select_two_bestof2	                     \
              $mutate  \
              ga_crossover_char_allele_mixing        \
              NULL			             \
              NULL			             \
             ]

  SET $popd ch_form "%c" ;# 

  #   ga_population_set_parameters (
  #      popd,			/* population   *pop */
  #      GA_SCHEME_DARWIN,		/* const ga_scheme_type scheme */
  #      GA_ELITISM_PARENTS_DIE,	/* const ga_elitism_type   elitism */
  #      0.9,			/* const double       crossover */
  #      0.1,			/* const double       mutation */
  #      0.0			/* const double       migration */
  #      );
  
  ga_population_set_parameters \
    $popd	               \
    "GA_SCHEME_DARWIN"	       \
    GA_ELITISM_PARENTS_DIE     \
    0.9			       \
    0.1			       \
    0.0      	          


  return $popd
}
# ------------------------------------------------------------------------------

set ::_NEW_ 1
set ::_OLD_ [expr (! $::_NEW_)]

# ------------------------------------------------------------------------------

dict_class_create  BOT79 {BOT} {

  ;# _это_перечисление_переменных

} {
  #---------------------------------------------------------

  set len_chromo      [dict_parse $args "-lsrc"] 
  set population_size [dict_parse $args "-lpop"] 
  set task            [dict_parse $args "-task"] 
  
  set pop [make_pop_DARWIN  $task $population_size $len_chromo] 
  
  SET $obj "pop"   $pop

}
# ------------------------------------------------------------------------------
# proc do_evolution_and_print_best {task pop max_generations name} \
# {

#   ga_evolution  $task $pop $max_generations   

#   do_print_best $pop $name

# }
#---------------------------------------------------------
proc calc_BOT79 {obj args} {
  
  
  set task             [dict_parse $args "-task" [GET $obj task]] 
  set max_generations  [dict_parse $args "-nums"] 
  
  set pop  [GET $obj pop]
  # 
  SET $pop "generation" 0
  SET $pop "itemlist"   {}

  set name [GET $obj name]
  
  #do_evolution_and_print_best $task $pop $max_generations1 $name

  ga_evolution  $task $pop $max_generations {*}$args   

  do_print_best $pop $name

}
# ------------------------------------------------------------------------------
proc BOT07_new {args} {


  set obj  [BOT79 new  {*}$args] 

  return $obj
}
# ------------------------------------------------------------------------------
proc BOT08_new {args} {


  set obj  [BOT79 new  {*}$args] 

  set pop [GET $obj pop]

  ga_population_set_scheme  $pop "GA_SCHEME_BALDWIN_CHILDREN"    

  return $obj
}
# ------------------------------------------------------------------------------
proc BOT09_new {args} {


  set obj  [BOT79 new  {*}$args] 

  set pop [GET $obj pop]

  ga_population_set_scheme  $pop "GA_SCHEME_LAMARCK_CHILDREN"

  return $obj
}
# ------------------------------------------------------------------------------
proc eschemes {} \
{


  global argc argv argv0
  
  set ::is_print 0
  set print $::is_print
  
  set population_size  150
  set max_generations1 600
  set max_generations2 300
  set max_generations3 300
  
  if  {$argc > 1} { 
    
    set population_size  [lindex $argv 1]
    set max_generations1 [lindex $argv 2]
    set max_generations2 [lindex $argv 3]
    set max_generations3 [lindex $argv 4]
    
  }
    
  #----------------------------------------------------------------------

  set task [make_task_for_STRU]

  set len_chromo [LTARGET] 
  
  #----------------------------------------------------------------------

  set obj7 \
    [BOT07_new  -lpop $population_size -lsrc $len_chromo -task $task -name Darwinian ] 
 
  set obj8  \
    [BOT08_new  -lpop $population_size -lsrc $len_chromo -task $task -name Baldwinian] 

  set obj9 \
    [BOT09_new  -lpop $population_size -lsrc $len_chromo -task $task -name Lamarckian] 

  #----------------------------------------------------------

  if {! $print} {
    RUN1 "calc_" $obj7 -task $task -nums $max_generations1 -print $print
  }
  
    RUN1 "calc_" $obj8 -task $task -nums $max_generations2 -print $print
  
  if {! $print} {
    RUN1 "calc_" $obj9 -task $task -nums $max_generations3 -print $print
  }
  
  
  return 1
}
# ------------------------------------------------------------------------------
proc make_random_list_member {source_list} {

  set nums [llength $source_list]
  
  set j [comm_random_int_minmax 0 [- $nums 1]]
  set l [lindex $source_list $j]

  return $l
}
# ------------------------------------------------------------------------------
proc make_random_target_text {source_list  size pmin pmax} {

  set ret {}

  for {set i 0} {$i < $size} {} {

    set l [make_random_list_member  $source_list] ;# или с коэффициентом порядка 

    set povtor [comm_random_int_minmax  $pmin $pmax]

    dotimes p $povtor {

      lappend ret $l

      incr i
      if {$i == $size} {break} ;# вышли из цикла dotimes
    }
  }

  return $ret
}
#-------------------------------------------------------------------------------
proc ent_as_string_list {e ch_form} {


  if {$ch_form == ""} {
    set ch_form [GET $e ch_form] ;# локальная переменная
  }

  set ch  [item_get_mainsrc $e]
  
  #puts -nonewline $out $name
  
  set buf {}

  foreach c $ch {

    #append buf [format $ch_form $c]
    lappend buf [format $ch_form $c]

  } 
  
  return $buf
}
# ------------------------------------------------------------------------------
# proc make_text_variant {task  t} {


#   set size    [GET $task "size"] 
#   set pmin    [GET $task "pmin"] 
#   set pmax    [GET $task "pmax"] 

#   set gp_list      [GET $task "gp_list"] 
#   set target_text0 [GET $task "target_text"] 

  
#   comm_random_seed $t      


#   if {$t == 0} { 
#     # берем задачу-строку  по умолчанию
#     set text  $target_text0
#   } else {
#     set text  [make_random_target_text   $gp_list $size  $pmin $pmax]
#   }
  
#   return $text
# }
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc make_bots_standart {bots lpop size task} {


  dict_set $bots "bot01" [BOT01 new  -lpop $lpop -lsrc $size -task $task]
  dict_set $bots "bot02" [BOT02 new  -lpop $lpop -lsrc $size -task $task]
  dict_set $bots "bot03" [BOT03 new  -lpop $lpop -lsrc $size -task $task]
  dict_set $bots "bot04" [BOT04 new  -lpop $lpop -lsrc $size -task $task]

}
# ------------------------------------------------------------------------------
proc make_bots_list {task gp_list target_text0 args} {


  # -----------------------------------------------------------------

  set mode       [dict_parse  $args "-mode"     S] 

  puts "[procname], mode = $mode ............."
  puts ""

  set lpop       [dict_parse  $args "-lpop"     30]    
  set ::is_print [dict_parse  $args "-print"     1]

  set size       [dict_parse  $args "-size"     [LTARGET]] 
  set pmin       [dict_parse  $args "-pmin"] 
  set pmax       [dict_parse  $args "-pmax"] 

  # -----------------------------------------------------------------


  set bots [dict_create] 
  
  #-------------------------------------------------------------

  if {$mode == "@"} {
  #-------------------------------------------------------------

    comm_random_seed_null 2019 ;# постоянный выбор текстовой строки

    #set lpop 30 ;# 30 ;# 30 ;# 140
    #set ::is_print 1

    make_bots_standart  $bots $lpop $size $task

  #-------------------------------------------------------------
  } \
  elseif {$mode == "T"} {
  #-------------------------------------------------------------

    #set args_add "-size $size "

    #--------------------------------------------

    comm_random_seed_null 2019 ;# постоянный выбор текстовой строки
    
    set vers 0
    set task [make_task_for_STRU -vers $vers]

    ####################
    #dict_print_real $task
    ####################

    set obj [BOT01 new  -lpop $lpop -lsrc $size -task $task -vers $vers]

    dict_set $bots "bot01_vers0" $obj

    ####################
    #dict_print_real $obj
    ####################

    #--------------------------------------------

    set vers 1
    set task [make_task_for_STRU -vers $vers]

    set obj [BOT01 new  -lpop $lpop -lsrc $size -task $task -vers $vers]

    set pop [GET $obj "pop"]
    SET $pop  select_one   "ga_select_one_bestof2"
    SET $pop  select_two   "ga_select_two_bestof2"

    dict_set $bots "bot01_vers1" $obj

  #-------------------------------------------------------------
  } \
  elseif {$mode == "S"} {
  #-------------------------------------------------------------

    # хочу сделать задачу поменьше (быстрее),
    # просто увеличив ошибку?

    SET $task "fit_error" 8.0
    #SET $task "fit_error" 1.0

    make_bots_standart $bots  $lpop $size $task

    # а ведь можно просто фиксировать маленькое кол-во шагов
    # и считать 1) сколько раз достигнем цели или
    #           2) как близко подойдет к ней.
 
  #-------------------------------------------------------------
  } \
  elseif {$mode == "Z"} {
  #-------------------------------------------------------------

    set task [make_task_for_STRU -vers 1]

    #dict_print_real $task
    #exit
    SET $task "fit_error" 8.0

    set sort_driver  "MAX_to_LEFT" 
    set randpop_proc "make_rand_prgpop" ;# "make_rand_prgpop_unikum"
    
    set obj \
      [BOT33 new   -lpop $lpop -lsrc $size \
         -sort_driver $sort_driver  -task $task -is_print 1]
    
    
    dict_set $bots "bot33" $obj 
    
  #-------------------------------------------------------------

  } else {
  #-------------------------------------------------------------

    set task [make_task_for_STRU]

    dict_set $bots "bot$mode" [BOT$mode new  -lpop $lpop -lsrc $size -task $task]

  }
  #-------------------------------------------------------------


  #puts "lpop = $lpop"
  #puts "size = $size"
  #puts ""

return $bots
}
# ------------------------------------------------------------------------------
proc task_correct_target_text {task t r} {

  #set target_text [make_text_variant  $task $t]

  set size    [GET $task "size"] 
  set pmin    [GET $task "pmin"] 
  set pmax    [GET $task "pmax"] 

  set gp_list      [GET $task "gp_list"] 
  set target_text0 [GET $task "target_text"] 

  
  comm_random_seed [+ $t $r]      


  if {$t == 0} { 
    # берем задачу-строку  по умолчанию
    set text  $target_text0
  } else {
    set text  [make_random_target_text   $gp_list $size  $pmin $pmax]
  }


  #SET $task "target_text" $target_text
  SET $task "target_text" $text

  return
}
# ------------------------------------------------------------------------------
proc maintest_531 {} {

  global argc argv

  #puts "argc = $argc   argv = $argv"
 
  # надо оставить только словарные параметры
  # 
  set argv [lrange $argv 1 end]

  # -----------------------------------------------------------------

  set num_text  [dict_parse $argv "-text"  1] ;# 1 ;# 2  
  set size      [dict_parse $argv "-size"  [LTARGET]] 
  #set print     [dict_parse $argv "-print" 0] 

  set pmin 1  ;# 2 выбираем длину блоков повторов из этого интервала: от
  set pmax 4  ;# 3 и до 
  
  # -----------------------------------------------------------------

  set num_text        [dict_parse $argv "-text"  1] ;# 1 ;# 2
  set num_runs        [dict_parse $argv "-runs"  1] ;# 2 ;# 5 ;# количество экспериментов
  set max_generations [dict_parse $argv "-nums" -1] ;# 30 ;# 15 - останов 


  set task  [make_task_for_STRU {*}$argv]

  set botobjs [make_bots_list  $task $::gp_list $::target_text  {*}$argv]


  #---------------------------------------------------------
#   set targets {}

#   for {set t 0} {$t < $num_text} {incr t} {

#     #comm_random_seed $t      
#     set target_text [make_text_variant  $task  $t]
    
#     lappend targets $target_text
#   }
  #---------------------------------------------------------

  #set num_text [llength $targets]

  maintest_run  $botobjs  "task_correct_target_text"  \
                $num_text $num_runs $max_generations  {*}$argv


  # g_stru.tl maintest_531 -mode @ -text 3 -runs 3
  # 
  # 1 mesto :    bot01,   8838 eval
  # 2 mesto :    bot02,  13830 eval
  # 3 mesto :    bot03,  15453 eval
  # 4 mesto :    bot04,  17274 eval

  return
}
#-------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
proc stru_main {} {

  global argc argv argv0

  puts ""
  
  set taskname [lindex $argv 0] ;# имя выч. задачи
  
  $taskname ;# прсто выполним

  puts ""
  
  return
}
#-------------------------------------------------------------------------------

#main
#stru_main

#-------------------------------------------------------------------------------
# 
# TODO:
# 
# +) Cделать ботов по всем тестам и добавить в соревнование maintest_531:

#    + переименовывать по номерам общих тестов, например bot01 для _01_test
#    + для bot02 общего теста нет, сразу в соревнование.
#    + bot03, bot04, bot05
#
#    + _dc_test    : bot06
#    + тест (eschemes, struggle2.c) разбить на bot07, bot08, bot09 

# 2) общая схемы "seed_proc" и "fit_func" (несколько вариантов)

# 3) Тест из файла g-croz.tl bot03  -> bot033, подогнать под общую схему
# 
# 4) Провести соревнования.
# 5) Найти аналогичные сравнительные тесты, пеерписать на них и сравниться.
# 6) Начать реализацию супербота (bot044) с выделением библиотечных подстрок, 
#    сравнить на соревнованиях, доказать, что такая идея дает большой профит!!
# 

# ------------------------------------------------------------------------------

#  g_stru.tl maintest_531 -1  (set num_runs 20)

# 1 mesto :     bot01,  23217 eval
# 2 mesto :     bot05,  26628 eval

# 3 mesto :     bot02,  29040 eval
# 4 mesto :     bot03,  32821 eval
# 5 mesto :     bot04,  45543 eval

# ------------------------------------------------------------------------------

# g_stru.tl _01_test 10 10           ................ PASSED
# g_stru.tl _03_test  3 8 2          ................ PASSED
# g_stru.tl _04_test  10 2 @         ................ PASSED
# g_stru.tl _05_test  2 10 1         ................ PASSED
# g_stru.tl _dc_test  1 5 2  @       ................ PASSED
# g_stru.tl _gp_test 2013 10 6 10    ................ PASSED
# g_stru.tl eschemes  5  1 1 1       ................ PASSED
# g_stru.tl maintest_531 @           ................ PASSED

#-------------------------------------------------------------------------------
#                       bnums, bsize, steps

# g_stru.tl _01_test        30      25           

# ******************************************************************************


#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# source "p_ping.tl"
#-------------------------------------------------------------------------------


# -*-   mode: tcl  ; coding: koi8   -*- ----------------------------------------

#!/bin/sh
# \
exec tclsh "$0" ${1+"$@"}

#-------------------------------------------------------------------------------
# Josef Knecht @ Copyright 
#-------------------------------------------------------------------------------

# set COMPOT "./COMPOT"

# set auto_path [linsert $auto_path 0 $COMPOT]

# set auto_path [linsert $auto_path 0 $COMPOT/COM/common] ;# for JIM

#------------------------------------------

set auto_path [linsert $auto_path 0 "COMMON"]
package require compot::common 

#------------------------------------------

# source "b-com0.tl"
# source "b-com1.tl"

#source "f-rand.tl"

source "p-corE.tl"
source "p-corF.tl"

#source "p-diff.tl"
#source "p-detw.tl"
#source "p-tabu.tl"
#source "p-sima.tl"

#-------------------------------------------------------------------------------
#   pingpong_ALL.c

# 		This program aims to solve a problem proposed in:
# 		Dennis E. Shasha, "Dr Ecco's Omniheurist Corner: Foxy",
# 		Dr Dobb's Journal, 323:148-149 (2001).

# //------------------------------------------------------------------------------
# /*

# Каждая команда состоит из 25 игроков, но для мини-соревнования, только 9 лучших
# игроков будет заявлено.
# Команда А - лучшая команда (в среднем), но команда В также имеет несколько 
# замечательных игроков.

# Предположим, мы пронумеруем в каждой команде игроков от 0 (лучший) до 24 (слабейший)
# так что: A[0] - лучший игрок в команде A, B[0] - лучший игрок в команде B. 
# Далее предположим, что игрок A[i] побеждает игрока B[i] на 2 очка для каждого i
# от 0 до 24 включительно.
# Однако, B[i] может побить A[i+1] (для каждого i от 0 до 23) на 2 очка.
# И далее, согласно транзитивности, получаем диаграмму силы (через 2 очка) :

# A[0] -> B[0] -> A[1] -> B[1] -> A[2] -> B[2] -> A[3] 

# Тренер команды B (которая в среднем слабее) - знает всю эту схему. 
# Тренер команды A - не в курсе!
# Тренер B понимает, что его команда будет терять по 2 очка на каждой "правильной"
# паре, т.е. B[0] -- A[0], B[1] -- A[1] и т. д. 
# Соответственно, он хочет  организовать схему соревнования таким образом, чтобы 
# выиграть больше игр, чем команда A, и при этом не разбудить подозрения у 
# тренера A.
# Тренер  A может стать подозрительным. если "average point spread" в играх, где 
# игроки команды A выиграют - слишком велика или если "maximum point spread" в таких
# играх  is too high.

# Таким образом, ТренерB поставил перед собой задачу -  составить пары из своих игроков 
# противигроков  команды A таким образом, чтобы игроки команды B не проигрывали больше 
# 10 очков и чтобы "average point spread" для игр где A побеждали - был не больше 7. 

#---------------------------------------------------------

# Here is an example to show you how this would go: If there were just five 
# players on each side, then ТренерB might pair up

# Ateam		Bteam
# 0		4
# 1		0
# 2		1
# 3		2
# 4 	        3

# which would enable B players to win by 2 points in every game except against 
# A[0]. However, B[4] would then lose by 18 points. Foxy wouldn't choose this 
# strategy because he would arouse the suspicions of ТренерА. Besides, 
# he needs only a majority of games, not 4 out of 5."


# Reader: First try to figure out a winning strategy for тренера B in the case of 
# the mini-competition (nine players on each team) and then for the case of 
# the maxi-competition (25 players on each team). 

# 1) In neither case should a B player lose by more than 10 points and 
# 2) the average B loss should be as near to 6 points as possible. 

# One last wrinkle not mentioned by the champions: 
# In the case of 25 players, at least five of the B wins should be by 2 points.


# ------------------------------------------------------------------------------
# Score solution.

# чем больше фитнес, тем лучше ??
#  
#-------------------------------------------------------------------------------
proc SQU {x} {

  return [expr {$x * $x}]
}
# ------------------------------------------------------------------------------
proc pingpong_score {entity task} {

  #   int i;  // Команда А (сильнейшая)       
  #   int j;  // Команда В (хитрая)

  set     score  0 ;# 0.0
  set lossscore  0 ;# 0.0
  set  badscore  0 ;# 0.0
  
  set  badloss 0
  set  loss    0
  
  # pilot
  #  
  #set len_chromo [GET $pop lsrc] ;# /* 25 */ /* 9 */ 

  #puts ""
  #puts "entity = [set $entity]"
  #puts ""
  set len_chromo [item_get_chromo_len $entity] 
 
  set is_score_print 0 ;# 0
 
  # делаем предварительные подсчеты по играм турнира
  #  
  if {$is_score_print} {
    puts ""
    puts "::: ~~~~~ pingpong_score BEGIN ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    puts ""
  }
  
  for {set i 0} {$i < $len_chromo} {incr i} {

    set j [item_get_chromo_gen $entity  $i] ;# соперник для игрока i ????
    
    
    if {$is_score_print} {
      #puts ""
      puts "::: i = $i   j = $j "
      puts ""
    }

    set score [expr {($j - $i) * 4 + 2}] ;# результат игры в этой паре (в очках)
    
    if {$is_score_print} {
    puts "::: i = $i   j = $j  score = $score"
    }

    if {$score > 0} {
      incr loss             ;# число проигрышей 
      incr lossscore $score ;# очков проиграно
      
      if {$score > 10} { 
        incr badloss
        incr badscore $score
      }
    }    
  }
  
  set lossscore [expr {1.0 * $lossscore / $loss}] ;# средний проигрыш
  
  
  if {$is_score_print} {
  puts "::: score     = $score"
  puts "::: loss      = $loss "
  puts "::: lossscore = $lossscore"
  puts "::: badscore  = $badscore "
  }

  # теперь начинаем считать фитнес (от нуля и ухудшая в сторону уменьшения)
  #  
  set fitness  0 ;# пока в локальной переменной, а потом запишем!
  
  # Ни в каком случае игрок не должен проиграть больше 10 очков.
  #   
  set fitness [expr {$fitness - ($badscore * 2.0)}]
  
  # Средний проигрыш должен быть по возможности не больше 6. 
  # 
  set fitness [expr {$fitness - ([SQU [expr 6 - $lossscore]] * 3.0)}] ;# ??
  
  # Команда должна выиграть большинство игр.
  #  
  if {$loss > 12} {
    set fitness [expr {$fitness - $loss}]
  }
  

  if {$is_score_print} {
    puts "::: entity->fitness = $fitness"
    puts "::: ~~~~~ pingpong_score FINAL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  }

   return $fitness 
}
# //------------------------------------------------------------------------------
# // Seed initial solutions.
# //------------------------------------------------------------------------------
proc pingpong_seed {pop task adam} {

  # int	  i, j;   // Team members 
  
  set len_chromo [GET $pop lsrc] ;# /* 25 */ /* 9 */
  
 
  for {set i 0} {$i < $len_chromo} {incr i} \
  {
    item_set_chromo_gen $adam  $i -1 ;# забили пустышками
  }


  for {set i 0} {$i < $len_chromo} {incr i} \
  {
    set j [comm_random_int $len_chromo] ;# выбрали второй случайный индекс
    
    while {[item_get_chromo_gen $adam  $j] > -1}  {

      if {$j == [expr {$len_chromo - 1}]} {
        set j 0
      } else {
        incr j ; # двигаемся вправо по кругу, пока не найдем первый свободный
      }
    }
    
    item_set_chromo_gen $adam  $j  $i
  }
  
  return true
}
# //------------------------------------------------------------------------------
# // Mutation by swapping two team members.
# //------------------------------------------------------------------------------
# void 
# pingpong_mutate_swap (population *pop, entity *mother, entity *son)
# //------------------------------------------------------------------------------
proc pingpong_mutate_swap {pop mother son} {

  #puts "pingpong_mutate_swap: ................ "

  #   int	   i, j;  /* Team members.         */
  #   int	   tmp;	  /* For swapping i and j. */
  
  #   //pilot
  #   int  len_chromo = pop->lsrc; /* 25 */ /* 9 */
  set len_chromo [GET $pop lsrc]
  
  #   // Copy chromosomes of parent to offspring. 
  #   // 
  #   memcpy (son->CH,
  #           mother->CH,
  #           pop->lsrc * sizeof(int));

  item_set_mainsrc $son [item_get_mainsrc $mother]

  #   i = random_int (len_chromo);
  #   j = random_int (len_chromo);

  set i [comm_random_int $len_chromo]
  set j [comm_random_int $len_chromo]
    
  if {$i == $j} \
  {
    if {$j == [expr {$len_chromo - 1}]} {
      set j  0
    } else {
      incr j
    }
  }
  
  #puts "pingpong_mutate_swap: i = $i  j = $j"

  #   tmp = ((int *)son->CH)[i];
  set tmp [item_get_chromo_gen $son  $i]
  
  #   ((int *)son->CH)[i] = ((int *)son->chromosome[0])[j];
  item_set_chromo_gen $son $i [item_get_chromo_gen $son $j]

  #   ((int *)son->CH)[j] = tmp;
  item_set_chromo_gen $son $j $tmp
  
  #   return;
}
# //------------------------------------------------------------------------------
# // Crossover.
# //------------------------------------------------------------------------------
# void 
# pingpong_crossover (population *pop, entity *mother,   entity *father, 
#                                      entity *daughter, entity *son)
# {
# //------------------------------------------------------------------------------
proc pingpong_crossover {pop task  mother father dau son} {

#   int	  i, j;	/* Team members. */

#   //pilot
#   int  len_chromo = pop->lsrc; /* 25 */ /* 9 */
  set len_chromo [GET $pop lsrc]
  

  for {set i 0} {$i < $len_chromo} {incr i} \
    {
      if {[comm_random_boolean]} \
        {
          #       ((int *)     son->CH)[i] = ((int *)father->CH)[i];
          #       ((int *)daughter->CH)[i] = ((int *)mother->CH)[i];
          item_set_chromo_gen $son $i [item_get_chromo_gen $father $i]
          item_set_chromo_gen $dau $i [item_get_chromo_gen $mother $i]

        } else {
          # !!!!!!!!! то же самое ??
          #
          #       ((int *)     son->CH)[i] = ((int *)father->CH)[i];
          #       ((int *)daughter->CH)[i] = ((int *)mother->CH)[i];
          item_set_chromo_gen $son $i [item_get_chromo_gen $father  $i] 
          item_set_chromo_gen $dau $i [item_get_chromo_gen $mother  $i]
      }
    }
  
  for {set i 1} {$i < $len_chromo} {incr i} \
    {
      for {set j 0} {$j < $i} {incr j} \
        {

          set son_i [item_get_chromo_gen $son  $i]
          set son_j [item_get_chromo_gen $son  $j]

          #       if (((int *)son->CH)[j] == ((int *)son->CH)[i])
          if {$son_j == $son_i} \
          {
            #  if (((int *)son->CH)[i] == len_chromo-1)
            if {$son_i == [expr  {$len_chromo - 1}]} {
              # ((int *)son->CH)[i] = 0;
               item_set_chromo_gen $son $i 0 
            } else {
              # ((int *)son->CH)[i]++;
              item_set_chromo_gen $son $i [expr {$son_i + 1}] 
            }

            set j 0
          }
        }
      
      # тоже самое для дочери !!!
      # 
      for {set j 0} {$j < $i} {incr j} \
        {
          set dau_i [item_get_chromo_gen $dau  $i]
          set dau_j [item_get_chromo_gen $dau  $j]

          #  if (((int *)daughter->CH)[j] == ((int *)daughter->CH)[i])
          if {$dau_j == $dau_i} \
          {
          # if (((int *)daughter->CH)[i] == len_chromo-1)
            if {$dau_i == [expr  {$len_chromo - 1}]} {
             #   ((int *)daughter->CH)[i] = 0;
             item_set_chromo_gen $dau $i 0 
           } else {
             #   ((int *)daughter->CH)[i]++;
             item_set_chromo_gen $dau $i [expr {$dau_i + 1}] 
           }

           set j 0
          }
        }
  }
  
  return
}
# //------------------------------------------------------------------------------
# // Mutation by shifting a team member.
# //------------------------------------------------------------------------------
# void 
# pingpong_mutate_shift (population *pop, entity *mother, entity *son)

# //------------------------------------------------------------------------------
proc pingpong_mutate_shift {pop mother son}  {

  #puts "pingpong_mutate_shift .......... "

  #   int	   i, j, k;	/* Team members.         */
  #   int	   tmp;		/* For swapping i and j. */
  
  #   //pilot
  #   int  len_chromo = pop->lsrc; /* 25 */ /* 9 */
  set len_chromo [GET $pop lsrc]
  
  #   /* Copy chromosomes of parent to offspring. */
  #   memcpy (son->CH,
  #           mother->CH,
  #           pop->lsrc * sizeof (int));

  item_set_mainsrc $son [item_get_mainsrc $mother]
  
  #   i = random_int (len_chromo);
  set i [comm_random_int $len_chromo]
  
  #   do {
  #     j = random_int (len_chromo);
  
  #   } while (i == j);

  while {1} {
    set j [comm_random_int $len_chromo]
    if {$i != $j} {break}
  }
  
  
  if {$i > $j} \
  {
    #     tmp = ((int *)son->CH)[j];
    set tmp [item_get_chromo_gen $son  $j] 
   
    for {set k $j} {$k < $i} {incr k} \
    {
      #       ((int *)son->CH)[k] = ((int *)son->CH)[k+1];
      item_set_chromo_gen $son $k [item_get_chromo_gen $son [expr {$k + 1}]] 
    }
    #     ((int *)son->CH)[i] = tmp;  #       не надо ???????!!!!!
    item_set_chromo_gen $son $i $tmp
    
  } else {
    
    #     tmp = ((int *)son->CH)[j];
    set tmp [item_get_chromo_gen $son  $j] ;# ??? одно и тоже ??
    
    for {set k $j} {$k > $i} {incr k -1} \
    {
      #       ((int *)son->CH)[k] = ((int *)son->CH)[k-1];
      item_set_chromo_gen $son $k [item_get_chromo_gen $son [expr {$k - 1}]] 
    }
    #     ((int *)son->CH)[i] = tmp; #       не надо ???????!!!!!
    item_set_chromo_gen $son $i $tmp
  }
  
  #   return;
}
# //------------------------------------------------------------------------------
# // Mutation.
# //------------------------------------------------------------------------------
# void 
# pingpong_mutate (population *pop, entity *mother, entity *son, 
#                  double r_prob)
# //------------------------------------------------------------------------------
proc  pingpong_mutate {pop mother son r_prob} {

  if {[comm_random_boolean_prob  $r_prob]} {
    pingpong_mutate_swap  $pop $mother $son

  } else {
    pingpong_mutate_shift $pop $mother $son
  }
  
  #   return;
}
# /*******************************************************************************

#   pingpong1.c

#   Обратите внимание, что это, вероятно, не является методом выбора
#   для решения данной проблемы - а используется только в качестве иллюстрации.

#   В этом примере используются кастомные операторы кроссовера и мутации, поскольку
  

#   This example uses custom crossover and mutation
#   operators since a given team member is unable to
#   play twice.

# //------------------------------------------------------------------------------
proc pingpong_genesis {population_size len_chromo         
                       mutate                             
                       select_one select_two crossover} { \


  #   //int population_size = 50;  
  #   population *pop = NULL;   /* Population of solutions. */
  
  set task [task_create  -fit_func "pingpong_score" -fit_tobest "MAX"]

  set pop [ga_genesis_main      \
	     $task \
	   $population_size  \
	     1                 \
              $len_chromo       \
              NULL              \
              NULL              \
              NULL              \
              NULL              \
              pingpong_seed     \
              NULL              \
              $select_one       \
              $select_two       \
              $mutate           \
              $crossover        \
              NULL              \
              NULL	        \
          ]
  

  return [list $task $pop]
}
# //------------------------------------------------------------------------------
proc main_ga {len_chromo} {

  set num_runs        "" ;
  set population_size "" ;
  set max_generations "" ;
  
  set print [parse_opts_3   num_runs population_size max_generations  50 50 200]
  

  for {set i 0} {$i < $num_runs} {incr i} {
 
    set seed [expr {424242 * $i + 10}]
    
    comm_random_seed $seed
  
    # set pop [pingpong_genesis  $population_size $len_chromo pingpong_mutate_0_2 \
    #          ga_select_one_randomrank \
    #          ga_select_two_randomrank \
    #          pingpong_crossover]
  
    foreach {task pop}  [pingpong_genesis  $population_size $len_chromo pingpong_mutate_0_5 \
			   ga_select_one_bestof2  \
			   ga_select_two_bestof2  \
			   pingpong_crossover] {}
  
    #     ga_population_set_parameters (
    #        pop,			   /* population                *pop */
    #        GA_SCHEME_DARWIN,	   /* const ga_scheme_type    scheme */
    #        GA_ELITISM_PARENTS_SURVIVE, /* const ga_elitism_type  elitism */
    #        0.5,			   /* double  crossover              */
    #        0.5,			   /* double  mutation               */
    #        0.0              	   /* double  migration              */
    #        );
    
    ga_population_set_parameters                          \
                               $pop	                  \
                               GA_SCHEME_DARWIN	          \
                               GA_ELITISM_PARENTS_SURVIVE \
                               0.5			  \
                               0.5			  \
                               0.0      	          

    SET $pop ch_form "%02d " ;# 

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #
    ga_evolution  $task $pop  $max_generations   -print $print  
    #
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    puts ""
    puts "The final solution with found was: (seed = $seed):"
    
    set bestentity [ga_get_entity_from_rank $pop 0]
    
    set beststring [item_get_mainsrc $bestentity]
    

    puts $beststring
    puts [format "With score = %f" [item_get_fitn $bestentity]]
    puts ""
    
  }
  
  
}
# /*******************************************************************************
#   pingpong9.c

# 		Note that this probably isn't the method of choice
# 		for solving this problem - it is just used as an
# 		illustration.

# 		This example uses custom crossover and mutation
# 		operators since a given team member is unable to
# 		play twice.

#   pingpong_tabu.c

# 		This example uses the tabu-search algorithm instead of
# 		a GA.
  
# //------------------------------------------------------------------------------
# void 
# pingpong_mutate_0_5 (population *pop, entity *mother, entity *son)
# //------------------------------------------------------------------------------
#proc pingpong_mutate_0_5 {pop mother son} {}
proc pingpong_mutate_0_5 {pop task mother son} {

  #   /* Checks. */
  #   if (!mother || !son) die ("Null pointer to entity structure passed");
  
  pingpong_mutate  $pop $mother $son 0.5
  
  #   return;
}
# //------------------------------------------------------------------------------
# //
# //------------------------------------------------------------------------------
proc main_t1 {len_chromo} {

  #   //int len_chromo      =  25; // т.е. правила .. можно ли изменять ??
  
  set num_runs        ""
  set population_size ""
  set max_iterations  ""
  
  parse_opts_3   num_runs population_size max_iterations  50 50 100
  
  
  for {set i 0} {$i < $num_runs} {incr i} {
 
    #     // Note that most of the population data is not required for a tabu-search. 
    #     // 
    
    set seed [expr {230975 * $i + 10}]
    comm_random_seed $seed
  
    foreach {task pop}   [pingpong_genesis  $population_size $len_chromo pingpong_mutate_0_5 \
			    NULL NULL NULL] {}
    
    #     /* ga_population_set_tabu_parameters() is required instead of
    #      * the usual ga_population_set_parameters().
    #      */
    #     ga_population_set_tabu_parameters (
    #        pop,			/* population	   *pop                            */
    #        ga_tabu_check_integer,	/* GAtabu_accept   tabu acceptance criterion       */
    #        50,			/* const int	   tabu list length                */
    #        20			        /* const int	   tabu neighbourhood search count */
    #        );
    
    ga_population_set_tabu_parameters                     \
                               $pop	                  \
                               ga_tabu_check_integer	  \
                               50			  \
                               20      	          

    SET $pop ch_form "%02d " ;# 

    #     /* ga_tabu() is called instead of ga_evolution().  The NULL parameter indicates
    #      * that a random (as generated by the GAseed callback) should be used.
    #      * Alternatively, a specific starting solution may be passed.
    #      */
    
    #     ga_tabu (
    #        pop,			/* population		*pop           */
    #        NULL,			/* entity		*initial       */
    #        max_iterations		/* const int		max_iterations */
    #        );
    
    ga_tabu $task     \
            $pop \
            NULL \
            $max_iterations 
    

    #     /* ga_tabu() doesn't sort the population.  Using ga_population_score_and_sort() is
    #      * therefore required so that we know which entity was optimised, but this process
    #      * is fairly inefficient.  This is not needed if a specific entity is passed to
    #      * ga_tabu() for optimisation.
    #      */
    
    #if {$::is_print} {
    #  pop_print $pop
    #}

    ga_population_score_and_sort $pop $task
    

    set bestentity [ga_get_entity_from_rank $pop 0]
    
    puts ""
    puts [format "The best solution found on attempt %d with fitness %f was:" $i \
            [item_get_fitn $bestentity]]
#            [ent_get_fitness $bestentity]]
    

    item_print_ch $bestentity ""
    puts ""
    puts ""
    
  }
  
}
# //------------------------------------------------------------------------------
proc main_sa {} {

  
  set num_runs        ""
  set population_size ""
  set max_iterations  ""
  
  parse_opts_3   num_runs population_size max_iterations  50 50 1000
  
  for {set i 0} {$i < $num_runs} {incr i} {
   
    set seed [expr {230 * $i + 10}] ;# !!! получается иногда ноль !!!

    #puts "main_sa: seed = $seed"
    #set seed 2021
    
    comm_random_seed $seed
  
    #     /* Note that most of the population data is not required for
    #       * simulated annealling.
    #       */
    
    #     pop = ga_genesis_integer (
    #        population_size,		/* const int              population_size      */
    #         1,			/* const int              num_chromo           */
    #        25,			/* const int              len_chromo           */
    #        NULL,			/* GAgeneration_hook      generation_hook      */
    #        NULL,			/* GAiteration_hook       iteration_hook       */
    #        NULL,			/* GAdata_destructor      data_destructor      */
    #        NULL,			/* GAdata_ref_incrementor data_ref_incrementor */
    #        pingpong_score,		/* GAevaluate             evaluate             */
    #        pingpong_seed,		/* GAseed                 seed                 */
    #        NULL,			/* GAadapt                adapt                */
    #        NULL,			/* GAselect_one           select_one           */
    #        NULL,			/* GAselect_two           select_two           */
    #        pingpong_mutate_0_5,	/* GAmutate               mutate               */
    #        NULL,			/* GAcrossover            crossover            */
    #        NULL,			/* GAreplace              replace              */
    #        NULL			/* vpointer		  User data            */
    #        );
    
    set len_chromo 25
   
    set task [task_create  -fit_func "pingpong_score" -fit_tobest "MAX"]

    set pop [ga_genesis_main   \
	       $task \
               $population_size  \
               1                 \
               $len_chromo       \
               NULL              \
               NULL              \
               NULL              \
               NULL              \
               pingpong_seed     \
               NULL              \
               NULL              \
               NULL              \
               pingpong_mutate_0_5 \
               NULL              \
               NULL              \
               NULL	         \
              ]

    #     // Evaluate the initial 50 population members. 
    #     //
    ga_population_score_and_sort $pop $task
    
    #     /* ga_population_set_sa_parameters() is required instead of
    #      * the usual ga_population_set_parameters().
    #      */

    #     ga_population_set_sa_parameters (
    #        pop,			/* population	   *pop                         */
    #        ga_sa_boltzmann_acceptance,/* GAsa_accept	   SA acceptance criterion      */
    #        100.0,		        /* const double	   Initial temperature          */
    #        0.0,		        /* const double	   Final temperature            */
    #        10.0,		        /* const double	   Temperature step size        */
    #        50			        /* const int	   Temperature update frequency */
    #        );
    
    ga_population_set_sa_parameters    \
            $pop                       \
            ga_sa_boltzmann_acceptance \
            100.0                      \
              0.0                      \
             10.0                      \
             50 	       
    
    
    #------------------------------------------------------------
    if {0} {

      set ch_form {%s }
      #set ch_form {123 4}
      
      puts "ch_form = |$ch_form|"
      
      SET $pop  ch_form $ch_form  
      
      set ch_form [GET $pop "ch_form"]
      
      puts "ch_form = |$ch_form|"
      
      exit

    } else {

      SET $pop  ch_form "%s " 
    }
    #------------------------------------------------------------
    
    if {$::is_print} { 
      puts ""
      puts "POP_PRINT  11111111111111111 : "
      puts ""
      
      pop_print $pop
    }

    #     /* ga_sa() is called instead of ga_evolution().  We use the best of the
    #      * initial 50 population members.  This entity is overwritten with an
    #      * improved version.
    #      */

    #set solution [ga_get_entity_from_rank  $pop 0]
    set solution "NULL"

    if {$::is_print} { 
      puts ""
      puts "solution = $solution"
      puts ""

      #item_print_ch  $solution
    }
    
    ga_sa  $task $pop      \
           $solution \
           $max_iterations 
    
    #pop_print $pop
    #exit
    
    # // попробуем вот так:
    # // 
    ga_population_score_and_sort  $pop $task

    set bestentity [ga_get_entity_from_rank $pop 0]
    
    puts ""
    puts [format "Final best: i = %d, seed = %d  fitness %f, beststring = " $i $seed \
            [item_get_fitn $bestentity]]

    item_print_ch $bestentity ""
    puts ""

    # ошибка в ch_form: надо {%s }, а у нас в JIM почему-то просто %s
    # это было в a-comm.tl : proc SET - скобочки {} надо для всех значений !!??
    #
    #puts stderr "bestentity = [set $bestentity]"

    puts ""
    
    #     // Just used here to write the resulting solution.
    #     //
    #     //pingpong_iteration_callback (i, solution);	
    #     //pingpong_iteration_callback (i, bestentity);	
    
    #     ga_extinction (pop);
  }
  
} 
# //------------------------------------------------------------------------------
# // 
# // l_pingpong _09
# // 
# // - вводить все параметры через командную строку;
# // - выделить общие процедуры по максимуму; 
# // 
# //------------------------------------------------------------------------------
proc ping_main {} {

  #set ::NEWEST 1 ;# !!!!!!!!!!!!!!!!!!! OK !!!!

  global argc argv argv0

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  #lset_test 

  #exit
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#   if (argc < 2) 
#     exit (EXIT_SUCCESS);

  set mode [lindex $argv 0] ;# имя выч. задачи

  set ::is_print 2 

  if     {$mode ==    "_09"}    { main_ga  9 } \
  elseif {$mode ==    "_25"}    { main_ga 25 } \
  elseif {$mode == "_t1_09"}    { main_t1  9 } \
  elseif {$mode == "_t1_25"}    { main_t1 25 } \
  elseif {$mode == "_t2_09"}    { main_t2  9 } \
  elseif {$mode == "_t2_25"}    { main_t2 25 } \
  elseif {$mode == "_sa"}       { main_sa    } \
  \
  else {
    puts ""
    puts "ERROR mode = $mode"
    puts ""
  }

#   if (!strcmp(argv[1], "_09"))    main_ga ( 9, argc, argv); // малое соревнование
#   if (!strcmp(argv[1], "_25"))    main_ga (25, argc, argv);

#   if (!strcmp(argv[1], "_t1_09")) main_t1 ( 9, argc, argv);
#   if (!strcmp(argv[1], "_t1_25")) main_t1 (25, argc, argv);

#   if (!strcmp(argv[1], "_t2_09")) main_t2 ( 9, argc, argv);
#   if (!strcmp(argv[1], "_t2_25")) main_t2 (25, argc, argv);

#   if (!strcmp(argv[1], "_sa"))    main_sa (argc, argv);

#   exit (EXIT_SUCCESS);
}
# //-----------------------------------------------------------------------------

#ping_main

# //-----------------------------------------------------------------------------
# //------------------------------------------------------------------------------

# /* X1:l_pingpong,_09 ... PASSED */
# /* X1:l_pingpong,_25 ... PASSED */
# /* X1:l_pingpong,_t1 ... PASSED */
# /* X1:l_pingpong,_t2 ... PASSED */

# //******************************************************************************




#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# source "p_orov.tl"
#-------------------------------------------------------------------------------


# -*-   mode: tcl  ; coding: koi8   -*- ----------------------------------------

#!/bin/sh
# \
exec tclsh "$0" ${1+"$@"}

#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------

# set COMPOT "./COMPOT"
# set auto_path [linsert $auto_path 0 $COMPOT]
# set auto_path [linsert $auto_path 0 $COMPOT/COM/common] ;# for JIM


set auto_path [linsert $auto_path 0 "COMMON"]
package require compot::common 

#------------------------------------------

# source "b-com0.tl"
# source "b-com1.tl"
# source "f-rand.tl"

source "p-corE.tl"
source "p-corF.tl"

#source "p-diff.tl"

# ;#-------------------------------------------------------------------------------

# ; задача определения координат (1D, 2D) точек по их расстояниям
# ; 
# ; MDS - Multidimension Scaling

# ;-------------------------------------------------------------------------------

# ; TODO:

# ; -) координаты фиксированных точек тоже надо вводить с погрешностями
# ; -) расстояния тоже могут быть не точны? как быть? варьировать по очереди?
# ; -) для представления точек и узлов использовать библиотеку графов

# ;#-------------------------------------------------------------------------------
# ;#-------------------------------------------------------------------------------

# ; параметры задачи:
# ; 

# ;(defvar _new          #f)
# ;(defvar _new          #t)

# ;(defvar *seed_points* NIL)
# ;(defvar *seed_points_index* 0)

# (defvar *max_val_arr* NIL)

# (defvar *dim*     NIL)
# (defvar *n_ext*   NIL)  
# (defvar *n_fix*   NIL)


# (defvar *max_len_defnode* 5) ; формат записи

# (defvar *work_fix_points* NIL) ; для удобства: начальные фиксированные точки
# (defvar *work_point*      NIL) ; для удобства: рабочая точка

# (defvar *nodes*      NIL)
# (defvar *edges*      NIL)


# ;# /*******************************************************************************
# ;# //------------------------------------------------------------------------------
proc point_from_chromosome {chromosome i} {

  #   ; здесь надо учитывать размерность точек !!
  #   ;
  #   ; cначала выпишем координаты в глобальную рабочую точку
  
  for {set d 0} {$d < $::dim} {incr d} {
  
    lset ::work_point $d [lindex $chromosome  [expr {($i * $::dim) + $d}] ]
  }
  
  return $::work_point
}
# ;# //------------------------------------------------------------------------------
proc point_print {point} {


  puts -nonewline  "\[" 
  
  for {set d 0} {$d < $::dim} {incr d} {
  
    puts -nonewline [format "%9.6f " [lindex $point $d]]
  }
  
  puts -nonewline  "\] "

}
# ;# //------------------------------------------------------------------------------
proc name_by_ind {ind} {

  set name "NAME"

  #   ;;(loop for n :across *nodes* :do
  #   ;;
  #   ;; )
  
  set name [lindex $::nodes $ind]

  return $name
}
# ;# //------------------------------------------------------------------------------
proc ext_point_print {point ext_ind} {

  set all_ind  [+ $::n_fix $ext_ind]
  set name  [name_by_ind   $all_ind]
  
  
  #   ;(format t "p~d (~s) = "  all_ind name)   
  #   ;(format t "p~s = "  name) 
  
  puts -nonewline  [format "%4s = "  $name] 
  
  point_print $point

}
# ;# //------------------------------------------------------------------------------
# ;# //  synopsis:	Generation callback
# ;# //------------------------------------------------------------------------------
# ;# static boolean 
# ;# test_generation_callback (int generation, population *pop)
# ;# //------------------------------------------------------------------------------
proc orov_generation_callback {generation pop} {


  if {[expr {$generation % 10}] == 0} {

    set best [pop_get_entity_  $pop  0] 
    
    puts stderr "orov_generation_callback: pop = [set $pop], best = $best"

    set best_chromo  [item_get_mainsrc  $best]
    set best_fit     [item_get_fitn     $best]
    
    
    puts -nonewline [format "%3d  : "  $generation]
    
    if $::__is_print {

      for {set i 0} {$i < $::n_ext} {incr i} {
      
        set p [point_from_chromosome  $best_chromo $i]
        ext_point_print  $p $i
      }
    }
    
    puts [format "(fitness = %9.6f) "  $best_fit]
    
  }
  
  return true
  
}
# ;#-------------------------------------------------------------------------------
# ;#-------------------------------------------------------------------------------
# ;#-------------------------------------------------------------------------------
# ;(defun find_len_true (edges ind_A ind_B)

# ;(let* (
# ;  )

# ;  (loop for e in edges do 
    
# ;    (when (and (= (nth 0 e) ind_A) (= (nth 1 e) ind_B))
# ;      (return-from find_len_true (nth 2 e))
# ;      )
# ;    )

# ;  (die "find_len_true")

# ;))
# ;#-------------------------------------------------------------------------------
# ;(defun calc_err_main (ind_A ind_B  points edges)

# ;(let* (
# ;  (A (elt points ind_A))
# ;  (B (elt points ind_B))

# ;  (len_true (find_len_true edges  ind_A ind_B))
# ;  )

# ;  (calc_err  A B len_true)

# ;))

# ;#-------------------------------------------------------------------------------
proc calc_len {A B} {

  # (let* (
  #   A_xyz B_xyz
  
  #   ;len 
  #   val 
  set sum 0
  #   )
  
  #   ;(setf a (first A)) ; здесь д.б. сама точка 
  
  #   (loop :for d :from 0 :below *dim* :do
  for {set d 0} {$d < $::dim} {incr d} {
  
    set A_xyz [lindex $A $d]
    set B_xyz [lindex $B $d] ;# соотв. координаты концов отрезка
    
    #     ;;(setf len (abs (- A_xyz B_xyz))) 
    
    set val [expr {$A_xyz - $B_xyz}] 
    
    incf sum [expr {$val * $val}]
  }
  
  #   ;(sqrt len) 
  
  return [expr {sqrt ($sum)}] 
  
}
# ;#-------------------------------------------------------------------------------
proc calc_err {A B len_true} {

  # (let* (
  
  set len [calc_len  $A $B]   
  #   )
  
  
  return [expr {abs ($len - $len_true)}]
  
}
# ;#-------------------------------------------------------------------------------
proc calc_err_for_one_edge {e points} {

  #   err
  #   ;(full_err 0)
  #   ;(summ_err 0)
  
  #   A B ;fitness
  #   A_ind B_ind  
  #   L_true
  
  
  set A_ind  [lindex $e 0] ;# (nth 0 e))
  set B_ind  [lindex $e 1] ;# (nth 1 e))
  set L_true [lindex $e 2] ;# (nth 2 e))
  
  set A [lindex $points $A_ind] ;# это многомерные точки !! с радиусами ??
  set B [lindex $points $B_ind]
  
  set err [calc_err  $A $B  $L_true]

  return $err
}
# ;#-------------------------------------------------------------------------------
proc calc_fitness_from_points {points edges} {

  #   err
  set summ_err 0
  #   ;(mult_err 0)
  
  #   fitness
  
  #   ;(format t "calc_fitness_from_points: points = ~s ~%" points)
  
  #  (loop :for e :in edges :do 
  foreach e $edges {
  
    set err [calc_err_for_one_edge  $e $points]
    
    incf summ_err  $err  ;# простая сумма? 

    #    ;(incf mult_err (* err err)) ; квадратичная, с послед. корнем?
  }
  
  #  -----------------------------------------------------
  # т.е. чем больше тем хуже или "чем меньше тем лучше"
  # 
  set fitness [expr {- $summ_err}]
  #
  # а теперь, "чем больше тем лучше" , стремясь к нулю !

  #   ;;
  #   ;(setf fitness (- (sqrt mult_err))) ;- какая лучше, вроде особо нет разницы
  
  
  return $fitness
  
}
# ;#-------------------------------------------------------------------------------
# ;#-------------------------------------------------------------------------------
# ;# //  synopsis:	Fitness function.

# ;# /* static */ boolean 
# ;# _test_score (population *pop, entity *this_entity)
# ;#-------------------------------------------------------------------------------
proc _test_score {this_entity task} {

  # (declare (ignore pop))
  
  #   fitness
  
  #   ;;  # нулевая точка должна быть фиксированна !
  #   points 
  
  
  #   ;;   0        1        2       3       4
  
  #   ;;   O ------ A ------ B ----- C ----- D
  #   ;;  
  #   ;;            1        0       1       4   cl orovos.cl 50 50 
  
  #   ;;  |AB| = 1
  #   ;;  |BC| = 1
  #   ;;  |AD| = 3
  #   ;; 
  
  # ;  (edges '(
  # ;          (0 1  1.0)
  
  # ;          (1 2  1.0)
  # ;          (2 3  1.0)
  # ;          (1 4  3.0) ; cl orovos.cl  69 10
  # ;          ;(3 4  1.0)
  # ;          ))
  
  # ;  (n     4)
  # ;  (*n_fix* 1)
  
  #   ;(x0  0) ;  эта точка участвует в расчетах фитнеса, но ен участвует в геноме
  #   ; можно считать их в общей схеме полагаю фложок - фикс,
  #   ; а можно - как дополнительное условие, алгоритм расчета фитнеса.
  
  set chromosome [item_get_mainsrc  $this_entity]
  

  #   ;;  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  #   ;; сформируем из хромосомы массив точек, а потом уже будем его обрабатывать
  #   ;;
  set points [list_make [expr {$::n_fix + $::n_ext}]]
  
  
  #   ;; запишем сначала фиксированные точки в этот рабочий массив
  #   ;; 
  #   (loop :for i :from 0 :below *n_fix*  :do 
  for {set i 0} {$i < $::n_fix} {incr i} {

    #     (setf (elt points i)  (elt *work_fix_points* i))
    lset points $i [lindex $::work_fix_points $i]
  }  
  
  #   ;; теперь запишем точки из генома
  #   ;; 

  for {set i 0} {$i < $::n_ext} {incr i} {
  
    lset points [expr {$i + $::n_fix}] [point_from_chromosome  $chromosome  $i]
  }
  
  #   ;; и теперь по этому 
  #   ;; 
  
  set fitness [calc_fitness_from_points  $points $::edges]
  
  return $fitness 
  
}
# ;#-------------------------------------------------------------------------------
# ;# Seed genetic data.

# ;# /* static */ boolean 
# ;# _test_seed (population *pop, entity *adam)
# ;#-------------------------------------------------------------------------------
proc point_init_by_random {&point} { 

  USE_REFS

  #   ; надо бы поточнее тут? по размерностям
  #   ; 
  
  #   (loop for d :from 0 :below *dim* :do
  for {set d 0} {$d < $::dim} {incr d} {
  
    #puts "d = $d"
    #  (setf (aref point d)  (random_double  (aref *max_val_arr* d)))
    #item_set_chromo_gen $point $d  [random_double [lindex $::max_val_arr $d]]

    lset point $d  [random_double [lindex $::max_val_arr $d]]
  }
  
}
# ;#-------------------------------------------------------------------------------
proc point_to_entity {point ent i} { 


  for {set d 0} {$d < $::dim} {incr d} {
  
    item_set_chromo_gen  $ent [expr {($::dim * $i) + $d}]  [lindex $point $d]
  }

}
# ;#-------------------------------------------------------------------------------
proc _test_seed {pop task adam} {  ;# task - описание заадчи


  #   ;; TODO: здесь нужно бы иметь индекс, т.е. связь с начальными значениями ??
  #   ;; 
  #   ;; нет, нужен механизм подключения "начальных точек"
  
  
  #   (declare (ignore pop))
  
  #   ;;  #   ((double *) adam->chromosome[0]) [0] = random_double (2.0);
  #   ;;  #   ((double *) adam->chromosome[0]) [1] = random_double (2.0);
  #   ;;  #   ((double *) adam->chromosome[0]) [2] = random_double (2.0);
  #   ;;  #   ((double *) adam->chromosome[0]) [3] = random_double (2.0);
  
  #   ;;  # пока будем делать с ОДНОЙ хромосомой 
  #   ;;  #
  #   ;;  # а надо ли несколько хромосом? т.е. например многомерная точка?
  #   ;;  # или адаптироваться должны процедуры скрещивания и т.д?
  
  
  #   (loop for i :from 0 :below *n_ext* :do
  for {set i 0} {$i < $::n_ext} {incr i} {
  
    point_init_by_random   ::work_point           ;# рабочая глобальная точка
    point_to_entity        $::work_point $adam $i 
  }
  
  
  return true

}
# ;# //------------------------------------------------------------------------------
# ;#-------------------------------------------------------------------------------
proc draw_entity {pop id name} {


  set entity  [pop_get_entity_      $pop $id]
  set chromo  [item_get_mainsrc  $entity]
  
  puts ""  
  puts [format "%s : fitness = %.6f "  $name [pop_get_entity_fitness_  $pop $id]]
  puts ""
  
  for {set i 0} {$i < $::n_ext} {incr i} {
  
    set p [point_from_chromosome $chromo $i]
    
    #puts "   "
    ext_point_print  $p $i
    puts "" 
  }
  
  puts ""
  
}
# ;#-------------------------------------------------------------------------------
proc draw_results {pop} {


  draw_entity   $pop 0 "FINAL 0"
  
  draw_entity   $pop 1 "FINAL 1"
  
  #   ;(draw_entity   pop 2 "FINAL 2")
  
}
# ;#-------------------------------------------------------------------------------
proc pntssolver_do {population_size max_generations             
                    {strategy      "GA_DE_STRATEGY_BEST"}       
                    {crossover     "GA_DE_CROSSOVER_BINOMIAL"}  
                    {num_perturbed 1}                           
                    } {
                  
  set crossover_factor    0.8 
  set weighting_factor    0.5 
  set weighting_factor2   0.5 
  
  #   pop 
  #   gen_hook_proc evaluate_proc initseed_proc 
  
  
  #   ;(random_seed 23091975)
  
  
  set  gen_hook_proc  "orov_generation_callback"
  #set  evaluate_proc  "_test_score"
  set  initseed_proc  "_test_seed"
  
  #   (setf pop (ga_genesis_double         
  #              population_size              ; const int              population_size     
  #              1                            ; const int              num_chromo         
  #              (* *n_ext* *dim*) ; 4                ; const int              len_chromo        
  #              gen_hook_proc     ; GAgeneration_hook      generation_hook    
  #              NUL                          ; GAiteration_hook       iteration_hook 
  #              NUL                          ; GAdata_destructor      data_destructor 
  #              NUL                          ; GAdata_ref_incrementor data_ref_incrementor
  #              evaluate_proc     ; GAevaluate             evaluate  
  #              initseed_proc     ; GAseed                 seed 
  #              NUL                          ; GAadapt                adapt 
  #              NUL                          ; GAselect_one           select_one 
  #              NUL                          ; GAselect_two           select_two 
  #              NUL                          ; GAmutate               mutate           
  #              NUL                          ; GAcrossover            crossover 
  #              NUL                          ; GAreplace              replace 
  #              NUL                          ; vpointer               User data
  #              ))
  
  
  set task [task_create   -fit_func "_test_score" -fit_tobest "MAX"]

  set pop [ga_genesis_main   \
	   $task \
           $population_size    \
           1		       \
           [expr $::n_ext * $::dim] \
           $gen_hook_proc      \
           NULL		       \
           NULL		       \
           NULL		       \
           $initseed_proc      \
           NULL	               \
           NULL	               \
           NULL	               \
           NULL                \
           NULL                \
           NULL		       \
           NULL		       \
          ]

  #   ;;    # (похоже инициация-seed еще не выполнялась ?) давай пока тут выполним:
  #   ;;    #
  ga_population_seed  $pop $task
  
  if $::__is_print { 
    pop_print $pop
  }
  
  #puts ""
  #puts "population_size = $population_size"

  #puts ""
  #puts "pntssolver_do ............ EXIT !!!!!!!!!!!"
  #puts ""

  #exit ;# !!!!!!!!!!!!!!1

  #   (ga_population_set_differentialevolution_parameters    
  #       pop 
  #       strategy crossover 
  #       num_perturbed weighting_factor weighting_factor2 
  #       crossover_factor)
  
  ga_population_set_differentialevolution_parameters $pop \
                                     $strategy $crossover   \
                                     $num_perturbed $weighting_factor $weighting_factor2 \
                                     $crossover_factor

  puts ""  
  
  #   ;;    # выполняем основной расчет (поиск минимума)
  #   ;;    #
  ga_differentialevolution  $pop $task	$max_generations 		
  
  
  if $::__is_print {
    puts "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
  }
  
  puts ""  
  pop_print $pop
  puts ""
  
  
  draw_results  $pop
  
  #   ;;  return
  
}
# ;# //------------------------------------------------------------------------------
# ;#-------------------------------------------------------------------------------
proc  add_to_end_of_list {l x} {

  #   (reverse (cons x (reverse l)))
  
  return [lappend $l $x]

}
# ;#-------------------------------------------------------------------------------
proc find_index_by_name  {name nodes_} {

  # ;; здесь nodes_ - простой массив индексов !?
  
  # (let (
  set ind  -1
  set len  [llength $nodes_]

  #   e
  #   )
  
  #   (loop :for i :from 0 :below len :do
  for {set i 0} {$i < $len} {incr i} {
  
    set e [lindex $nodes_ $i] ;# (elt nodes_ i))
    
   # puts "find_index_by_name: name= $name  e= $e"
    
    #  (when (eql e name) 
    if [string equal $e $name] {  
    
      set ind $i
      break ;# (return)
    }
  }
  
  if {$ind == -1} { 
    puts ""
    puts "ERROR !!  find_index_by_name:  name = $name"
    puts ""
    exit
  }
  
  return $ind
}
# ;#-------------------------------------------------------------------------------
proc find_radius_by_name {name nodes} {

  set obxvat 0.0

  #   ;(format t "find_radius_by_name: name = ~s  ind = ~s ~%" name ind)

  #   (loop :for n :across nodes :do
  foreach n $nodes {
  
    #     (when (eql (aref n 0)  name) 
    if {[string equal [lindex $n 0] $name]} {
    
      set obxvat [lindex $n 1]
      break ;#       (return)
    }
  }
  
  return [/ $obxvat 6.28]

  #   ;0.5  
  #   ;(aref (aref nodes ind) 1)
}
# ;#-------------------------------------------------------------------------------
proc edges_correct {nodes  &name_edges} {

  USE_REFS

  set size [llength  $name_edges]
  
  #   e  
  #   A_name   B_name
  #   A_radius B_radius
  #   L_true    L_true_correct
  
  
  #   (loop :for i :from 0 :below size :do
  for {set i 0} {$i < $size} {incr i} {
  
    set e [lindex $name_edges $i]
    
    set A_name  [lindex  $e 0]  
    set B_name  [lindex  $e 1] 
    
    puts "edges_correct: A_name = $A_name  B_name = $B_name"
    
    set A_radius  [find_radius_by_name  $A_name $nodes] 
    set B_radius  [find_radius_by_name  $B_name $nodes] 
    
    #     ;(exit)
    set L_TRUE  [lindex $e 2]
    
    #     ;;-------------------------------------------
    
    set L_TRUE_correct [+ $L_TRUE $A_radius $B_radius]
    
    #setf (aref e 2) L_TRUE_correct)
    lset e 2  $L_TRUE_correct
    
    #     (setf (elt name_edges i) e) ; запишем обратно
    lset name_edges $i  $e
  }
  
}
# ;#-------------------------------------------------------------------------------
proc  make_edges_from_namededges  {namededges nodes} {


  # (declare (special nodes))

  #puts "namededges = $namededges"


  set edges  {} ;# NIL)

  #   ie
  #   A_name B_name L_true A_indx B_indx


  #   (loop :for ne :across namededges :do
  foreach ne $namededges {
  
    set A_name  [lindex $ne 0]   
    set B_name  [lindex $ne 1]     
    set L_true  [lindex $ne 2] ;# здесь уже расстояние между центрами, корректное?
    
    set A_indx  [find_index_by_name  $A_name $nodes]
    set B_indx  [find_index_by_name  $B_name $nodes]
    
    set ie [list  $A_indx $B_indx $L_true] ;# ребро (индекс индекс длина)

    #     ;(setf ie  (A_indx B_indx L_true)) ; ребро (индекс индекс длина)
    
    puts "ne = $ne  ie = $ie" 
    
    #set edges [add_to_end_of_list  $edges $ie]
    lappend edges $ie
  }

  puts ""
  puts "make_edges_from_namededges ............................"
  puts ""
  puts "names = $namededges"
  puts "nodes = $nodes"
  puts "edges = $edges"
  puts "......................................................."
  puts "" 

  return $edges

}
# ;#-------------------------------------------------------------------------------
# ;#-------------------------------------------------------------------------------
proc loop_for_fix_nodes {defnodes &nodes_} {

  USE_REFS

  set n 0
  #   is_fix_flag
  
  #   (loop :for p :across defnodes :do  
  foreach p $defnodes {
  
    #puts "p = $p"

    set is_fix_flag [lindex $p 3] ;# (aref p 3))
  
    if {$is_fix_flag} {
  
      #puts ""
      #puts "!!!! is_fix_flag !!!!"
      #puts ""

      #       (vector-push-extend  (aref p 0)            nodes_) ; только имя туда
      #       (vector-push-extend  (aref p 4) *work_fix_points*) ; сами коориднаты точки
      
      #lappend nodes             [lindex $p 0]  ????
      lappend ::nodes           [lindex $p 0]
      lappend ::work_fix_points [lindex $p 4]

      incr n
    }
  
  }
  
  #puts ""
  #puts "::nodes = $::nodes"
  #puts "  nodes = $nodes"
  #puts ""

  return $n ;# return 

}
# ;#-------------------------------------------------------------------------------
proc loop_for_ext_nodes {defnodes  &nodes_} {

  USE_REFS

  set n 0
  #   is_fix_flag


  #   (loop :for p :across defnodes :do
  foreach p $defnodes {
  
    set is_fix_flag [lindex $p 3]
    
    if {! $is_fix_flag} { ;# не фиксированные точки
    
      #       (vector-push-extend  (aref p 0) nodes_)
      #lappend nodes_ [lindex $p 0]
      lappend ::nodes [lindex $p 0]
      
      #       ;(when _new
      #       ;  (point_init_by_random  *work_point*) 
      #       ;  (vector-push-extend    (copy-seq  *work_point*)  *seed_points*)
      #       ;  )
      
      incr n
    }
  }
  
  return $n ;# return 
}
# ;#-------------------------------------------------------------------------------
proc loop_for_all_nodes_simple {defnodes  &nodes_} {

  USE_REFS

  set n_fix  0
  set n_ext  0

  #   ; тут же надо именно последовательно формировать !!!
  #   ; т.е. на выходе сначала фиксированные точки, а не смешивать!!
  
  set n_fix  [loop_for_fix_nodes  $defnodes nodes_] ;# -> *nodes*
  set n_ext  [loop_for_ext_nodes  $defnodes nodes_] ;# -> *nodes*
   
  #   (values n_fix n_ext) 

  return [list $n_fix $n_ext]
}
# ;#-------------------------------------------------------------------------------
proc pntssolver_init_task {&defnodes  namededges dim max_val_arr} {

  USE_REFS

  set ::dim  $dim ;# это уже глобальная переменная  

  #   ;(nodes_  (make-array 0 :adjustable t :fill-pointer 0))
  #   ;p
  #   ;(n 0)  

  set ::max_val_arr  $max_val_arr 
  
  #   ;; делаем массивы и заносим туда поэлементно
  
  set ::nodes {}
  set ::work_fix_points {}

  set ::work_point [list_make $::dim 0]

  #   ; создаем по заданным шаблонам уже мат. узлы:
  #   ;
  #   ; чтобы вернуть несколько значений (если переменные уже есть):
  #   ; 

  foreach {::n_fix ::n_ext} [loop_for_all_nodes_simple  $defnodes ::nodes] {break}
  
  #   ;(format t "pntssolver_init_task: fix_nodes_ = ~S ~%" *nodes*)
  #   ;(format t "~%" )
  
  #   ; создаем ребра:
  
  set ::edges [make_edges_from_namededges  $namededges $::nodes] 
  
  return
}
# ;#-------------------------------------------------------------------------------
# ;#-------------------------------------------------------------------------------
proc make_test_1 {dim} {


  #   ;;  эти точки участвуют в расчетах фитнеса, но не в геноме
  #   ;; 
  
  # полагаем, что это точки с "обхватом"
  # имя / охват / фикс.координаты?

  set defnodes { 
    {x0   0.0 " x0" true {0  0}} 

    {p10  0.0 "p10" false} 
    {p20  0.0 "p20" false}
    {p30  0.0 "p30" false}
    {p40  0.0 "p40" false}
  }
  
  
  set namededges { 
  
    {x0  p10  1.0} 
    {p10 p20  1.0}
    {p20 p30  1.0}
  
    {p10 p40  3.0}
  }
  
    # ;                (3 4  1.0) ;  чем больше связей, тем точне, особенно в 2D
    # ;                (0 4  4.0)
    # ;                (0 3  3.0)
  
    # ;; ----------------------------
  #   ;; ----------------------------
  
  #   ;; сначала надо скорерктировать, если нужно (!), расстояния между 
  #   ;; центрами толстых точек:
  
  # ;  (print name_edges)
  # ;  (format t "~%")
  
  # ;  (edges_correct   defnodes  namededges) 
  # ;  (print name_edges)
  # ;  (format t "~%")
  
  # ;  (exit)
  #   ;---------------------------------------------------------------------
  
  #   ;(setf max_val_arr (make-array dim :initial-element 5.0))
  #   ;(pntssolver_init_task    all_points_local name_edges  dim 5.0)
  
  #(make-array ; массив максимальных значений
  #              dim :initial-element 5.0))
  #
  set arrmax [list_make $dim 5.0] 

  pntssolver_init_task    defnodes $namededges $dim $arrmax                    

}
# ;#-------------------------------------------------------------------------------
proc make_real_orovo {} {

  # ;(setf *dim*   2) ; это уже глобальная переменная
  
  
  #   ;;  эти точки участвуют в расчетах фитнеса, но не в геноме
  #   ;; 
  
  
  # { pX   0.00    ""  true {13.50  44.78}} ;; посчитал через уравнения
  # { pZ   0.00    ""  true {30 30.7}} ;  { pZ pY 9.3}
  # { p4_  0.00    ""  true {30 21.3}} ;  { pZ  p4_  9.4}
  # { pP   0.00    ""  true {30 20.3}} ;  prirezka (20.3 by doc)


  set defnodes { 
  
    { pL   0.00    ""  true { 0  0}}
    { pR   0.00    ""  true {30  0}}
  
    { pX   0.00    ""  true {13.50  44.78}}
    { pY   0.00    ""  true {30 40}}
  
    { pZ   0.00    ""  true {30 30.7}} 
  
    { p4_  0.00    ""  true {30 21.3}}
    { pP   0.00    ""  true {30 20.3}}
  
  
    { p1   1.50    ""  true {16.4  37}}
    { p2   0.98   "B"  true {16.35 23.65}}
    { p2_  0.95   "B"  true {16.35 23.35}}
    { p3   0.98   "B"  true {22.4  22.1}}
    { p4   1.20   "B"  true {28.6  21.8}}
    { p5   0.60   "B"  true {27.3  31.1}}
    { p6   0.60   "S"  true {31    32.3}}
    { p7   0.33   "B"  true {30    35.7}}
    { p8   0.52   "B"  true {24.45 29.2}}
    { p9   0.44   "S"  true {21.3  27.15}}
    { p10  0.49   "S"  true {19.2  27.4}}
    { p11  0.47   "B"  true {13.3  29.3}}
    { p12  0.45   "B"  true {10    32.15}}
    { p13  0.52   "S"  true {14.6  34.3}}
    { p14  0.62   "B"  true {12    11.9}}
    { p15  0.85   "B"  true {13.25 11.9}}
    { p16  0.47   "S"  true {20.2  14.55}}
    { p17  1.19   "B"  true {27.1  13.3}}
    { p18  0.58   "O"  true {8.7    9.3}}
    { p19  0.33   "O"  true {8.6   15.6}}
    { p20  0.48   "S"  true {6.25  10.4}}
    
  
    { p21  0.45   "S"  false}
    { p22  0.17   "S"  true {6.1  5.6}}
    { p23  0.45   "O"  true {7    4.6}}
    { p24  0.26   "S"  true {2    0.45}}
    { p25  0.41   "S"  true {4.4  1.3}}
    
    { p26  0.73   "B"  true {6    0.2}}
    { p26_ 0.19   "O"  false}
    
    { p27  0.29   "B"  false}
    { p28  0.31   "B"  false}
    { p29  0.49   "B"  false}
    { p30  0.63   "B"  false}
    { p31  0.69   "B"  true {11.4   3 }}
    { p32  0.40   "B"  false}
    { p33  0.35   "B"  false}
    { p34  0.35   "B"  false}
    { p35  0.59   "B"  true {15.7  3.5}}
    { p36  0.17   "O"  false}
    { p37  0.76   "O"  false}
    { p38  0.40   "B"  true {19.75 3.35}}
    { p39  0.46   "B"  true {20.1  4.2 }}
    { p40  0.37   "O"  false}
    { p41  0.33   "O"  false}
    { p42  0.53   "O"  true {22    5.2 }}
    { p43  0.47   "O"  true {21.75 7   }}
    { p45  0.23   "O"  false}
    { p46  0.20   "O"  false}
    { p47  0.20   "O"  true {24.2  5.5}}
    { p48  0.25   "O"  true {25.25 2.5}}
    { p49  0.15   "O"  false}
    
    
    { pA   0.00    ""  true {14.05 13.75}} 
    { pB   0.00    ""  false} 
    { pC   0.00    ""  true {19.4  12.1}} 
    { pD   0.00    ""  true {14.35 11.3}}  
    
  }
  
  
  #  { pB_  0.00    ""  false } 
  #  { pC_  0.00    ""  false } 
  
  #  { pC_ p17  2.8} 
  #  { pP  pB_  4.5} 
  
  set namededges {
  
    { p1  p2  13.4} 
    { p1  pX   9.0} 
    { p1  pY  13.8} 
    
    { p2  p2_  0.3}               
    { p2  p10  4.3}               
    { p2  p11  6.0}
    { p2  p12 10.3}
    { p2  p13 10.4}
    
    { p3  p2   6.0}
    { p3  p4   6.1}
    { p3  p8   7.0} 
    { p3  p9   5.0} 
    { p3  p16  7.8} 
    
    { p4  p5   9.0}
    { p4  p8   8.1}
    { p4  p4_  1.3}
    
    { p5  p1  12.62}
    { p5  p6   3.1}
    { p5  p7   5.4}
    { p5  p8   3.9}
    { p5  pZ   2.1}
    
    { p6  p7   4.0}
    { p7  pY   4.3}
    { p8  p9   3.5}
    { p9  p13  9.5}
    
    { p10 p9   2.1}
    { p10 p11  5.76}
    
    { p11 p12  4.38}
    { p11 p13  5.0}
    
    { p12 p13  5.15}
    { p13 p1   3.45}
    
  
    { p14 p15  0.87} 
    { p14 p16  7.13} 
    { p14 p18  4.14} 
    
    { p16 pB   4.14} 
    
    { pA  p2_  9.15} 
    { pA  p14  2.55} 
    { pA  p15  1.7} 
    
    { pA  pB   5.0} 
    { pC  pD   5.0} 
    { pA  pD   2.5} 
    { pB  pC   2.5} 
    
    { pA  p18  6.93} 
    { pA  p19  5.86} 
    
    { pB  p2_  8.7} 
    { pB  p3   7.9} 
    { pC  p16  2.5} 
    { pC  p17  7.87} 
    { pD  p15  1.3} 
    
    { p18 pD   5.98} 
    { p18 p19  6.27} 
    { p18 p20  2.60} 
    
    { p19 p14  5.00} 
    { p19 p16 11.58} 
    { p19 pB  10.47} 
    { p19 p20  5.37} 
    
    
    { pR  p48  5.43} 
    { pR  p40  8.53} 
    { pR  p41  8.00} 
    { pR  p37 11.01} 
    { pR  p38 10.98} 
    { pR  p39 10.76} 
    { pR  p42  9.52} 
    { pR  p43 10.90} 
    { pR  p47  8.05} 
    { pR  p45  7.15} 
    { pR  p38 10.96} 
    { pR  p35 14.65} 
    { pR  p31 18.66} 
    { pR  p49 13.78} 
    
    { p40 p48  3.90} 
    { p40 p46  4.00} 
    { p40 p45  3.44} 
    { p40 p41  1.42} 
    { p40 p42  4.05} 
    { p40 p43  5.80} 
    { p40 p39  3.28} 
    { p40 p38  2.97} 
    { p40 p35  6.14} 
    { p40 p36  4.08} 
    { p40 p37  2.62} 
    { p40 p31 10.05} 
    { p40 p33  8.95} 
    { p40 p34  9.8} 
    { p40 pC  11.2} 
    { p40 pD  12.5} 
    { p40 p23 15.0} 
    
    
    { p35 p14  9.48} 
    { p35 p15  9.1} 
    { p35 pC   9.37} 
    { p35 pD   8.12} 
    { p35 p18  9.3} 
    { p35 p21 11.86} 
    { p35 p34  3.6} 
    { p35 p31  4.00} 
    { p35 p33  3.28} 
    { p35 p32  4.18} 
    { p35 p27  6.45} 
    { p35 p26  9.9} 
    { p35 p29  5.11} 
    { p35 p28  6.24} 
    { p35 p43  6.8} 
    { p35 p42  6.4} 
    { p35 p39  4.26} 
    { p35 p38  3.67} 
    { p35 p41  6.6} 
    { p35 p37  4.3} 
    { p35 p36  3.08} 
    { p35 p19 14.39} 
    
    
    { p23 p22  1.17} 
    { p23 p25  3.95} 
    { p23 p26  4.33} 
    { p23 p24  6.24} 
    { p23 p30  4.07} 
    { p23 p31  4.83} 
    { p23 p34  5.20} 
    { p23 p35  9.05} 
    { p23 pL   8.18} 
    { p23 p18  4.74} 
    { p23 p21  4.86} 
    { p23 p20  5.86} 
    { p23 p14  8.73} 
    { p23 p15  9.41} 
    { p23 pD   9.84} 
    
    
    { pL  p24  2.03} 
    { pL  p25  4.50} 
    { pL  p26  5.98} 
    { pL  p26_ 6.86} 
    
  }
    
  #    ;; ---------------------------------------------
  
  edges_correct   $defnodes namededges 
  
  pntssolver_init_task   defnodes $namededges  2  {30 40}
  
}
# ------------------------------------------------------------------------------
# proc sqrt {v} {

#   return [expr $v]
# }
# ------------------------------------------------------------------------------
proc calc_len_points {p1 p2} {
  

  set x1 [lindex $p1 0]    
  set y1 [lindex $p1 1]  
  
  set x2 [lindex $p2 0]    
  set y2 [lindex $p2 1] 
  
  set lx [- $x2 $x1] 
  set ly [- $y2 $y1] 
  
  #set ret [sqrt [+ [* $lx $lx] [* $ly $ly]]]

  set ret [expr {sqrt (($lx * $lx) + ($ly * $ly))}]
  
  return $ret
}
# ------------------------------------------------------------------------------
proc new_prirezka_test {} {
  
  set p1   {94 58}    ;# (97594 132058)
  set p2   {70 80}    ;# (97570 132080)
  set p3   {86 54}    ;# (97586 132054)
  set p4   {92 57}    ;# (97592 132057)
  
  set n1   {83 68}    ;# (97583 132068)
  set n2   {79 90}    ;# (97579 132090)
  set n3   {60 88}    ;# (97560 132088)
  set n4   {47 80}    ;# (97547 132080)
  set n5   {53 70}    ;# (97553 132070)
  
  set a  [calc_len_points  $p3 $n1]
  set b  [calc_len_points  $n1 $p2]
  set c  [calc_len_points  $p2 $p3]
  
  #   (x  (/ (+ (- (* a a) (* b b)) (* c c)) (* 2 c)))
  #   (y  (sqrt (- (* a a) (* x x))))

  set x  [expr {((($a * $a) - ($b * $b)) + ($c * $c)) /  (2 * $c)}]
  set y  [expr {sqrt (($a * $a) - ($x * $x))}]

  
  #   (declare (ignore p1 p4 n2 n3 n4))
  
  puts ""
  puts "p2 __ p3 =  [calc_len_points  $p2 $p3]"  ;# 30.528675f0 
  puts "p2 __ n5 =  [calc_len_points  $p2 $n5]"   
  puts ""

  puts "a= $a b= $b c= $c"  
  puts "x= $x"  
  puts "y= $y" 
 
  puts ""
  
}
# ;#-------------------------------------------------------------------------------
# ;proc parse_opts {&population_size &max_generations  \
# ;                def_population_size def_max_generations} {

# ;#-------------------------------------------------------------------------------
# (defun parse_opts_int_int_int (index  int1 int2 int3)

# (let* (
#   ;(index  0)

#   (argus  (get_argus))
#   (argc   (list-length argus))
#   )

#   ;(format t "argc = ~s ~%" argc)
#   (setf __is_print false)
  
#   (set int1   (parse-integer (nth index argus))) (incf index)

#   ;(unless  (= argc 0) ;; если есть параметры
#   (set int2 (parse-integer (nth index argus))) (incf index) ; пишем в "символ"
#   (set int3 (parse-integer (nth index argus))) (incf index)
#   ;)
  

#   ;(when (= argc 3)
#   ;    (set r_dim             (parse-integer (nth 2 argus))) 
#   ;  )

#   (when (= argc (+ index 1))   ; cl v_pnts.cl  01  4 1  @
#     (setf __is_print true)
#     )

# ))
# ;#-------------------------------------------------------------------------------
proc parse_opts_int_int {index  &int1 &int2} {

  USE_REFS

  global argc argv argv0

  #   (argus  (get_argus))
  #   (argc   (list-length argus))
  
  set ::__is_print false
  
  #   (set int1 (parse-integer (nth index argus))) (incf index)
  #   (set int2 (parse-integer (nth index argus))) (incf index) ; пишем в "символ"
  
  set int1 [lindex $argv $index]  ; incr index
  set int2 [lindex $argv $index]  ; incr index
  
  #   (when (= argc (+ index 1))   ; ...... @

  if {$argc == [+ $index 1]} {

    set ::__is_print true
    set ::is_print   true
  }
  
}
# ;# //------------------------------------------------------------------------------
# ;#-------------------------------------------------------------------------------
proc make_test_orovo {} {

  # ; MDS - Multidimension Scaling
  
  set defnodes   {} ;# (make-array  0 :adjustable t :fill-pointer 0))
  set namededges {} ;# (make-array  0 :adjustable t :fill-pointer 0))
  
  #   ;; ----------------------------
  #   ;; TODO: задавать функциями с формированием имен и координат узлов!
  
        
  lappend defnodes {p_00_00    0.0    ""  true {0   0}} 
  lappend defnodes {p_30_00    0.0    ""  true {30  0}} 
  lappend defnodes {p_00_40    0.0    ""  true {0  40}} 
  lappend defnodes {p_30_40    0.0    ""  true {30 40}}  
  
  lappend defnodes {p_15_00    0.0    ""  false}
  lappend defnodes {p_15_40    0.0    ""  false}
  
  #   ;; ----------------------------
  #   ;; TODO: задавать функциями с формированием имен и длин ребер!
  
  lappend namededges { p_00_00  p_15_00  15 } 
  lappend namededges { p_15_00  p_30_00  15 }
  lappend namededges { p_00_40  p_15_40  15 }
  lappend namededges { p_15_40  p_30_40  15 }
  
  #   ;; TODO: сделать отдельную функцию, по индексам координат формировать
  #   ;;       имена и расстояния;
  #   ;; 
  
  #   ;; ----------------------------
    
  pntssolver_init_task  defnodes  $namededges  2  {30 40}
  
}
# ;# //------------------------------------------------------------------------------
proc  orov_main {} {
  
  set num_test          1
  set population_size  40 
  set max_generations  50

  # --------------------------------------------------

  global argc argv

  #set argv [lrange $argv 1 end]

  set num_test        [dict_parse $argv "-test"   1]
  set population_size [dict_parse $argv "-lpop"  40]
  set max_generations [dict_parse $argv "-nums"  50]
  set ::is_print      [dict_parse $argv "-print"  0]


  puts ""

  set ::__is_print $::is_print  

  puts ""
  puts "num_test        = $num_test"
  puts "population_size = $population_size" ;# lpop
  puts "max_generations = $max_generations" ;# nums
  puts ""

  comm_random_seed 23091975 ;# сюда вынес, чтобы отдельно формировать случайные точки
  

  #   ;;--------------------------------------------------
  switch -glob $num_test  {
  
    "1"  {make_test_1  1}
    "2"  {make_test_1  2}
    
    "20" {make_test_orovo}
    
    #     ;;------------------------------------------------
    
    "22" {
    
      make_real_orovo

      set ::is_print    1
      #set  ::__is_print true

      puts ""
      puts "population_size = $population_size"
      puts ""

      pntssolver_do  $population_size $max_generations \
        "GA_DE_STRATEGY_RANDTOBEST" \
        "GA_DE_CROSSOVER_BINOMIAL"  \
        1  ;# num_perturbed

      exit
    }

    "23" {
    
      new_prirezka_test
      exit
    }
    #default: {
    #  puts "ERROR num_test !!"
    #  exit
    #}
    
  }
  #   ;;--------------------------------------------------
  
  
  pntssolver_do   $population_size $max_generations
  
}
# ;-------------------------------------------------------------------------------

#MAIN
#orov_main

# ;-------------------------------------------------------------------------------

# g_orov.jm  1  4 1 
# g_orov.jm  1  40 40 
# g_orov.jm  2  4 1 
# g_orov.jm 20  100 30 
# g_orov.jm 23 

# g_orov.jm 22 ERROR !!!!!!!!!!!!!!!!!!!!!!!!1 

# ;-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#source "p_all5.jm"
#-------------------------------------------------------------------------------


# -*-   mode: tcl  ; coding: koi8   -*- ----------------------------------------

#!/bin/sh
# \
exec jimsh "$0" ${1+"$@"}

#-------------------------------------------------------------------------------

#source "p_all5.tl"

#-------------------------------------------------------------------------------
# Josef Knecht @ Copyright 
#-------------------------------------------------------------------------------

#set COMPOT "./COMPOT"
# set auto_path [linsert $auto_path 0 $COMPOT]
# set auto_path [linsert $auto_path 0 $COMPOT/COM/common] ;# for JIM

#------------------------------------------

set auto_path [linsert $auto_path 0 "COMMON"]
package require compot::common 

# package require tcltest

#------------------------------------------

# expected integer but got ""
#     while executing
# "incr [VGET $p size] 1"

#------------------------------------------

# source "b-com0.tl"
# source "b-com1.tl"
# source "f-rand.tl"


source "p-corE.tl"

#source "ga_de.tl"

#-------------------------------------------------------------------------------
# //  Score solution (Normalised RMSD deviation from values
# //  of '5' for all parameters).
# //------------------------------------------------------------------------------
# static boolean 
# all5s_score (population *pop, entity *entity)
# //------------------------------------------------------------------------------
proc all5s_score {item task}  {

  set len [item_get_chromo_len $item] 

  set fitness 0
  
  #   // Loop over alleles in chromosome
  #   // 
  
  for {set k 0} {$k < $len} {incr k} \
  {

    set   allele [item_get_chromo_gen $item  $k]
    incr fitness [expr {(5 - $allele) * (5 - $allele)}]
  }
  
  set fitness [expr {sqrt ($fitness)}]
  #
  # т.е. чем меньше тем лучше, стремясь к нулю !
  
  #   // Normalize fitness so larger positive values are better
  #   //
  set fitness [expr  {1.0 / (1.0 + $fitness)}]

  # а теперь чем больше, тем лучше стремясь 0 -> 1

  item_set_fitn  $item $fitness 

  return $fitness
}
# //------------------------------------------------------------------------------
# // Entity initialisation.

# static boolean 
# all5s_seed (population *pop, entity *entity)

# //------------------------------------------------------------------------------
proc all5s_seed {pop task entity} \
{
  # int  point; /* Index of allele to seed */
  
  set maxint 11
  #set maxint 19

  for {set point 0} {$point < [GET $pop lsrc]} {incr point} \
  {
    item_set_chromo_gen $entity  $point [comm_random_int $maxint]

    #$entity configure -ch_form " %02d"
    # БУДЕМ ЗАДАВАТЬ ЭТОТ параметр при создании, т.е. ga_entity_setup
  }
  
  return true
}
# //------------------------------------------------------------------------------
# // Mutation of a single parameter with wrapping 0<->10.
# //------------------------------------------------------------------------------
# static void 
# all5s_mutate (population *pop, entity *father, entity *son)

# //------------------------------------------------------------------------------
proc all5s_mutate {pop task  father son}  {

  #   int   i;                             /* Loop variable over all chromosomes */
  #   int   point;                         /* Index of allele to mutate          */
  #   int   dir = random_boolean()?-1:1;   /* The direction of drift.            */
  
  if {[comm_random_boolean]} {
    set dir -1
  } else {
    set dir  1
  }

  #puts -nonewline stderr "  all5s_mutate : dir = $dir"

  #   // Sanity check
  #   // 
  #   if (!father || !son)
  #     die ("Null pointer to entity structure passed");
  
  set lsrc [GET $pop lsrc]

  #   // Select mutation locus
  #   // 
  set point [comm_random_int $lsrc]
  
  #   // Copy genome from father
  #   // 
  #   for (i=0; i<pop->lsrc; i++)
  #     ((int *)son->CH)[i] = ((int *)father->CH)[i];
  
  #set son_CH [$father get_chromosome]
  set son_CH [item_get_mainsrc $father]

  #   //
  #   // Mutate by tweaking a single allele.
  #   //
  #   ((int *)son->CH)[point] += dir;

  set  gen [lindex $son_CH $point]
  incr gen $dir
  
  #puts stderr "  point = $point  gen = $gen"

  #   if      (((int *) son->CH)[point] > 10)
  #     ((int *) son->CH)[point] = 0;
  #
  #   else if (((int *) son->CH)[point] < 0)
  #     ((int *) son->CH)[point] = 10;

  if       {$gen > 10} {
    set gen 0
  } elseif {$gen <  0} {
    set gen 10
  }

  lset son_CH $point $gen ;# смутировали хромосому-список

  item_set_mainsrc $son $son_CH ;# и записали ее в сына

  return
}
# //------------------------------------------------------------------------------
# //------------------------------------------------------------------------------
# //  all5s.c

# //		This searches for a set of values all equalling '5', 
# //		with allowed bounds of 0 to 10 inclusive as imposed
# //		by custom chromosomes.

# //		It is an example to demonstrate how to impose bounds
# //		on the chromosome values by using custom seed and
# //		mutation operator functions.  Compare this to the
# //		accompanying all5s_allele_ranges.c

# //------------------------------------------------------------------------------
proc all5_1_main {} \
{

  #   population  *pop = NULL;	      /* Population of solutions.               */
  #   char        *beststring = NULL; /* Human readable form of best solution.  */
  #   size_t       beststrlen = 0;    /* Length of beststring.                  */
  
  
  set len_chromo      ""
  set population_size ""
  set max_generations ""
  
  
  parse_opts_3  len_chromo population_size max_generations 100 200 250
  
  comm_random_seed  20092004
  
  #   pop = ga_genesis_integer (
  #      population_size,	/* const int              population_size      */
  #      1,		        /* const int              num_chromo           */
  #      len_chromo,		/* const int              len_chromo           */
  #      NULL,			/* GAgeneration_hook      generation_hook      */
  #      NULL,			/* GAiteration_hook       iteration_hook       */
  #      NULL,			/* GAdata_destructor      data_destructor      */
  #      NULL,			/* GAdata_ref_incrementor data_ref_incrementor */
  #      all5s_score,		/* GAevaluate             evaluate             */
  #      all5s_seed,		/* GAseed                 seed                 */
  #      NULL,			/* GAadapt                adapt                */
  #      ga_select_one_sus,	/* GAselect_one           select_one           */
  #      ga_select_two_sus,	/* GAselect_two           select_two           */
  #      all5s_mutate,		/* GAmutate               mutate               */
  #      ga_crossover_integer_singlepoints, /* GAcrossover    crossover        */
  #      NULL,			/* GAreplace	  	  replace              */
  #      NULL			/* vpointer		  User data            */
  #      );
  
  set task [task_create  -fit_func "all5s_score" -fit_tobest "MAX" -fit_target 1]

  set pop [ga_genesis_main   \
	     $task \
             $population_size    \
             1		        \
             $len_chromo	        \
             NULL               \
             NULL               \
             NULL               \
             NULL               \
             all5s_seed         \
             NULL               \
             ga_select_one_bestof2 \
             ga_select_two_bestof2 \
             all5s_mutate       \
             ga_crossover_integer_singlepoints  \
             NULL               \
             NULL               \
          ]
  

  SET $pop "ch_form" " %02d" ;# 

  #   ga_population_set_parameters (
  #      pop,			/* population                 *pop */
  #      GA_SCHEME_DARWIN,	/* const ga_scheme_type     scheme */
  #      GA_ELITISM_PARENTS_SURVIVE,/* const ga_elitism_type   elitism */
  #      0.8,			/* double		 crossover */
  #      0.05,			/* double		  mutation */
  #      0.0              	/* double		 migration */
  #      );
  
  #puts stderr ".... 3"

  ga_population_set_parameters                            \
                               $pop	                  \
                               GA_SCHEME_DARWIN	          \
                               GA_ELITISM_PARENTS_SURVIVE \
                               0.8			  \
                               0.05			  \
                               0.0      	          


  if {$::is_print} {
    # пока здесь остановимся, осмотримся и распечатаемся:
    # (похоже инициация-seed еще не выполнялась ?) давай пока тут выполним:
    #
    ga_population_seed $pop $task 
    #
    #$pop print ;# Error: invalid command name "::G_DICT_33"
  }


  ga_evolution  $task $pop $max_generations   

  #$pop print

  #   // Display final solution
  #   // 
  puts "The final solution was:"
  #   beststring = ga_chromosome_integer_to_string (pop, ga_get_entity_from_rank(pop,0), 
  #                                                 beststring, &beststrlen);

  set best_entity [ga_get_entity_from_rank $pop 0]
  set beststring [item_get_mainsrc $best_entity]

  puts $beststring

  puts [format "With score = %f" [item_get_fitn $best_entity]]
  
  return 1
}
# //------------------------------------------------------------------------------
# // 
# //  all5s_allele_ranges.c
# //
# //		This searches for a set of values all equalling '5', 
# //		with allowed bounds of 0 to 10 inclusive, using
# //		built-in features only.
# //
# //		This example demonstrates the
# //		ga_population_set_allele_min_integer() and
# //		ga_population_set_allele_max_integer() functions.
# // 
#-------------------------------------------------------------------------------


# //------------------------------------------------------------------------------
proc all5_2_main {} \
{

  #set mut [MUTATE new]

  #SET $mut "param" 1
  #puts "mutate param = [GET $mut param]"

  #--------------------------

  set len_chromo      ""
  set population_size ""
  set max_generations ""
  
  parse_opts_3  len_chromo population_size max_generations 100 200 250

  comm_random_seed  20092004

  set task [task_create  -fit_func "all5s_score" -fit_tobest "MAX" -fit_target 1]

  set pop [ga_genesis_main   \
	     $task \
             $population_size   \
             1		        \
             $len_chromo	\
             NULL               \
             NULL               \
             NULL               \
             NULL               \
             ga_seed_integer_random \
             NULL               \
             ga_select_one_bestof2	\
             ga_select_two_bestof2	\
             ga_mutate_integer_singlepoint_drift \
             ga_crossover_integer_singlepoints   \
             NULL               \
             NULL               \
          ]

  SET $pop  allele_min_integer 0
  SET $pop  allele_max_integer 10

  SET $pop "ch_form" " %02d" ;# 

  set crossover 0.8
  set mutation  0.05
  set migration 0.0

  ga_population_set_parameters                            \
                               $pop	                  \
                               GA_SCHEME_DARWIN	          \
                               GA_ELITISM_PARENTS_SURVIVE \
                               $crossover $mutation $migration  	          
  
  ga_evolution  $task $pop $max_generations   

  #$pop print

  puts "The final solution was:"

  set best_entity [ga_get_entity_from_rank $pop 0]
  set beststring [item_get_mainsrc $best_entity]

  puts $beststring

  puts [format "With score = %f" [item_get_fitn $best_entity]]
    
  return 1
}
# //******************************************************************************
# //------------------------------------------------------------------------------
proc all5_main {}  {

  #set ::NEWEST 1 ;# !!!!!!!!!!!!!!!!!!! OK !!!!

  global argc argv argv0

  puts ""
  
  #   if (argc < 2 ) 
  #     exit (EXIT_SUCCESS);
  
  set mode [lindex $argv 0] ;# имя выч. задачи
  
  #   if      (! strcmp (mode, "_1")) _1_main (argc, argv);
  #   else if (! strcmp (mode, "_2")) _2_main (argc, argv); 
  #   else {
  #     printf ("\n");
  #     printf ("ERROR mode = %s \n", mode);
  #     printf ("\n");
  #   }
  
  if     {$mode == "_1"}     { all5_1_main } \
  elseif {$mode == "_2"}     { all5_2_main } \
  elseif {$mode == "_NEWEST"} { 
    set ::NEWEST 1
    all5_1_main 
  } \
  \
  else {
    puts ""
    puts "ERROR mode = $mode"
    puts ""
  }

  puts ""
  
}
# //-----------------------------------------------------------------------------

# g_all5.tl _1       11 10 10
# g_all5.tl _NEWEST  11 10 10

# //-----------------------------------------------------------------------------

#all5_main

# //-----------------------------------------------------------------------------
# //------------------------------------------------------------------------------
# ******************************************************************************


#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------



  global argc argv argv0
  global argv

  if  {$argc == 0} { 
    puts "argc == 0"
    exit
  }
  
  set prog [lindex $argv 0] ;# 

  set argv [lrange $argv 1 end]

  #puts "argv = $argv"

  if       {$prog == "test"}   {
    #set ret [exec p-test.jm {*}$argv] 
    #puts "$ret"
    #source "p-test.jm"
    test_main
  } elseif {$prog == "stru"}   {
    #set ret [exec p_stru.tl {*}$argv] 
    #puts "$ret"
    stru_main
  } elseif {$prog == "ping"}   {
    ping_main
  } elseif {$prog == "orov"}   {
    orov_main
  } elseif {$prog == "all5"}   {
    all5_main
  } else {
    puts ""
    puts "ERROR prog = $prog"
    puts ""
  }

  #puts "ret = $ret"
  #puts "$ret"

#-------------------------------------------------------------------------------
#
# p-test.jm      de_full -lpop 9 -nums 1
# p_xxxx.jm test de_full -lpop 9 -nums 1
#
#-------------------------------------------------------------------------------
