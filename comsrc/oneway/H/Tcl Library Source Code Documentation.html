<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<base href="https://core.tcl-lang.org/tcllib/doc/trunk/embedded/md/tcllib/files/modules/sha1/sha256.md">
<meta http-equiv="Content-Security-Policy" content="default-src 'self' data:; script-src 'self' 'nonce-1e128427487a5e2855ebadb59d1ffd804563f7c7965ed1ec'; style-src 'self' 'unsafe-inline'; img-src * data:">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tcl Library Source Code: Documentation</title>
<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/tcllib/timeline.rss">
<link rel="stylesheet" href="/tcllib/style.css?id=54d669ef" type="text/css">
</head>
<body class="doc rpage-doc cpage-doc">
<div class="header">
<div class="title"><h1>Tcl Library Source Code</h1>Documentation</div>
<div class="status"><a href="/tcllib/login">Login</a>
</div>
</div>
<div class="mainmenu">
<a href="//core.tcl.tk">Core <img src="//core.tcl.tk/images/ext.png"></a><a href="/tcllib/doc/trunk/embedded/index.md">Home</a>
<a href="/tcllib/timeline?y=e&v=0">Blog</a>
<a href="/tcllib/doc/trunk/embedded/md/toc.md">Docs</a>
<a href="/tcllib/wiki?name=Downloads">Downloads</a>
<a href="/tcllib/ticket">Tickets</a>
<a href="/tcllib/timeline">Timeline</a>
<a href="/tcllib/dir?ci=tip">Files</a>
<a href="/tcllib/brlist">Branches</a>
<a href="/tcllib/taglist">Tags</a>
<a href="/tcllib/wiki">Wiki</a>
</div>
<div class="content"><span id="debugMsg"></span>
<div class="markdown">
<p><hr> [ <a href="../../../../toc.md">Main Table Of Contents</a> &#124; <a href="../../../toc.md">Table Of Contents</a> &#124; <a href="../../../../index.md">Keyword Index</a> &#124; <a href="../../../../toc0.md">Categories</a> &#124; <a href="../../../../toc1.md">Modules</a> &#124; <a href="../../../../toc2.md">Applications</a> ] <hr></p>
<h1>NAME</h1>
<p>sha256 - SHA256 Message-Digest Algorithm</p>
<h1><a name="toc"></a>Table Of Contents</h1>
<ul>
<li><p><a href="#toc">Table Of Contents</a></p></li>
<li><p><a href="#synopsis">Synopsis</a></p></li>
<li><p><a href="#section1">Description</a></p></li>
<li><p><a href="#section2">COMMANDS</a></p></li>
<li><p><a href="#section3">PROGRAMMING INTERFACE</a></p></li>
<li><p><a href="#section4">EXAMPLES</a></p></li>
<li><p><a href="#section5">REFERENCES</a></p></li>
<li><p><a href="#section6">Bugs, Ideas, Feedback</a></p></li>
<li><p><a href="#seealso">See Also</a></p></li>
<li><p><a href="#keywords">Keywords</a></p></li>
<li><p><a href="#category">Category</a></p></li>
<li><p><a href="#copyright">Copyright</a></p></li>
</ul>
<h1><a name="synopsis"></a>SYNOPSIS</h1>
<p>package require Tcl 8.5 9 <br>
package require sha256 ?1.0.4? </p>
<p><a href="#1"><strong>::sha2::sha256</strong> ?<strong>-hex&#124;-bin</strong>? [ <strong>-channel channel</strong> &#124; <strong>-file filename</strong> &#124; ?<strong>--</strong>? <em>string</em> ]</a> <br>
<a href="#2"><strong>::sha2::sha224</strong> ?<strong>-hex&#124;-bin</strong>? [ <strong>-channel channel</strong> &#124; <strong>-file filename</strong> &#124; ?<strong>--</strong>? <em>string</em> ]</a> <br>
<a href="#3"><strong>::sha2::hmac</strong> <em>key</em> <em>string</em></a> <br>
<a href="#4"><strong>::sha2::hmac</strong> ?<strong>-hex&#124;-bin</strong>? <strong>-key key</strong> [ <strong>-channel channel</strong> &#124; <strong>-file filename</strong> &#124; ?<strong>--</strong>? <em>string</em> ]</a> <br>
<a href="#5"><strong>::sha2::SHA256Init</strong></a> <br>
<a href="#6"><strong>::sha2::SHA224Init</strong></a> <br>
<a href="#7"><strong>::sha2::SHA256Update</strong> <em>token</em> <em>data</em></a> <br>
<a href="#8"><strong>::sha2::SHA256Final</strong> <em>token</em></a> <br>
<a href="#9"><strong>::sha2::SHA224Final</strong> <em>token</em></a> <br>
<a href="#10"><strong>::sha2::HMACInit</strong> <em>key</em></a> <br>
<a href="#11"><strong>::sha2::HMACUpdate</strong> <em>token</em> <em>data</em></a> <br>
<a href="#12"><strong>::sha2::HMACFinal</strong> <em>token</em></a> </p>
<h1><a name="description"></a>DESCRIPTION</h1>
<p>This package provides an implementation in Tcl of the SHA256 and SHA224
message-digest algorithms as specified by FIPS PUB 180-1 (1). These algorithms
take a message and generates a 256-bit (224-bit) digest from the input. The SHA2
algorithms are related to the SHA1 algorithm.</p>
<p>This package also includes support for creating keyed message-digests using the
HMAC algorithm from RFC 2104 (3) with SHA256 as the message-digest.</p>
<h1><a name="section2"></a>COMMANDS</h1>
<ul>
<li><p><a name="1"></a><strong>::sha2::sha256</strong> ?<strong>-hex&#124;-bin</strong>? [ <strong>-channel channel</strong> &#124; <strong>-file filename</strong> &#124; ?<strong>--</strong>? <em>string</em> ]</p>
<p>The command takes a message and returns the SHA256 digest of this message as
a hexadecimal string. You may request the result as binary data by giving
<em>-bin</em>.</p>
<p>The data to be hashed can be specified either as a string argument to the
<strong>sha256</strong> command, or as a filename or a pre-opened channel. If the
<em>-filename</em> argument is given then the file is opened, the data read and
hashed and the file is closed. If the <em>-channel</em> argument is given then
data is read from the channel until the end of file. The channel is not
closed. <em>NOTE</em> use of the channel or filename options results in the
internal use of <strong><a href="../../../../index.md#vwait">vwait</a></strong>. To avoid
nested event loops in Tk or tclhttpd applications you should use the
incremental programming API (see below).</p>
<p>Only one of <em>-file</em>, <em>-channel</em> or <em>string</em> should be given.</p>
<p>If the <em>string</em> to hash can be mistaken for an option (leading dash "-"),
use the option <strong>--</strong> before it to terminate option processing and force
interpretation as a string.</p></li>
<li><p><a name="2"></a><strong>::sha2::sha224</strong> ?<strong>-hex&#124;-bin</strong>? [ <strong>-channel channel</strong> &#124; <strong>-file filename</strong> &#124; ?<strong>--</strong>? <em>string</em> ]</p>
<p>Like <strong>::sha2::sha256</strong>, except that the SHA224 digest is returned.</p></li>
<li><p><a name="3"></a><strong>::sha2::hmac</strong> <em>key</em> <em>string</em></p></li>
<li><p><a name="4"></a><strong>::sha2::hmac</strong> ?<strong>-hex&#124;-bin</strong>? <strong>-key key</strong> [ <strong>-channel channel</strong> &#124; <strong>-file filename</strong> &#124; ?<strong>--</strong>? <em>string</em> ]</p>
<p>Calculate an Hashed Message Authentication digest (HMAC) using the SHA256
digest algorithm. HMACs are described in RFC 2104 (3) and provide an SHA256
digest that includes a key. All options other than <em>-key</em> are as for the
<strong>::sha2::sha256</strong> command.</p>
<p>If the <em>string</em> to hash can be mistaken for an option (leading dash "-"),
use the option <strong>--</strong> before it to terminate option processing and force
interpretation as a string.</p></li>
</ul>
<h1><a name="section3"></a>PROGRAMMING INTERFACE</h1>
<p>For the programmer, the SHA256 hash can be viewed as a bucket into which one
pours data. When you have finished, you extract a value that is derived from the
data that was poured into the bucket. The programming interface to the SHA256
hash operates on a token (equivalent to the bucket). You call <strong>SHA256Init</strong>
to obtain a token and then call <strong>SHA256Update</strong> as many times as required
to add data to the hash. To release any resources and obtain the hash value, you
then call <strong>SHA256Final</strong>. An equivalent set of functions gives you a keyed
digest (HMAC).</p>
<p>If you have <strong>critcl</strong> and have built the <strong>tcllibc</strong> package then the
implementation of the hashing function will be performed by compiled code.
Failing that there is a pure-tcl equivalent. The programming interface remains
the same in all cases.</p>
<ul>
<li><p><a name="5"></a><strong>::sha2::SHA256Init</strong></p></li>
<li><p><a name="6"></a><strong>::sha2::SHA224Init</strong></p>
<p>Begins a new SHA256/SHA224 hash. Returns a token ID that must be used for
the remaining functions.</p></li>
<li><p><a name="7"></a><strong>::sha2::SHA256Update</strong> <em>token</em> <em>data</em></p>
<p>Add data to the hash identified by token. Calling <em>SHA256Update $token
"abcd"</em> is equivalent to calling <em>SHA256Update $token "ab"</em> followed by
<em>SHA256Update $token "cb"</em>. See <a href="#section4">EXAMPLES</a>. Note that this
command is used for both SHA256 and SHA224. Only the initialization and
finalization commands of both hashes differ.</p></li>
<li><p><a name="8"></a><strong>::sha2::SHA256Final</strong> <em>token</em></p></li>
<li><p><a name="9"></a><strong>::sha2::SHA224Final</strong> <em>token</em></p>
<p>Returns the hash value and releases any resources held by this token. Once
this command completes the token will be invalid. The result is a binary
string of 32/28 bytes representing the 256/224 bit SHA256 / SHA224 digest
value.</p></li>
<li><p><a name="10"></a><strong>::sha2::HMACInit</strong> <em>key</em></p>
<p>This is equivalent to the <strong>::sha2::SHA256Init</strong> command except that it
requires the key that will be included in the HMAC.</p></li>
<li><p><a name="11"></a><strong>::sha2::HMACUpdate</strong> <em>token</em> <em>data</em></p></li>
<li><p><a name="12"></a><strong>::sha2::HMACFinal</strong> <em>token</em></p>
<p>These commands are identical to the SHA256 equivalent commands.</p></li>
</ul>
<h1><a name="section4"></a>EXAMPLES</h1>
<pre><code>% sha2::sha256 "Tcl does SHA256"
0b91043ee484abd83c3e4b08d6034d71b937026379f0f59bda6e625e6e214789

% sha2::hmac Sekret "Tcl does SHA256"
4f9352c64d655e8a36abe73e6163a9d7a54039877c1c92ec90b07d48d4e854e0

% set tok [sha2::SHA256Init]
::sha2::1
% sha2::SHA256Update $tok "Tcl "
% sha2::SHA256Update $tok "does "
% sha2::SHA256Update $tok "SHA256"
% sha2::Hex [sha2::SHA256Final $tok]
0b91043ee484abd83c3e4b08d6034d71b937026379f0f59bda6e625e6e214789
</code></pre>
<h1><a name="section5"></a>REFERENCES</h1>
<ol>
<li><p>"Secure Hash Standard", National Institute of Standards and Technology,
U.S. Department Of Commerce, April 1995.
(<a href="http://www.itl.nist.gov/fipspubs/fip180-1.htm">http://www.itl.nist.gov/fipspubs/fip180-1.htm</a>)</p></li>
<li><p>Rivest, R., "The MD4 Message Digest Algorithm", RFC 1320, MIT, April 1992.
(<a href="http://www.rfc-editor.org/rfc/rfc1320.txt">http://www.rfc-editor.org/rfc/rfc1320.txt</a>)</p></li>
<li><p>Krawczyk, H., Bellare, M. and Canetti, R. "HMAC: Keyed-Hashing for Message
Authentication", RFC 2104, February 1997.
(<a href="http://www.rfc-editor.org/rfc/rfc2104.txt">http://www.rfc-editor.org/rfc/rfc2104.txt</a>)</p></li>
</ol>
<h1><a name="section6"></a>Bugs, Ideas, Feedback</h1>
<p>This document, and the package it describes, will undoubtedly contain bugs and
other problems. Please report such in the category <em>sha1</em> of the <a href="http://core.tcl.tk/tcllib/reportlist">Tcllib
Trackers</a>. Please also report any ideas
for enhancements you may have for either package and/or documentation.</p>
<p>When proposing code changes, please provide <em>unified diffs</em>, i.e the output of
<strong>diff -u</strong>.</p>
<p>Note further that <em>attachments</em> are strongly preferred over inlined patches.
Attachments can be made by going to the <strong>Edit</strong> form of the ticket
immediately after its creation, and then using the left-most button in the
secondary navigation bar.</p>
<h1><a name="seealso"></a>SEE ALSO</h1>
<p><a href="../md4/md4.md">md4</a>, <a href="../md5/md5.md">md5</a>,
<a href="../ripemd/ripemd128.md">ripemd128</a>,
<a href="../ripemd/ripemd160.md">ripemd160</a>, <a href="sha1.md">sha1</a></p>
<h1><a name="keywords"></a>KEYWORDS</h1>
<p><a href="../../../../index.md#fips_180_1">FIPS 180-1</a>,
<a href="../../../../index.md#hashing">hashing</a>,
<a href="../../../../index.md#message_digest">message-digest</a>, <a href="../../../../index.md#rfc_2104">rfc
2104</a>,
<a href="../../../../index.md#security">security</a>,
<a href="../../../../index.md#sha256">sha256</a></p>
<h1><a name="category"></a>CATEGORY</h1>
<p>Hashes, checksums, and encryption</p>
<h1><a name="copyright"></a>COPYRIGHT</h1>
<p>Copyright &copy; 2008, Andreas Kupries <andreas\_kupries@users\.sourceforge\.net></p>
</div>
<script nonce="1e128427487a5e2855ebadb59d1ffd804563f7c7965ed1ec">/* builtin.c:620 */
(function(){
if(window.NodeList && !NodeList.prototype.forEach){NodeList.prototype.forEach = Array.prototype.forEach;}
if(!window.fossil) window.fossil={};
window.fossil.version = "2.23 [47362306a7] 2023-11-01 18:56:47 UTC";
window.fossil.rootPath = "/tcllib"+'/';
window.fossil.config = {projectName: "Tcl Library Source Code",
shortProjectName: "",
projectCode: "05391902863193f286cc4eeb0b0cd8a8d16b4ec9",
/* Length of UUID hashes for display purposes. */hashDigits: 10, hashDigitsUrl: 16,
diffContextLines: 5,
editStateMarkers: {/*Symbolic markers to denote certain edit states.*/isNew:'[+]', isModified:'[*]', isDeleted:'[-]'},
confirmerButtonTicks: 3 /*default fossil.confirmer tick count.*/,
skin:{isDark: false/*true if the current skin has the 'white-foreground' detail*/}
};
window.fossil.user = {name: "guest",isAdmin: false};
if(fossil.config.skin.isDark) document.body.classList.add('fossil-dark-style');
window.fossil.page = {name:"doc/trunk/embedded/md/tcllib/files/modules/sha1/sha256.md"};
})();
</script>
<script nonce="1e128427487a5e2855ebadb59d1ffd804563f7c7965ed1ec">/* doc.c:430 */
window.addEventListener('load', ()=>window.fossil.pikchr.addSrcView(), false);
</script>
</div>
<div class="footer">
This page was generated in about
0.081s by
Fossil 2.23 [47362306a7] 2023-11-01 18:56:47
</div>
<script nonce="1e128427487a5e2855ebadb59d1ffd804563f7c7965ed1ec">/* style.c:914 */
function debugMsg(msg){
var n = document.getElementById("debugMsg");
if(n){n.textContent=msg;}
}
</script>
<script nonce="1e128427487a5e2855ebadb59d1ffd804563f7c7965ed1ec">
/* fossil.bootstrap.js *************************************************************/
"use strict";
(function () {
if(typeof window.CustomEvent === "function") return false;
window.CustomEvent = function(event, params) {
if(!params) params = {bubbles: false, cancelable: false, detail: null};
const evt = document.createEvent('CustomEvent');
evt.initCustomEvent( event, !!params.bubbles, !!params.cancelable, params.detail );
return evt;
};
})();
(function(global){
const F = global.fossil;
const timestring = function f(){
if(!f.rx1){
f.rx1 = /\.\d+Z$/;
}
const d = new Date();
return d.toISOString().replace(f.rx1,'').split('T').join(' ');
};
const localTimeString = function ff(d){
if(!ff.pad){
ff.pad = (x)=>(''+x).length>1 ? x : '0'+x;
}
d || (d = new Date());
return [
d.getFullYear(),'-',ff.pad(d.getMonth()+1),
'-',ff.pad(d.getDate()),
' ',ff.pad(d.getHours()),':',ff.pad(d.getMinutes()),
':',ff.pad(d.getSeconds())
].join('');
};
F.message = function f(msg){
const args = Array.prototype.slice.call(arguments,0);
const tgt = f.targetElement;
if(args.length) args.unshift(
localTimeString()+':'
);
if(tgt){
tgt.classList.remove('error');
tgt.innerText = args.join(' ');
}
else{
if(args.length){
args.unshift('Fossil status:');
console.debug.apply(console,args);
}
}
return this;
};
F.message.targetElement =
document.querySelector('#fossil-status-bar');
if(F.message.targetElement){
F.message.targetElement.addEventListener(
'dblclick', ()=>F.message(), false
);
}
F.error = function f(msg){
const args = Array.prototype.slice.call(arguments,0);
const tgt = F.message.targetElement;
args.unshift(timestring(),'UTC:');
if(tgt){
tgt.classList.add('error');
tgt.innerText = args.join(' ');
}
else{
args.unshift('Fossil error:');
console.error.apply(console,args);
}
return this;
};
F.encodeUrlArgs = function(obj,tgtArray,fakeEncode){
if(!obj) return '';
const a = (tgtArray instanceof Array) ? tgtArray : [],
enc = fakeEncode ? (x)=>x : encodeURIComponent;
let k, i = 0;
for( k in obj ){
if(i++) a.push('&');
a.push(enc(k),'=',enc(obj[k]));
}
return a===tgtArray ? a : a.join('');
};
F.repoUrl = function(path,urlParams){
if(!urlParams) return this.rootPath+path;
const url=[this.rootPath,path];
url.push('?');
if('string'===typeof urlParams) url.push(urlParams);
else if(urlParams && 'object'===typeof urlParams){
this.encodeUrlArgs(urlParams, url);
}
return url.join('');
};
F.isObject = function(v){
return v &&
(v instanceof Object) &&
('[object Object]' === Object.prototype.toString.apply(v) );
};
F.mergeLastWins = function(){
var k, o, i;
const n = arguments.length, rc={};
for(i = 0; i < n; ++i){
if(!F.isObject(o = arguments[i])) continue;
for( k in o ){
if(o.hasOwnProperty(k)) rc[k] = o[k];
}
}
return rc;
};
F.hashDigits = function(hash,forUrl){
const n = ('number'===typeof forUrl)
? forUrl : F.config[forUrl ? 'hashDigitsUrl' : 'hashDigits'];
return ('string'==typeof hash ? hash.substr(
0, n
) : hash);
};
F.onPageLoad = function(callback){
window.addEventListener('load', callback, false);
return this;
};
F.onDOMContentLoaded = function(callback){
window.addEventListener('DOMContentLoaded', callback, false);
return this;
};
F.shortenFilename = function(name){
const a = name.split('/');
if(a.length<=2) return name;
while(a.length>2) a.shift();
return '.../'+a.join('/');
};
F.page.addEventListener = function f(eventName, callback){
if(!f.proxy){
f.proxy = document.createElement('span');
}
f.proxy.addEventListener(eventName, callback, false);
return this;
};
F.page.dispatchEvent = function(eventName, eventDetail){
if(this.addEventListener.proxy){
try{
this.addEventListener.proxy.dispatchEvent(
new CustomEvent(eventName,{detail: eventDetail})
);
}catch(e){
console.error(eventName,"event listener threw:",e);
}
}
return this;
};
F.page.setPageTitle = function(title){
const t = document.querySelector('title');
if(t) t.innerText = title;
return this;
};
F.debounce = function f(func, wait, immediate) {
var timeout;
if(!wait) wait = f.$defaultDelay;
return function() {
const context = this, args = Array.prototype.slice.call(arguments);
const later = function() {
timeout = undefined;
if(!immediate) func.apply(context, args);
};
const callNow = immediate && !timeout;
clearTimeout(timeout);
timeout = setTimeout(later, wait);
if(callNow) func.apply(context, args);
};
};
F.debounce.$defaultDelay = 500;
})(window);
/* fossil.dom.js *************************************************************/
"use strict";
(function(F){
const argsToArray = (a)=>Array.prototype.slice.call(a,0);
const isArray = (v)=>v instanceof Array;
const dom = {
create: function(elemType){
return document.createElement(elemType);
},
createElemFactory: function(eType){
return function(){
return document.createElement(eType);
};
},
remove: function(e){
if(e.forEach){
e.forEach(
(x)=>x.parentNode.removeChild(x)
);
}else{
e.parentNode.removeChild(e);
}
return e;
},
clearElement: function f(e){
if(!f.each){
f.each = function(e){
if(e.forEach){
e.forEach((x)=>f(x));
return e;
}
while(e.firstChild) e.removeChild(e.firstChild);
};
}
argsToArray(arguments).forEach(f.each);
return arguments[0];
},
};
dom.splitClassList = function f(str){
if(!f.rx){
f.rx = /(\s+|\s*,\s*)/;
}
return str ? str.split(f.rx) : [str];
};
dom.div = dom.createElemFactory('div');
dom.p = dom.createElemFactory('p');
dom.code = dom.createElemFactory('code');
dom.pre = dom.createElemFactory('pre');
dom.header = dom.createElemFactory('header');
dom.footer = dom.createElemFactory('footer');
dom.section = dom.createElemFactory('section');
dom.span = dom.createElemFactory('span');
dom.strong = dom.createElemFactory('strong');
dom.em = dom.createElemFactory('em');
dom.ins = dom.createElemFactory('ins');
dom.del = dom.createElemFactory('del');
dom.label = function(forElem, text){
const rc = document.createElement('label');
if(forElem){
if(forElem instanceof HTMLElement){
forElem = this.attr(forElem, 'id');
}
dom.attr(rc, 'for', forElem);
}
if(text) this.append(rc, text);
return rc;
};
dom.img = function(src){
const e = this.create('img');
if(src) e.setAttribute('src',src);
return e;
};
dom.a = function(href,label){
const e = this.create('a');
if(href) e.setAttribute('href',href);
if(label) e.appendChild(dom.text(true===label ? href : label));
return e;
};
dom.hr = dom.createElemFactory('hr');
dom.br = dom.createElemFactory('br');
dom.text = function(){
return document.createTextNode(argsToArray(arguments).join(''));
};
dom.button = function(label,callback){
const b = this.create('button');
if(label) b.appendChild(this.text(label));
if('function' === typeof callback){
b.addEventListener('click', callback, false);
}
return b;
};
dom.textarea = function(){
const rc = this.create('textarea');
let rows, cols, readonly;
if(1===arguments.length){
if('boolean'===typeof arguments[0]){
readonly = !!arguments[0];
}else{
rows = arguments[0];
}
}else if(arguments.length){
rows = arguments[0];
cols = arguments[1];
readonly = arguments[2];
}
if(rows) rc.setAttribute('rows',rows);
if(cols) rc.setAttribute('cols', cols);
if(readonly) rc.setAttribute('readonly', true);
return rc;
};
dom.select = dom.createElemFactory('select');
dom.option = function(value,label){
const a = arguments;
var sel;
if(1==a.length){
if(a[0] instanceof HTMLElement){
sel = a[0];
}else{
value = a[0];
}
}else if(2==a.length){
if(a[0] instanceof HTMLElement){
sel = a[0];
value = a[1];
}else{
value = a[0];
label = a[1];
}
}
else if(3===a.length){
sel = a[0];
value = a[1];
label = a[2];
}
const o = this.create('option');
if(undefined !== value){
o.value = value;
this.append(o, this.text(label || value));
}else if(undefined !== label){
this.append(o, label);
}
if(sel) this.append(sel, o);
return o;
};
dom.h = function(level){
return this.create('h'+level);
};
dom.ul = dom.createElemFactory('ul');
dom.li = function(parent){
const li = this.create('li');
if(parent) parent.appendChild(li);
return li;
};
dom.createElemFactoryWithOptionalParent = function(childType){
return function(parent){
const e = this.create(childType);
if(parent) parent.appendChild(e);
return e;
};
};
dom.table = dom.createElemFactory('table');
dom.thead = dom.createElemFactoryWithOptionalParent('thead');
dom.tbody = dom.createElemFactoryWithOptionalParent('tbody');
dom.tfoot = dom.createElemFactoryWithOptionalParent('tfoot');
dom.tr = dom.createElemFactoryWithOptionalParent('tr');
dom.td = dom.createElemFactoryWithOptionalParent('td');
dom.th = dom.createElemFactoryWithOptionalParent('th');
dom.fieldset = function(legendText){
const fs = this.create('fieldset');
if(legendText){
this.append(
fs,
(legendText instanceof HTMLElement)
? legendText
: this.append(this.legend(legendText))
);
}
return fs;
};
dom.legend = function(legendText){
const rc = this.create('legend');
if(legendText) this.append(rc, legendText);
return rc;
};
dom.append = function f(parent){
const a = argsToArray(arguments);
a.shift();
for(let i in a) {
var e = a[i];
if(isArray(e) || e.forEach){
e.forEach((x)=>f.call(this, parent,x));
continue;
}
if('string'===typeof e
|| 'number'===typeof e
|| 'boolean'===typeof e
|| e instanceof Error) e = this.text(e);
parent.appendChild(e);
}
return parent;
};
dom.input = function(type){
return this.attr(this.create('input'), 'type', type);
};
dom.checkbox = function(value, checked){
const rc = this.input('checkbox');
if(1===arguments.length && 'boolean'===typeof value){
checked = !!value;
value = undefined;
}
if(undefined !== value) rc.value = value;
if(!!checked) rc.checked = true;
return rc;
};
dom.radio = function(){
const rc = this.input('radio');
let name, value, checked;
if(1===arguments.length && 'boolean'===typeof name){
checked = arguments[0];
name = value = undefined;
}else if(2===arguments.length){
name = arguments[0];
if('boolean'===typeof arguments[1]){
checked = arguments[1];
}else{
value = arguments[1];
checked = undefined;
}
}else if(arguments.length){
name = arguments[0];
value = arguments[1];
checked = arguments[2];
}
if(name) this.attr(rc, 'name', name);
if(undefined!==value) rc.value = value;
if(!!checked) rc.checked = true;
return rc;
};
const domAddRemoveClass = function f(action,e){
if(!f.rxSPlus){
f.rxSPlus = /\s+/;
f.applyAction = function(e,a,v){
if(!e || !v
) return;
else if(e.forEach){
e.forEach((E)=>E.classList[a](v));
}else{
e.classList[a](v);
}
};
}
var i = 2, n = arguments.length;
for( ; i < n; ++i ){
let c = arguments[i];
if(!c) continue;
else if(isArray(c) ||
('string'===typeof c
&& c.indexOf(' ')>=0
&& (c = c.split(f.rxSPlus)))
|| c.forEach
){
c.forEach((k)=>k ? f.applyAction(e, action, k) : false);
}else if(c){
f.applyAction(e, action, c);
}
}
return e;
};
dom.addClass = function(e,c){
const a = argsToArray(arguments);
a.unshift('add');
return domAddRemoveClass.apply(this, a);
};
dom.removeClass = function(e,c){
const a = argsToArray(arguments);
a.unshift('remove');
return domAddRemoveClass.apply(this, a);
};
dom.toggleClass = function f(e,c){
if(e.forEach){
e.forEach((x)=>x.classList.toggle(c));
}else{
e.classList.toggle(c);
}
return e;
};
dom.hasClass = function(e,c){
return (e && e.classList) ? e.classList.contains(c) : false;
};
dom.moveTo = function(dest,e){
const n = arguments.length;
var i = 1;
const self = this;
for( ; i < n; ++i ){
e = arguments[i];
this.append(dest, e);
}
return dest;
};
dom.moveChildrenTo = function f(dest,e){
if(!f.mv){
f.mv = function(d,v){
if(d instanceof Array){
d.push(v);
if(v.parentNode) v.parentNode.removeChild(v);
}
else d.appendChild(v);
};
}
const n = arguments.length;
var i = 1;
for( ; i < n; ++i ){
e = arguments[i];
if(!e){
console.warn("Achtung: dom.moveChildrenTo() passed a falsy value at argument",i,"of",
arguments,arguments[i]);
continue;
}
if(e.forEach){
e.forEach((x)=>f.mv(dest, x));
}else{
while(e.firstChild){
f.mv(dest, e.firstChild);
}
}
}
return dest;
};
dom.replaceNode = function f(old,nu){
var i = 1, n = arguments.length;
++f.counter;
try {
for( ; i < n; ++i ){
const e = arguments[i];
if(e.forEach){
e.forEach((x)=>f.call(this,old,e));
continue;
}
old.parentNode.insertBefore(e, old);
}
}
finally{
--f.counter;
}
if(!f.counter){
old.parentNode.removeChild(old);
}
};
dom.replaceNode.counter = 0;
dom.attr = function f(e){
if(2===arguments.length) return e.getAttribute(arguments[1]);
const a = argsToArray(arguments);
if(e.forEach){
e.forEach(function(x){
a[0] = x;
f.apply(f,a);
});
return e;
}
a.shift();
while(a.length){
const key = a.shift(), val = a.shift();
if(null===val || undefined===val){
e.removeAttribute(key);
}else{
e.setAttribute(key,val);
}
}
return e;
};
const enableDisable = function f(enable){
var i = 1, n = arguments.length;
for( ; i < n; ++i ){
let e = arguments[i];
if(e.forEach){
e.forEach((x)=>f(enable,x));
}else{
e.disabled = !enable;
}
}
return arguments[1];
};
dom.enable = function(e){
const args = argsToArray(arguments);
args.unshift(true);
return enableDisable.apply(this,args);
};
dom.disable = function(e){
const args = argsToArray(arguments);
args.unshift(false);
return enableDisable.apply(this,args);
};
dom.selectOne = function(x,origin){
var src = origin || document,
e = src.querySelector(x);
if(!e){
e = new Error("Cannot find DOM element: "+x);
console.error(e, src);
throw e;
}
return e;
};
dom.flashOnce = function f(e,howLongMs,afterFlashCallback){
if(e.dataset.isBlinking){
return;
}
if(2===arguments.length && 'function' ===typeof howLongMs){
afterFlashCallback = howLongMs;
howLongMs = f.defaultTimeMs;
}
if(!howLongMs || 'number'!==typeof howLongMs){
howLongMs = f.defaultTimeMs;
}
e.dataset.isBlinking = true;
const transition = e.style.transition;
e.style.transition = "opacity "+howLongMs+"ms ease-in-out";
const opacity = e.style.opacity;
e.style.opacity = 0;
setTimeout(function(){
e.style.transition = transition;
e.style.opacity = opacity;
delete e.dataset.isBlinking;
if(afterFlashCallback) afterFlashCallback();
}, howLongMs);
return e;
};
dom.flashOnce.defaultTimeMs = 400;
dom.flashOnce.eventHandler = (event)=>dom.flashOnce(event.target)
dom.flashNTimes = function(e,n,howLongMs,afterFlashCallback){
const args = argsToArray(arguments);
args.splice(1,1);
if(arguments.length===3 && 'function'===typeof howLongMs){
afterFlashCallback = howLongMs;
howLongMs = args[1] = this.flashOnce.defaultTimeMs;
}else if(arguments.length<3){
args[1] = this.flashOnce.defaultTimeMs;
}
n = +n;
const self = this;
const cb = args[2] = function f(){
if(--n){
setTimeout(()=>self.flashOnce(e, howLongMs, f),
howLongMs+(howLongMs*0.1));
}else if(afterFlashCallback){
afterFlashCallback();
}
};
this.flashOnce.apply(this, args);
return this;
};
dom.addClassBriefly = function f(e, className, howLongMs, afterCallback){
if(arguments.length<4 && 'function'===typeof howLongMs){
afterCallback = howLongMs;
howLongMs = f.defaultTimeMs;
}else if(arguments.length<3 || !+howLongMs){
howLongMs = f.defaultTimeMs;
}
this.addClass(e, className);
setTimeout(function(){
dom.removeClass(e, className);
if(afterCallback) afterCallback();
}, howLongMs);
return this;
};
dom.addClassBriefly.defaultTimeMs = 1000;
dom.copyTextToClipboard = function(text){
if( window.clipboardData && window.clipboardData.setData ){
window.clipboardData.setData('Text',text);
return true;
}else{
const x = document.createElement("textarea");
x.style.position = 'fixed';
x.value = text;
document.body.appendChild(x);
x.select();
var rc;
try{
document.execCommand('copy');
rc = true;
}catch(err){
rc = false;
}finally{
document.body.removeChild(x);
}
return rc;
}
};
dom.copyStyle = function f(e, style){
if(e.forEach){
e.forEach((x)=>f(x, style));
return e;
}
if(style){
let k;
for(k in style){
if(style.hasOwnProperty(k)) e.style[k] = style[k];
}
}
return e;
};
dom.effectiveHeight = function f(e){
if(!e) return 0;
if(!f.measure){
f.measure = function callee(e, depth){
if(!e) return;
const m = e.getBoundingClientRect();
if(0===depth){
callee.top = m.top;
callee.bottom = m.bottom;
}else{
callee.top = m.top ? Math.min(callee.top, m.top) : callee.top;
callee.bottom = Math.max(callee.bottom, m.bottom);
}
Array.prototype.forEach.call(e.children,(e)=>callee(e,depth+1));
if(0===depth){
f.extra += callee.bottom - callee.top;
}
return f.extra;
};
}
f.extra = 0;
f.measure(e,0);
return f.extra;
};
dom.parseHtml = function(){
let childs, string, tgt;
if(1===arguments.length){
string = arguments[0];
}else if(2==arguments.length){
tgt = arguments[0];
string  = arguments[1];
}
if(string){
const newNode = new DOMParser().parseFromString(string, 'text/html');
childs = newNode.documentElement.querySelector('body');
childs = childs ? Array.prototype.slice.call(childs.childNodes, 0) : [];
}else{
childs = [];
}
return tgt ? this.moveTo(tgt, childs) : childs;
};
F.connectPagePreviewers = function f(selector,methodNamespace){
if('string'===typeof selector){
selector = document.querySelectorAll(selector);
}else if(!selector.forEach){
selector = [selector];
}
if(!methodNamespace){
methodNamespace = F.page;
}
selector.forEach(function(e){
e.addEventListener(
'click', function(r){
const eTo = '#'===e.dataset.fPreviewTo[0]
? document.querySelector(e.dataset.fPreviewTo)
: methodNamespace[e.dataset.fPreviewTo],
eFrom = '#'===e.dataset.fPreviewFrom[0]
? document.querySelector(e.dataset.fPreviewFrom)
: methodNamespace[e.dataset.fPreviewFrom],
asText = +(e.dataset.fPreviewAsText || 0);
eTo.textContent = "Fetching preview...";
methodNamespace[e.dataset.fPreviewVia](
(eFrom instanceof Function ? eFrom.call(methodNamespace) : eFrom.value),
function(r){
if(eTo instanceof Function) eTo.call(methodNamespace, r||'');
else if(!r){
dom.clearElement(eTo);
}else if(asText){
eTo.textContent = r;
}else{
dom.parseHtml(dom.clearElement(eTo), r);
}
}
);
}, false
);
});
return this;
};
return F.dom = dom;
})(window.fossil);
/* fossil.pikchr.js *************************************************************/
(function(F){
"use strict";
const D = F.dom, P = F.pikchr = {};
P.addSrcView = function f(svg){
if(!f.hasOwnProperty('parentClick')){
f.parentClick = function(ev){
if(ev.altKey || ev.metaKey || ev.ctrlKey
|| this.classList.contains('toggle')){
this.classList.toggle('source');
ev.stopPropagation();
ev.preventDefault();
}
};
};
if(!svg) svg = 'svg.pikchr';
if('string' === typeof svg){
document.querySelectorAll(svg).forEach((e)=>f.call(this, e));
return this;
}else if(svg.forEach){
svg.forEach((e)=>f.call(this, e));
return this;
}
if(svg.dataset.pikchrProcessed){
return this;
}
svg.dataset.pikchrProcessed = 1;
const parent = svg.parentNode.parentNode;
const srcView = parent ? svg.parentNode.nextElementSibling : undefined;
if(!srcView || !srcView.classList.contains('pikchr-src')){
return this;
}
parent.addEventListener('click', f.parentClick, false);
return this;
};
})(window.fossil);
</script>
</body>
</html>
