(*----------------------------------------------------------------------------*)
(*                     Synopsis of the language Joy                           *)
(*----------------------------------------------------------------------------*)

2 3 + .

(* складываем два числа, потом дублируем его в стеке и перемножаем их *)
2 3 + dup * .

(* склеиваем две строки *)
[1 2 3]  [4 5 6 7]  concat .

(* применяем некую функцию к массиву, здесь возведение в квадрат  *)
[1 2 3 4]  [dup *]  map .

(* ===================================================================

Finally, take a look at the combinators "i" and "dip":

      [A] i   == A
  [B] [A] dip == A [B] 

These combinators are special in that they dequote stack items, 
removing their wrapping; in other words, these combinators execute 
programs on the stack. The "i" combinator simply executes the top 
item on the stack. 
The "dip" combinator executes the top item "A", 
but first it gets rid of the second item, which is restored after 
the execution of "A" is complete. The "dip" combinator will prove 
to be very versatile and 
also quite fundamental. 

 ====================================================================*)

(* i - выполняет верхний итем на стеке: результатом будут в стеке "100 6"   *)

2 3  [ + 20 * 10 4 - ]  i . .

(* ===================================================================

Another combinator that expects an aggregate is the filter combinator. 
The quoted program has to yield a truth value. The result is a new 
aggregate of the same type containing those elements of the original 
for which the quoted program yields true. For example, the quoted 
program ['Z >] will yield truth for characters whose numeric values 
is greater than that of Z. Hence it can be used to remove upper case 
letters and blanks from a string.

 ====================================================================*)

(* применяем фильтр к строке: убираем заглавные буквы и пробелы ? *)

"John Smith"  ['Z >]  filter .


(* ===================================================================

Sometimes it is necessary to add or multiply or otherwise combine all 
elements of an aggregate value. The fold combinator can do just that. 
It requires three parameters: the aggregate to be folded, the quoted 
value to be returned when the aggregate is empty, and the quoted 
binary operation to be used to combine the elements. In some languages 
the combinator is called reduce (because it turns the aggregate into 
a single value), or insert (because it looks as though the binary 
operation has been inserted between any two members). The following 
two programs compute the sum of the members of a list and the sum of 
the squares of the members of a list. They evaluate to 10 and 38, 
respectively. 

 ====================================================================*)

[2 5 3]  0  [+]  fold .
[2 5 3]  0  [dup * +]  fold .  

(* ===================================================================

Joy has a useful device, the linrec combinator, which allows computation 
of anonymous functions that might have been defined recursively using 
a linear recursive pattern. Whereas the ifte combinator requires three 
quoted parameters, the linrec combinator requires four: an if-part, 
a then-part, a rec1-part and a rec2-part. Recursion occurs between 
the two rec-parts. For example, the factorial function could be 
computed by 
	succ == 1 +;
	pred == 1 -;

Здесь простая линейная рекурсия:
if 0 then 1 else [дублируем и уменьшаем на 1, затем умножаем *]

 ====================================================================*)

4  [null] [succ] [dup pred] [*] linrec  .

(* вычислим факториал для каждого элемента списка [1 2 3 4] *)
[1 2 3 4]  [ [null]  [succ]  [dup pred]  [*]  linrec ]   map .


(* ===================================================================

quit.

 ====================================================================*)

(*----------------------------------------------------------------------------*)

