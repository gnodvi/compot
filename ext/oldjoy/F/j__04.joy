(* --------------------------------------------------------------- *)
(*  Overview of the language JOY : это мои первые тесты            *)

(*  js~.tl TEST_main j__00.joy                                     *)
(* --------------------------------------------------------------- *)


"./L/N_inilib.joy" include.
"./L/numlib.joy"   include.
"./L/mthlib.joy"   include.

LIBRA

  mylist == [5 6 0 1];

  linrec2 == (P T R1 R2)
     $P $T
     $R1
     $P $T $R1 $R2 [] cons cons cons cons
     [linrec] $R2 concat concat concat
     ifte;

     binrec2 == (B T R1 R2)
     $B $T
     $R1 [(a b)] concat
     [$a] $B $T $R1 $R2 [] cons cons cons cons concat [binrec]
     [$b] $B $T $R1 $R2 [] cons cons cons cons concat [binrec]
     $R2 concat concat concat concat concat
     ifte

END. 

newline .

(* ==========================================================================


В Joy есть полезная штука - комбинатор linrec, который позволяет вычислять 
анонимные функции, которые могут быть определены рекурсивно, испульзуя 
линейно-рекурсивный паттерн. Там где комбинатор ifte требует три квотированных
параметра, комбинатору linrec требуется четыре: 
an if-part, a then-part, a rec1-part and a rec2-part.

Например, функция factorial может быть вычислена как: 
	succ == 1 +;
	pred == 1 -;
Здесь простая линейная рекурсия:
if 0 then 1 else [дублируем и уменьшаем на 1, затем умножаем *]

Да, вот это правильное описание:

linrec 	[P] [T] [R1] [R2] -> ...
	Executes P. If that yields true, executes T. 
        Else executes R1, recurses, executes R2.

0  [null] [succ] [dup pred] [*] linrec2  .
4  [null] [succ] [dup pred] [*] linrec2  .

4  [null] [succ] [dup pred] [*] linrec_gena  .
9  [null] [succ] [dup pred] [*] linrec_gena  .

============================================================================= *)


4  [null] [succ] [dup pred] [*] linrec2  .

(* =============================================================================

mylist    putlist
[3 2 4 1]  [small] [] [uncons [>] split] [swapd cons concat]  binrec2 ^



[5 4 3 2] putlist
mylist binrec2 .
newline .
mylist qsort  putlist 
newline .


Бинарная рекурсия: не работает в JOYTCL !!!!!
Runtime error: Type mismatch. Expected 'integer string float char', got 'list'

Во многих  рекурсивных определениях имеется два рекурсивных вызова определяемой
функции. Это паттерн бинарной рекурсии и он обычно используется в определениях
функций  quicksort и  Fibonacci.

По аналогии с комбинатором линейной рекурсии linrec, в Joy есть комбинатор для
бинарной рекурсии binrec.
Ниже демонстрируется функция quicksort для быстрой сортировки списка из смеси 
всего, кроме списков.

qsort ==
        [small] [] [uncons [>] split] [swapd cons concat] binrec

[3 2 4 1]  [small] [] [uncons [>] split] [swapd cons concat]  binrec2 ^

---------------------------------------------

3 [1 2 3 4] in .
5 [1 2 3 4] in .
[-] [+ - * /] in . 

[5 4 3 2] putlist
newline .
[5 4 3 2] qsort

newline .

=============================================================================== *)

quit.

(* ============================================================================ *)


