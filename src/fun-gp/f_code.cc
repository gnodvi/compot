// -*-  mode: c    ; coding: koi8   -*- ----------------------------------------

//------------------------------------------------------------------------------

/* #include <stdio.h> */
/* #include <stdlib.h>    */
/* #include <string.h> */
/* #include <math.h>  */


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
/* 

D. Backspace
ограничение по времени на тест   2 секунды
ограничение по памяти на тест    256 мегабайт
ввод    стандартный ввод
вывод   стандартный вывод

Вам заданы две строки s
и t, каждая из которых состоит из строчных букв латинского алфавита. 
Вы собираетесь посимвольно напечатать строку s
, начиная с первого символа и заканчивая последним.

Когда вы собираетесь напечатать какой-то символ, вместо того, чтобы нажать на 
кнопку, печатающую этот символ, вы можете нажать кнопку "Backspace". Нажатие 
на эту кнопку удаляет последний напечатанный символ, который еще не был удален 
(или ничего не делает, если все напечатанные символы уже удалены или вы еще не 
напечатали ни одного символа). 

Например, если строка s -- "abcbd", и вы нажимаете на кнопку Backspace вместо 
печати первого и 
четвертого символа, в результате получится строка "bd" (первое нажатие Backspace 
не удалит ни одного символа, а второе нажатие этой кнопки удалит символ "c". 

Другой пример: если s
равна "abcaa", и вы нажимаете Backspace вместо двух последних букв, 
получается "a".

Вы должны определить, можно ли получить строку t
, если вы попробуете набрать строку s, нажимая Backspace вместо нажатия кнопок, 
соответствующих некоторым (возможно, ни одному) буквам строки s


//--------------------------------------------
Входные данные

В первой строке задано одно целое число q (1 <= q <= 10^5 ) -- количество 
наборов входных данных.

Первая строка каждого набора входных данных содержит строку s 
(1 <= |s| <= 10^5). 
Каждый символ строки s -- строчная буква латинского алфавита.

Вторая строка каждого набора входных данных содержит строку t 
(1 <= |t| <= 10^5). 
Каждый символ строки t -- строчная буква латинского алфавита.

Гарантируется, что суммарное по всем наборам входных данных количество 
символов во всех строках не превосходит 2 * 10^5


Выходные данные

Для каждого набора выходных данных выведите "YES", если можно получить строку t
, набирая строку s и заменяя некоторые символы нажатиями клавиши Backspace, 
или "NO" в противном случае.

Каждую букву можно выводить в любом регистре (YES, yes, Yes будут распознаны 
как положительный ответ, NO, no и nO будут распознаны как отрицательный ответ).

*/
//--------------------------------------------

// Пример
// Входные данные

// 4
// ababa
// ba
// ababa
// bb
// aaa
// aaaa
// aababa
// ababa

// Выходные данные

// YES
// NO
// NO
// YES

//--------------------------------------------
// Примечание
// Рассмотрим пример из условия.

// Чтобы получить <<ba>> из <<ababa>>, можно нажать Backspace вместо первого и 
// четвертого символа.

// Нет способа получить <<bb>> при попытке напечатать <<ababa>>.

// Нет способа получить <<aaaa>> при попытке напечатать <<aaa>>.

// Чтобы получить <<ababa>> при попытке напечатать <<aababa>>, можно нажать 
// Backspace вместо печати первого символа, а затем напечатать все оставшиеся 
// символы.

//------------------------------------------------------------------------------

#include <bits/stdc++.h>

using namespace std;

#define FILENAME "f_code.in"

//------------------------------------------------------------------------------

int main ()
{

  ios_base::sync_with_stdio(false);
  cin.tie(NULL);

  #ifndef ONLINE_JUDGE
  //freopen ("input.txt",  "r", stdin);
  //freopen ("output.txt", "w", stdout);

  freopen (FILENAME,  "r", stdin);
  //freopen ("t_code.O",  "w", stdout);
  #endif

  int ttt;
  cin >> ttt; //  первое значение - количество тестов

  for (int tt = 0; tt < ttt; tt++)
  {

    // один тест

    string s, t;
    cin >> s >> t; // читаем две строки ?

    int n = s.size();
    int m = t.size();

    int i = n - 1;
    int f = 1;

    printf ("s = %s \n", s.c_str());
    printf ("t = %s \n", t.c_str());

    for (int j = m - 1; j >= 0; j--)
    {

      printf ("j = %d \n", j);

      // while (i >= 0 && s[i] != t[j])
      while (1)
      {
        printf ("  i = %d, s[i] = %c, t[j] = %c \n", i, s[i], t[j]);

        if (i < 0) break; 

        if (s[i] == t[j]) 
          break; // символы равны, выходим на сдвиг в 1 символ

        i -= 2;  // если не равны в исходной строке сдвигаемся на 2 символа
      }

      // идея в том, что :
      // 1) идем с концов сравнивая;
      // 2) если символы совпадают, значит мы его печатали, всё просто;
      // 3) если не совпадают, то единственный вариант может быть, если там была;
      //    нажата BACKSPACE, что "убмвает" сразу 2 символа - его и предыдущий;
      // 4) ну м ограничения по началу строк смотрим;

      if (i < 0)
      {
        f = 0;
        break;
      }

      i -= 1; // и дальше указатель в исходной строке на 1 символ влево
    }
   
    //if (f)   cout << "YES \n"; // отложенная печать в конце !?
    //else     cout << "NO  \n";

    //if (f)   cout << "YES" << endl ;
    //else     cout << "NO"  << endl ;

    if (f)   printf ("YES \n");
    else     printf ("NO  \n");
    
    printf ("------------------------------- \n");

  }

  return 0;
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
