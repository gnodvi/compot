# -*-   mode: tcl  ; coding: koi8   -*- ----------------------------------------

#-------------------------------------------------------------------------------

################################################################################
#
# Новый метод (pGP - probabalistic):
# 
# 1) фиксируем "программу" максимального размера с избыточным кол-ом операторов
# 2) каждый оператор идет с вероятность его выполения
# 3) фитнес-значене = сумме попыток выполнения вероятностной программы
# 4) ищем решение в виде вщественной хромомомы (а может и округляя вероятности)
# 
#-------------------------------------------------------------------------------
proc calc_FITPROC_01 {task joy_prg} {

  set fitness 0

  set result [getresult_prg  $joy_prg]

  set delta [expr {abs($::sum_target-$result)}]  ;# ??
  
  incr fitness $delta


  #return [expr {$fitness + [llength $joy_prg]}]
  #
  # давай пока длину не учитывать ?!
  # 

  return $fitness
}
#-------------------------------------------------------------------------------
proc FITPROC_01 {p task args} {


  set joy_prg  [item_get_mainsrc $p]

  return [calc_FITPROC_01 $task $joy_prg]
}
#-------------------------------------------------------------------------------
proc _test_seed {pop task adam} {

  set len_chromo [GET $task "len_chromo"]  

  for {set i 0} {$i < $len_chromo} {incr i} {

    item_set_chromo_gen $adam $i  [random_double 1.0]
  }

  return true;
}
# //------------------------------------------------------------------------------
proc _test_step {generation pop} {

  set best [pop_get_entity_ $pop  0]
  
  set best_chromo [item_get_mainsrc $best]
  set best_fit    [item_get_fitn    $best]
  
  #print_one_line  [format "%3d" $generation]  $best_fit $best_chromo

  #puts [format "generation = %3d: best_fit = $best_fit" $generation] 

  #puts ""
  print_one_line  [format "%3d" $generation]  $best_fit $best_chromo
  #puts ""

  
  return true;
}
#-------------------------------------------------------------------------------
#
# t~.tl TEST test_pGP -nums 2 -lpop 10 -seed @
# 
# вероятностное программирование (в программе каждый итем задан словарем 
# с вероятностью)
# 
#-------------------------------------------------------------------------------
proc _test_score {this_entity  task} {


  set len_chromo [GET $task "len_chromo"]  

  set program {}

  for {set i 0} {$i < $len_chromo} {incr i} {

    set X [item_get_chromo_gen $this_entity  $i] 
    
    #puts -nonewline [format "  % 5.3f"  $X]

    set cmd [dict_create  "cmd" p1 "ver" $X]
    lappend program $cmd
  }


  set num_runs    7
  set fitness_sum 0

  for {set i 0} {$i < $num_runs} {incr i} {

    set fitness [calc_FITPROC_01 $task $program]

    #puts "fitness = $fitness"
    incr fitness_sum $fitness
  }

  set fitness [expr {1.0 * $fitness_sum} / $num_runs]

  set fitness [expr {-  $fitness}] 

  #
  # а теперь наоборот должно быть 
  # fit_tobest = MAX, движемся к нулю сдева  : --> 0 
  
  #print_one_line  "--"  $fitness $this_entity

  #puts -nonewline [format "  "]
  #puts -nonewline [format ": fit = % f "  $fitness]
  #puts ""

  #set fitness 0.9
  #puts "_test_score: program = $program, fitness = $fitness"

  return $fitness
}
#-------------------------------------------------------------------------------
proc test_pGP {args} {

  puts ""
  puts "args = $args"
  puts ""

  #global argc argv argv0
  #set argo [lrange $argv 2 end]

  #global argv 
  #set argv [lrange $argv 2 end]

  set argv $args
  
  #argo_print $argo 

  set seed        [dict_parse $argv "-seed" 2016]
  set individuals [dict_parse $argv "-lpop" 10]
  #set len         [dict_parse $argo "-size" 10] 
  set nums        [dict_parse $argv "-nums"  4]
  #set gp_list     [dict_parse $argo "-list" "p1"] ;#  "p1 nop"  "p1 p3" 
  #set auto        [dict_parse $argo "-auto"  0]
  
  set ::sum_target 5 ;# 20


  puts "individuals  = $individuals" ;# колич-во ботов
  #puts "len          = $len"         ;# макс. длина ботов (при начальном старте?)
  puts "nums         = $nums"        ;# шагов эволюции  
  #puts "gp_list      = $gp_list"     ;#   

  puts "::sum_target = $::sum_target" ;# к чему стремимся, что надо получить 
  puts ""

  #exit
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  #set is_print 1
  #DebugOn

  #set pb [mp_create]
  v1_init_all  ;# !!!!!!!!!!! ???

  #mp_init $pb 

  #exit
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  set task_rev [task_create  \
		  -fit_func "_test_score" -fit_tobest "MAX" -isreverse 1 -fit_error 0.001 ]
    
  #global argv
  #set argv [lrange $argv 1 end]

  set len_chromo  9 ;# [dict_parse $argv  "-size" 4]

  SET $task_rev "len_chromo" $len_chromo

  set seed_proc "_test_seed"
  set step_proc "_test_step"

  #set pop [super_de $task_rev $seed_proc $step_proc  {*}$argv -size 9] ;# !!!!!

  set pop [super_ga $task_rev $seed_proc $step_proc   {*}$argv -size 9] ;# !!!!!


  puts ""
  #exit
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  #pop_print $pop

  set best [pop_get_entity_ $pop  0]
  
  set best_chromo [item_get_mainsrc $best]
  set best_fit    [item_get_fitn    $best]

  #set best 0
  
  #set best_entity [pop_get_entity_         $pop  $best]
  #set best_fit    [pop_get_entity_fitness_ $pop  $best]
  
  #set best_chromo [item_get_mainsrc $best_entity]
  
  print_one_line  "Final"  $best_fit $best_chromo
  
  
  return
}
################################################################################
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
proc get_x_list {xmin xmax nums} {

  set x_list {}

  lappend x_list $xmin ;# 1-я точка обязательна


  # делаем внутренни точки в таком количестве
  set in_nums [- $nums 2] 

  # с шагом
  set step [/ [* 1.0 [- $xmax $xmin]] [- $nums 1]]

  for {set i 1} {$i <= $in_nums} {incr i} {

    set x [+ $xmin [* $i $step]]
    lappend x_list $x
  }


  lappend x_list $xmax ;# последняяя точка обязательна

  return $x_list
}
#-------------------------------------------------------------------------------

# 0 - не делаем специально начальеую инициацию для задачи _XX (поиска формулы)
# 1 - кладем сразу начальное значение x в стек несколько раз с запасом
# 
set ::INIT 0  


#-------------------------------------------------------------------------------
proc getresult_prog_val {prog val} {


  v0_set_stack_null ;# и не более того !!!!
  
  # кладем одно значение в стек
  # 
  push $val 

  if {$::INIT} {
    push $val 
    push $val 
    push $val 
    push $val 
    push $val 
    push $val 
    push $val 
    push $val 
  }

  # выполняем программку
  # 
  run_v1_prog $prog

  # забираем одно значение из стека
  # 
  set result [pop]


  return $result
}
#-------------------------------------------------------------------------------
#
# Типичный пример. Выявлем (раскручиваем) программу, вычисляющую квадрат числа.
# Лучшая програма :  "DUP *"
# Лучший фитнес == 2 (нет ошибок для любых входов, длина проги == 2).
#
# r~.tl TEST TEST_xx  -seed 1 -lpop 20 -size 6 -nums -1 -vers ga
# 
#-------------------------------------------------------------------------------
proc FITPROC_xx {prog task args} {

  set is_print [dict_parse $args "-is_print"   0]

  set x_list [get_x_list  0 2  10]

  #puts "x_list = $x_list"
  #exit

  # ???? 
  # 
  #set func [GET $task "func"]
  set joyf [GET $task "joyf"] ;# наверное удобне в консоли задавать строку на JOY

  # начинаем в цикле подсчет фитнеса --------------------------

  #set is_print 0

  if {0} {
    puts stderr ""
    puts stderr "-------------------------------------------------------------------"
    puts stderr ""
    #puts stderr "FITPROC_xx: prg    = $src"
    puts stderr "FITPROC_xx: x_list = $x_list"
    #puts stderr "FITPROC_xx: func   = $func"
    puts stderr "FITPROC_xx: joyf   = $joyf"
    puts stderr ""
  }

  set fitness 0

  set delta_sum 0 ;# будем суммировать отклонения в точках или их квадраты



  foreach x $x_list {

    #---------------------------------------------------------------

    if {0} {
      set real [expr $func] ;# рельное значение для функции в этой точке
    } else {
      #run_v1_src  $joyf     ;# выполнить исходник ??
      set real [v1_get_result_from_one_arg  $joyf $x]
    }


    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    # обнудим стек, выполним программку и возьмем результат (верхний эдемент стека)
    # 
    #set calc [getresult_prog_val  $prog $x] ;# посчитанное

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
    v0_set_stack_null ;# и не более того !!!!
    
    # кладем одно значение в стек
    # 
    push $x 
    
    if {$::INIT} {
      push $x 
      push $x 
      push $x 
      push $x 
      push $x 
    }
    
    # выполняем программку
    # 
    run_v1_prog $prog


    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    # забираем одно значение из стека
    # 
    set calc [pop]


    #---------------------------------------------------------------

    set len [llength $::joy_ST] ;# сколько еще осталось в стеке значений ??

    #puts stderr "::joy_ST = $::joy_ST,  len = $len"
    #puts "calc = $calc"

    #set delta_sum 0 ;# будем суммировать отклонения в точках или их квадраты

    if {$is_print} {
      puts stderr "x = $x, calc = |$calc|, ::joy_ST = |$::joy_ST|"
    }
    #---------------------------------------------------------------
    #

    if {$calc eq {}}  {

      if {$is_print} {
        puts stderr "FITPROC_xx: x = $x, calc eq {} , ERROR operator??"
      }
      # ошибка программы (на первом ошибочном операторе) !!
      # 
      # можно бы попробовать гибкую реакци. на "неверные" операторы программы, т.е.
      # не вываливаться сразу в ошибку, а продолжать выпонять остальные операторы !
      #
      # но пока просто даим не слишком большой штраф, в пределах дельта-ошибок
      
      incr fitness 25 ;# 10 50 150
      #
      # может сразу выходить из цикла по точкам, они же все такие будут?
      break

    } elseif {![string is integer $calc] && ![string is double $calc]} {

      # здесь может быть просто списко или символ-строка, а не число!
      # но пока кроме числе и {ошибки} в стеке ничего не предвидится
      #
      puts "FITPROC_xx: NOT DIGITAL ???? !!!"
      exit

      incr fitness 50 ;# при каждой ошибке добавляем дельту
      # 
      # может сразу выходить из цикла по точкам, они же все такие будут?
      break

    } else {

      #set delta [expr {abs($o-$calc)}] ;# 
      set delta [expr {( $real - $calc ) ** 2 } ] ;# !! может корень из суммы квадратов?

      #if {$delta > 1000} {
      #  # anti overflow ???
      #  set delta 1000
      #}

      set delta_sum [+ $delta_sum $delta]

      if {$is_print} {
        puts stderr "FITPROC_xx: x = $x, real = $real, calc = $calc, delta = $delta, delat_sum = $delta_sum"
      }

      #set fitness [+ $fitness $delta]
    }
    #---------------------------------------------------------------

  }
    
  #set fitness [+ $fitness $delta_sum]
  set fitness [expr {$fitness + sqrt ($delta_sum)}]

  # 1) TODO
  # длину учитывать ? но тогда генетич. разнообразие ухудшается?
  #
  set len [calc_len_prog $prog]

  #set fitness [+ $fitness [* 0.01 $len]]


  # 2) TODO
  # нам не нужны лишние результаты в стеке ? тоже ухудшает? лучше потом преобразовать?
  #
  #incr fitness $len


  #puts stderr "FITPROC_xx, prg = $src, fitness = $fitness"

  return $fitness
}
#-------------------------------------------------------------------------------
# proc fitness_test {task item} {

#   #set task NULL

#   puts "item = $item,  ret = [FITPROC_xx  $item $task -is_print 1] "

# }
#-------------------------------------------------------------------------------
proc func_prepare_from_input {inp} {

  set lis [split $inp]

  set out {}

  foreach l $lis {

    if        {$l == "x"} {
      append out {$x}
    } elseif  {$l == "plus"} {
      append out +
    } elseif  {$l == "minus"} {
      append out -
    } elseif  {$l == "mult"} {
      append out *
    } elseif  {$l == "pow"} {
      append out **
    } else {
      append out $l
    }
  } 

  return $out
}
#-------------------------------------------------------------------------------
proc TEST_xx {args} {

  set argv $args

  puts ""
  puts "TEST_xx $args"
  puts ""

  #------------------------------------------------------

  ## set seed        [dict_parse $argv "-seed"  2013]
  set seed        [dict_parse $argv "-seed"  @] ;# каждый выхов случаен

  set lpop        [dict_parse $argv "-lpop"  10]   ;# колич-во ботов 
  set size        [dict_parse $argv "-size"   6]   ;# макс. длина ботов (при начальном старте?)
  set nums        [dict_parse $argv "-nums"  10]   ;# шагов эволюции 

  set vers        [dict_parse $argv "-vers"  "gp"] ;# по умолчанию 

  set print       [dict_parse $argv "-print"    1]
  set ::is_print  $print

  set fit_func    [dict_parse $argv "-fit_func"    "FITPROC_xx"] 
  set fit_tobest  [dict_parse $argv "-fit_tobest"  "MIN"] 

  #------------------------------------------------------

  set ::INIT  [dict_parse $argv "-init"   0] 

  ;# 0 - не делаем специально начальеую инициацию
  ;# 1 - кладем сразу начальное значение x в стек несколько раз с запасом dup dup dup

  if {$::INIT} {
    set gp_list     [dict_parse $argv "-list"   "* nop +"]
  } else {
    set gp_list     [dict_parse $argv "-list"   "dup * +"]
  }

  #------------------------------------------------------

  #set func        [dict_parse $argv "-func"   {x ** 2 + x}]
  set func        [dict_parse $argv "-func"   {x pow 2 plus x}]
  set func [func_prepare_from_input $func] 

  set joyf        [dict_parse $argv "-joyf"   {dup dup * +}]

  #------------------------------------------------------
  # флажки для новейших алгоритмов
  # 
  # 
  #set ::gp_NEWS      [dict_parse $argv "-news"  $::gp_NEWS]
  #set ::gp_NEWS      [dict_parse $argv "::gp_NEWS"  $::gp_NEWS]

  dict_parse_GLOBAL "::gp_NEWS" $argv
  dict_parse_GLOBAL "::gp_AUTO" $argv

  ##set ::gp_DEEP  [dict_parse $argv "-deep"  $::DEEP]
  dict_parse_GLOBAL "::gp_DEEP" $argv
  

  ios_init_TEST_xx 

  #set ::randinstr   randinstr_MAIN 
  #set ::quotes_proc "make_quotes_BE"
  #set ::quotes_proc "make_quotes_TCL"
  #set ::quotes_proc  "quotes_proc_NULL" 

  #set rand_prgpop_proc "make_rand_prgpop"
  
  #set pb [mp_create]
  v1_init_all  ;# !!!!!!!!!!! ???

  #if {0} {
  #  mp_init $pb \
  #    randinstr    "randinstr_MAIN" \
  #    quotes_proc  "make_quotes_TCL"
  #} else {
  
  # mp_init $pb \
  #   randinstr    "randinstr_MAIN" \
  #   quotes_proc  "quotes_proc_NULL"
  
  #}

  #set ::IOS_begin 1
  #set ::IOS_final 1

  set task [task_create  \
	      -ios_begin 1 -ios_final 1 \
              -fit_func $fit_func  -fit_tobest $fit_tobest \
              -func  $func \
              -joyf  $joyf \
              -gp_list    $gp_list \
             ] 
  
  #------------------------------------------------------
  #
  # задаем начальную "случайность"
  
  if {$seed == "@"} {
    
    set seed [clock seconds]
  }
  
  comm_random_seed $seed 


  #------------------------------------------------------
  # распечатаем начальные значения

  puts "func = $func"
  puts "joyf = $joyf"
  puts "seed = $seed"
  puts "init = $::INIT"
  puts "list = $gp_list"

  #------------------------------------------------------


  if {$vers == "fs"} {
  #------------------------------------------------------
  # r~.tl TEST TEST_xx  -seed 2013 -lpop 30 -nums -1 -vers fs



    #
    # ga_evolution, ищем как обычную строку 

    set gp_list      "dup * nop +"  ;# "1 2 3 4 5 6 7 8 9"
    set ::target_text  "nop dup dup nop nop nop nop * nop + nop nop"
    set size 12

    set fitness_func   "FITPROC_list_FS"
    set fit_target     0    
    # т.е. тоже больше фитнес - лучше, но мы приближаемся сдева к точносу 0 !!
  
    set task_fs [task_create  -fit_func $fitness_func -fit_tobest "MAX" \
                   -fit_target $fit_target \
                   -fit_error  0.01        \
                   -gp_list    $gp_list]  

    #set obj \
      [BOT01 new  -lpop $lpop -lsrc $size -task $task_fs -vers $vers] 


    set pop [pop1_create  -lpop $lpop -lsrc $size -task $task_fs] ;#   -vers $vers 

    #SET $pop  select_one   "ga_select_one_sus"
    #SET $pop  select_two   "ga_select_two_sus"

    #set pop [GET $obj "pop"]


    SET $pop  select_one   "ga_select_one_bestof2"
    SET $pop  select_two   "ga_select_two_bestof2"


    set m [dict merge   {-print  1} $argv]
    puts "m = $m"

    #---------------------------------------------------------
    #
    #
    # r~.tl TEST TEST_xx -seed 2013 -lpop 30 -nums -1 -vers fs 
    #---------------------------------------------------------
    ## proc calc_BOT01 {obj args} {}

    #if {1} {
      
      #set args {*}$m
      set args $m

      ##set pop [GET $obj pop]
      
      SET $pop  seedproc "maintest_seed_proc" ;# ??
      
      #------------------
      
      set task            $task_fs ;# [dict_parse $args "-task"  [GET $obj "task"]] 
      set max_generations [dict_parse $args "-nums"  10] 
      ##set vers            [dict_parse $args "-vers"  [GET $obj "vers"]]
      
      #puts stderr ""
      #puts stderr "calc_BOT01: args = $args" 
      #puts stderr "calc_BOT01: nums = $max_generations"  ;# шагов эволюции  
      #puts stderr "calc_BOT01: vers = $vers"  
      #task_print $task  
      puts stderr ""
      
      ##set  pop [GET $obj "pop"]
      # 
      SET $pop "generation" 0
      SET $pop "itemlist"   {}
      
      #puts "[procname]: task = [set $task]"
      # exit
      
      set ret [ga_evolution  $task $pop  $max_generations  {*}$args]
      
      ##return $ret

    #} else {
    #
    #  set ret [calc_BOT01 $obj {*}$m]
    #}

   
  #------------------------------------------------------
  }
  if {$vers == "gp"} {

  #------------------------------------------------------
  #
  # запускаем эволюцию GP напрямую, через функцию

    run_gp_evolution_for_task $task $seed  \
      -lpop $lpop  -size $size -nums $nums \

#      $lpop $size $nums  \
    # -printproc 0 \
    #                           -mutprob         0.2

    # -> calc_BOT33 -> gp_evolution_main ->

    puts ""
    puts "===================================================================="

  #------------------------------------------------------
  } 
  if {$vers == "ga"} {
  #------------------------------------------------------
    ## proc calc_BOT01 {obj args} {}
    
    #set ::is_print $print
    
    #set obj_ga \
      [BOT01 new  -lpop $lpop -lsrc $size -task $task -vers $vers] 
    
      set pop [pop1_create  -lpop $lpop -lsrc $size -task $task] ;#  -vers $vers 

    SET $pop  select_one   "ga_select_one_sus"
    SET $pop  select_two   "ga_select_two_sus"


    #set pop [GET $obj_ga "pop"]
    
    # только эти функции выбора работают для GP!
    # но вот в этом, наверное и есть ошибка, почему здесь получается хуже мутация
    # чем в BOT01 для поиска строк
    
    SET $pop  select_one   "ga_select_one_bestof2"
    SET $pop  select_two   "ga_select_two_bestof2"    
         
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    # r~.tl TEST TEST_xx  -seed 2013 -lpop 10 -size 6 -nums 10 -vers ga


    #if {1} {
      set args [list -nums $nums   -print 1]

      ##set pop [GET $obj pop]
      
      SET $pop  seedproc "maintest_seed_proc" ;# ??
      
      #------------------
      
      ##set task            $task_fs ;# [dict_parse $args "-task"  [GET $obj "task"]] 
      set max_generations [dict_parse $args "-nums"  10] 
      ##set vers            [dict_parse $args "-vers"  [GET $obj "vers"]]
      
      puts stderr ""
      
      ##set  pop [GET $obj "pop"]
      # 
      SET $pop "generation" 0
      SET $pop "itemlist"   {}
      
      #puts "[procname]: task = [set $task]"
      # exit
      
      set ret [ga_evolution  $task $pop  $max_generations  {*}$args]
      
      ##return $ret

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    #} else {

      ##set ret [calc_BOT01 $obj {*}$m]

    #  calc_BOT01 $obj_ga  -nums $nums   -print 1
    #}
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`



  #------------------------------------------------------
  } 
  if {$vers == "ga_gp"} {
  #------------------------------------------------------
    
    #
    # а теперь запустим "соревнование" ???????????????/
    
    set obj_gp [BOT33 new   -lpop $lpop -lsrc $size \
                -task $task -print $print]

   
    set botobjs [dict_create] 
  
    dict_set $botobjs "BOT33" $obj_gp

    set num_text 1
    set num_runs [dict_parse $argv "-runs" 1]

    maintest_run  $botobjs  "task_correct_gp" $num_text $num_runs  $nums  
   
  #------------------------------------------------------
  } 
  #------------------------------------------------------
  
  
  return
}
#-------------------------------------------------------------------------------
#
# r~.tl TEST TEST_xx -nums -1 -news 1 -func 'x pow 3 plus x' -print 1
# r~.tl TEST TEST_xx -nums  5 -news 1 -func 'x pow 3 plus x' -print 1 -seed 13 -auto 1
#
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#
# соревнование-тест (пока с одним участником)

# О.Г. Монахов, Э.А.Монахова, 2017
#
# Параллельный алгоритм 
# многовариантного эволюционного синтеза нелинейных моделей
#

# x^3 + x^2      :  dup dup dup * + * 
# x^3 + x^2 + x  :  dup dup dup dup * nop + * + 

#
# TODO:

#   этот примитивный генетичекий алгоритм очень плохо сходится. нужно делать 
#   рефакторинг, 
#   выделение блоков и статистику по расположению этих блоков относительно друг 
#   друга 
#   (.е. это уже начальное понятие типа данных), а также об их эффективном 
#   вкладе в результат..
#  
#  

# упростил пока (сразу заношу в стек X несколько раз (dup dup dup dup dup dup)

# l~.tl TEST TEST_xx  -seed @ -lpop 20 -size 20 -nums -1 -news 1 -list "* +" -print 2 -func 'x ** 3 + x ** 2 + x' 

# Test1:  x ** 4 + x ** 3 + x ** 2 + x       =  * + * + * +

#         sin ( x ** 2 + x      )            =  * + sin      
#         sin ( x ** 2 + x ** 2 )            =  + * sin      
#         sin ( x ** 2 + x ** 3 )            =  * + * sin      
# Test2:  sin ( x ** 2 + x ** 4 )            =  * * + * sin

# Test3:  sin (exp(sin(exp(sin(x)))))        =  
# Test4:  sin (x ** 3) + exp (x)             =  
# Test5:  sin (2 * x) + 1/(x ** 2) - x ** 3  =  
# Test6:  (x + 2) / exp (a * x - 5)          =  

#-------------------------------------------------------------------------------

# r~.tl TEST TEST_xx  -seed 1 -lpop 20 -size 6 -nums -1 -vers ga    
# r~.tl TEST TEST_xx  -seed 1 -lpop 20 -size 6 -nums -1 -vers gp    
  
# OUT:
# r~.tl TEST TEST_xx  -seed    0 -lpop  5 -size 6 -nums -1 -vers gp -print 2 
# r~.tl TEST TEST_xx  -seed 2013 -lpop 10 -size 6 -nums 10 -vers gp

################################################################################
#-------------------------------------------------------------------------------
proc NEXT_01 {args} {

  set argo $args
  
  argo_print $argo 

  set seed        [dict_parse $argo "-seed"  @]
  set individuals [dict_parse $argo "-lpop" 10]
  set len         [dict_parse $argo "-size" 10] 
  set nums        [dict_parse $argo "-nums"  4]
  set ::is_print  [dict_parse $argo "-print" 1] 
  set gp_list     [dict_parse $argo "-list" "p1"] ;#  "p1 nop"  "p1 p3" 

  set tclinit     [dict_parse $argo "-tcl"  ""]

  eval $tclinit

  puts "tclinit = $tclinit"
  puts "nums = $nums"
  puts ""
  #exit
    
  # флажки для новейших алгоритмов
  # 
  # 
  #set ::gp_NEWS      [dict_parse $argo "-news"  $::gp_NEWS]
  #set ::gp_NEWS      [dict_parse $argo "::gp_NEWS"  $::gp_NEWS]

  dict_parse_GLOBAL "::gp_NEWS" $argo
  dict_parse_GLOBAL "::gp_AUTO" $argo

  #set ::AUTO      [dict_parse $argo "-auto"  $::AUTO]
  

  # TODO 
  # - автоматическое добавление этих параметров и их динамическая корректировка
  # - более гибкое задание вариантов алгоритмов и их параметров? -algo ??

  ios_add_new  p1  {} {}
  ios_add_new  p3  {} {}
  ios_add_new  p5  {} {}
  ios_add_new  m1  {} {}

  #set ::IOS_begin 0
  #set ::IOS_final 0

  # r~.tl TEST NEXT_01 -seed 2016
  # r~.tl TEST NEXT_01 -nums -1 -seed @ -target 5 -news 1 -list "p1 p3 m1" -print 2

  #------------------------------------------------------

  set ::sum_target [dict_parse $argo "-target" 20]

  puts "individuals  = $individuals" ;# колич-во ботов
  puts "len          = $len"         ;# макс. длина ботов (при начальном старте?)
  puts "nums         = $nums"        ;# шагов эволюции  
  puts "gp_list      = $gp_list"     ;#   

  puts "::sum_target = $::sum_target" ;# к чему стремимся, что надо получить 
  puts ""

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  set is_print 1
  #DebugOn

  set task [task_create  \
              -fit_func  FITPROC_01_NEW  -fit_tobest  "MIN" -fit_target  0  \
              -gp_list     $gp_list]

#              -fit_target  $::sum_target \
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ## l~.tl TEST NEXT_01 -seed @ -lpop 10 -size 1 -nums -1 -list "p1 p3 p5"
  ## touch l:l~.tl,TEST,NEXT_01,-seed,123,-lpop,10,-size,1,-nums,-1,
  ##                                            -list,\{,p1,p3,p5,\}

  puts stderr  "nums = $nums !!"
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  #set pb [mp_create]
  v1_init_all  ;# !!!!!!!!!!! ???
  #mp_init $pb 

  #set rand_prgpop_proc "make_rand_prgpop" ;# "make_rand_prgpop_unikum"

  
  run_gp_evolution_for_task    \
      $task                    \
      $seed \
      -lpop $individuals  -size $len  -nums $nums \
      {*}$argo                 \

  # -print        $is_print  \
  # -mutprob          0.1    \
  #     -printproc  0      \
  

  #puts "!!!!!11"
  #gp_dict_print 

  return
}

################################################################################

# TODO: на простейшей "программы" отладить все механмзмы
#       SP - статистического программирования

# r~.tl TEST NEXT_01 -seed @ -lpop 5 -size 2 -nums 3 -list "p1 p3 p5" -print 2 -auto 0


# r~.tl ANTS ANTS_gp 2012  10 15 2
# r~.tl TEST TEST_pp 2014

# r~.tl TEST NEXT_01 -nums -1 -target 10 -list "p1 p3" -size 10 -print 2
# r~.tl TEST NEXT_01 -nums -1 -target 10 -list "p1 p3" -size  2 -print 1 -news 1

# r~.tl TEST NEXT_01 -seed 2016 -lpop 10 -size 10 -nums  4
# r~.tl TEST NEXT_01 -seed    @ -lpop 10 -size  1 -nums -1
# r~.tl TEST NEXT_01 -seed 2020 -lpop 10 -size  1 -nums  5 

# r~.tl TEST NEXT_01 -seed @ -lpop 10 -size 1 -nums -1 -list "p1 p3 p5" -auto 1

###########################################################################################
