
> FATAL ERROR: This entity already contains no chromosomes.
> in TclObj_chromosome_destructor at "g-chro.cc" line 74


#-------------------------------------------------------------------------------

- GENA      : простой генетический алгоритм, доделать его функционал и 
              верифицировать на тестах по поиску минимума стандартных функций;

- тесты симулирующий задачу по оптимзации подключений к модулям ШСК (независимые гены): 

  1) дано   : список из 54*3  трехзначных числел (112 304 .. 561 144)
     сделать: переставить числа группируя по мудулям (второй вариант - сортируя)
     использовать: 3-х генную схему, 1-генную;

  2) дано   : два список по 54*3  трехзначных числел (т.е. для двух подсетей)
     сделать: для каждой подсети как в пункте 1)
     использовать: 2-х генную схему (для каждой подсети)?

#-------------------------------------------------------------------------------
# функция создания начальной популяции (передается в расчет)
#-------------------------------------------------------------------------------

# set seed_body_2 [list        \
#                              \
#   set seed [genrand 100 10]  \
#                              \
#   return \$seed              \
#                ]

# можно здесь формировать тело процедуры динамически с уже готовой константой ?
# или просто переопределить процедуру ..
# 

##puts "[subst $seed_body_1]"
#puts "$seed_body_2"

#proc seed {name entity} $seed_body_2

#-------------------------------------------------------------------------------
# Constructing Procedures Dynamically
# Динамическое формирование процедур (стр. 222)
#
# Сделать это достаточно трудно, поскольку тело процедуры нельзя представить в
# виде простого списка. Тело процедуры - это последовательность команд, разделенных
# символами перевода строки или точками с запятой; каждая из этих команд
# является списком. Ряд команд в составе процедуры - это команды условного перехода
# или  циклы, которые сами содержат тело команды.
# Задача динамического формирования процедуры услажняется тем, что при ее решении
# применяются два типа переменных: один из них используются для создания тела
# процедуры, а переменные другого типа используются при выполнении процедуры..
# Для обработки шаблона динамически генерируемой процедуры используется команда
# format либо regsub ..
#-------------------------------------------------------------------------------
#
# загружаем библиотеку и вызываем инициализирующую процедуру
# 

#eval exec {export LD_LIBRARY_PATH=./T:$LD_LIBRARY_PATH}
# puts "LD_LIBRARY_PATH = $env(LD_LIBRARY_PATH)"
# puts ""
# set env(LD_LIBRARY_PATH) "[pwd]/T:$env(LD_LIBRARY_PATH)"
# puts ""
# puts "LD_LIBRARY_PATH = $env(LD_LIBRARY_PATH)"

#-------------------------------------------------------------------------------
