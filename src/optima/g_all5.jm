# -*-   mode: tcl  ; coding: koi8   -*- ----------------------------------------

#!/bin/sh
# \
exec jimsh "$0" ${1+"$@"}

#-------------------------------------------------------------------------------

#source "g_all5.tl"

#-------------------------------------------------------------------------------
# Josef Knecht @ Copyright 
#-------------------------------------------------------------------------------

set COMPOT "./COMPOT"

set auto_path [linsert $auto_path 0 $COMPOT]

set auto_path [linsert $auto_path 0 $COMPOT/src/common] ;# for JIM

#------------------------------------------

package require compot::common 

# package require tcltest

#------------------------------------------

# expected integer but got ""
#     while executing
# "incr [VGET $p size] 1"

#------------------------------------------

# source "b-com0.tl"
# source "b-com1.tl"


#source "f-rand.tl"

source "g-corE.tl"

#source "ga_de.tl"

#-------------------------------------------------------------------------------
# //  Score solution (Normalised RMSD deviation from values
# //  of '5' for all parameters).
# //------------------------------------------------------------------------------
# static boolean 
# all5s_score (population *pop, entity *entity)
# //------------------------------------------------------------------------------
proc all5s_score {item task}  {

  set len [item_get_chromo_len $item] 

  set fitness 0
  
  #   // Loop over alleles in chromosome
  #   // 
  
  for {set k 0} {$k < $len} {incr k} \
  {

    set   allele [item_get_chromo_gen $item  $k]
    incr fitness [expr {(5 - $allele) * (5 - $allele)}]
  }
  
  set fitness [expr {sqrt ($fitness)}]
  #
  # т.е. чем меньше тем лучше, стремясь к нулю !
  
  #   // Normalize fitness so larger positive values are better
  #   //
  set fitness [expr  {1.0 / (1.0 + $fitness)}]

  # а теперь чем больше, тем лучше стремясь 0 -> 1

  item_set_fitn  $item $fitness 

  return $fitness
}
# //------------------------------------------------------------------------------
# // Entity initialisation.

# static boolean 
# all5s_seed (population *pop, entity *entity)

# //------------------------------------------------------------------------------
proc all5s_seed {pop entity} \
{
  # int  point; /* Index of allele to seed */
  
  set maxint 11
  #set maxint 19

  for {set point 0} {$point < [GET $pop len_chromosomes]} {incr point} \
  {
    item_set_chromo_gen $entity  $point [random_int $maxint]

    #$entity configure -ch_form " %02d"
    # БУДЕМ ЗАДАВАТЬ ЭТОТ параметр при создании, т.е. ga_entity_setup
  }
  
  return true
}
# //------------------------------------------------------------------------------
# // Mutation of a single parameter with wrapping 0<->10.
# //------------------------------------------------------------------------------
# static void 
# all5s_mutate (population *pop, entity *father, entity *son)

# //------------------------------------------------------------------------------
proc all5s_mutate {pop father son}  {

  #   int   i;                             /* Loop variable over all chromosomes */
  #   int   point;                         /* Index of allele to mutate          */
  #   int   dir = random_boolean()?-1:1;   /* The direction of drift.            */
  
  if {[random_boolean]} {
    set dir -1
  } else {
    set dir  1
  }

  #puts -nonewline stderr "  all5s_mutate : dir = $dir"

  #   // Sanity check
  #   // 
  #   if (!father || !son)
  #     die ("Null pointer to entity structure passed");
  
  set len_chromosomes [GET $pop len_chromosomes]

  #   // Select mutation locus
  #   // 
  set point [random_int $len_chromosomes]
  
  #   // Copy genome from father
  #   // 
  #   for (i=0; i<pop->len_chromosomes; i++)
  #     ((int *)son->CH)[i] = ((int *)father->CH)[i];
  
  #set son_CH [$father get_chromosome]
  set son_CH [item_get_mainsrc $father]

  #   //
  #   // Mutate by tweaking a single allele.
  #   //
  #   ((int *)son->CH)[point] += dir;

  set  gen [lindex $son_CH $point]
  incr gen $dir
  
  #puts stderr "  point = $point  gen = $gen"

  #   if      (((int *) son->CH)[point] > 10)
  #     ((int *) son->CH)[point] = 0;
  #
  #   else if (((int *) son->CH)[point] < 0)
  #     ((int *) son->CH)[point] = 10;

  if       {$gen > 10} {
    set gen 0
  } elseif {$gen <  0} {
    set gen 10
  }

  lset son_CH $point $gen ;# смутировали хромосому-список

  item_set_mainsrc $son $son_CH ;# и записали ее в сына

  return
}
# //------------------------------------------------------------------------------
# //------------------------------------------------------------------------------
# //  all5s.c

# //		This searches for a set of values all equalling '5', 
# //		with allowed bounds of 0 to 10 inclusive as imposed
# //		by custom chromosomes.

# //		It is an example to demonstrate how to impose bounds
# //		on the chromosome values by using custom seed and
# //		mutation operator functions.  Compare this to the
# //		accompanying all5s_allele_ranges.c

# //------------------------------------------------------------------------------
proc _1_main {} \
{

  #   population  *pop = NULL;	      /* Population of solutions.               */
  #   char        *beststring = NULL; /* Human readable form of best solution.  */
  #   size_t       beststrlen = 0;    /* Length of beststring.                  */
  
  
  set len_chromo      ""
  set population_size ""
  set max_generations ""
  
  
  parse_opts_3  len_chromo population_size max_generations 100 200 250
  
  random_seed  20092004
  
  #   pop = ga_genesis_integer (
  #      population_size,	/* const int              population_size      */
  #      1,		        /* const int              num_chromo           */
  #      len_chromo,		/* const int              len_chromo           */
  #      NULL,			/* GAgeneration_hook      generation_hook      */
  #      NULL,			/* GAiteration_hook       iteration_hook       */
  #      NULL,			/* GAdata_destructor      data_destructor      */
  #      NULL,			/* GAdata_ref_incrementor data_ref_incrementor */
  #      all5s_score,		/* GAevaluate             evaluate             */
  #      all5s_seed,		/* GAseed                 seed                 */
  #      NULL,			/* GAadapt                adapt                */
  #      ga_select_one_sus,	/* GAselect_one           select_one           */
  #      ga_select_two_sus,	/* GAselect_two           select_two           */
  #      all5s_mutate,		/* GAmutate               mutate               */
  #      ga_crossover_integer_singlepoints, /* GAcrossover    crossover        */
  #      NULL,			/* GAreplace	  	  replace              */
  #      NULL			/* vpointer		  User data            */
  #      );
  
  set task [task_create "all5s_score" -fit_tobest "MAX" -fit_target 1]

  set pop [ga_genesis_main   \
	     $task \
             $population_size    \
             1		        \
             $len_chromo	        \
             NULL               \
             NULL               \
             NULL               \
             NULL               \
             all5s_seed         \
             NULL               \
             ga_select_one_sus	\
             ga_select_two_sus	\
             all5s_mutate       \
             ga_crossover_integer_singlepoints  \
             NULL               \
             NULL               \
          ]
  

  SET $pop "ch_form" " %02d" ;# 

  #   ga_population_set_parameters (
  #      pop,			/* population                 *pop */
  #      GA_SCHEME_DARWIN,	/* const ga_scheme_type     scheme */
  #      GA_ELITISM_PARENTS_SURVIVE,/* const ga_elitism_type   elitism */
  #      0.8,			/* double		 crossover */
  #      0.05,			/* double		  mutation */
  #      0.0              	/* double		 migration */
  #      );
  
  #puts stderr ".... 3"

  ga_population_set_parameters                            \
                               $pop	                  \
                               GA_SCHEME_DARWIN	          \
                               GA_ELITISM_PARENTS_SURVIVE \
                               0.8			  \
                               0.05			  \
                               0.0      	          


  if {$::is_print} {
    # пока здесь остановимся, осмотримся и распечатаемся:
    # (похоже инициация-seed еще не выполнялась ?) давай пока тут выполним:
    #
    ga_population_seed $pop  
    #
    $pop print
  }


  ga_evolution  $task $pop $max_generations   

  #$pop print

  #   // Display final solution
  #   // 
  puts "The final solution was:"
  #   beststring = ga_chromosome_integer_to_string (pop, ga_get_entity_from_rank(pop,0), 
  #                                                 beststring, &beststrlen);

  set best_entity [ga_get_entity_from_rank $pop 0]
  set beststring [item_get_mainsrc $best_entity]

  puts $beststring

  puts [format "With score = %f" [item_get_fitn $best_entity]]
  
  return 1
}
# //------------------------------------------------------------------------------
# // 
# //  all5s_allele_ranges.c
# //
# //		This searches for a set of values all equalling '5', 
# //		with allowed bounds of 0 to 10 inclusive, using
# //		built-in features only.
# //
# //		This example demonstrates the
# //		ga_population_set_allele_min_integer() and
# //		ga_population_set_allele_max_integer() functions.
# // 
#-------------------------------------------------------------------------------


# //------------------------------------------------------------------------------
proc _2_main {} \
{

  #set mut [MUTATE new]

  #SET $mut "param" 1
  #puts "mutate param = [GET $mut param]"

  #--------------------------

  set len_chromo      ""
  set population_size ""
  set max_generations ""
  
  parse_opts_3  len_chromo population_size max_generations 100 200 250

  random_seed  20092004

  set task [task_create "all5s_score" -fit_tobest "MAX" -fit_target 1]

  set pop [ga_genesis_main   \
	     $task \
             $population_size   \
             1		        \
             $len_chromo	\
             NULL               \
             NULL               \
             NULL               \
             NULL               \
             ga_seed_integer_random \
             NULL               \
             ga_select_one_sus	\
             ga_select_two_sus	\
             ga_mutate_integer_singlepoint_drift \
             ga_crossover_integer_singlepoints   \
             NULL               \
             NULL               \
          ]

  SET $pop  allele_min_integer 0
  SET $pop  allele_max_integer 10

  SET $pop "ch_form" " %02d" ;# 

  set crossover 0.8
  set mutation  0.05
  set migration 0.0

  ga_population_set_parameters                            \
                               $pop	                  \
                               GA_SCHEME_DARWIN	          \
                               GA_ELITISM_PARENTS_SURVIVE \
                               $crossover $mutation $migration  	          
  
  ga_evolution  $task $pop $max_generations   

  #$pop print

  puts "The final solution was:"

  set best_entity [ga_get_entity_from_rank $pop 0]
  set beststring [item_get_mainsrc $best_entity]

  puts $beststring

  puts [format "With score = %f" [item_get_fitn $best_entity]]
    
  return 1
}
# //******************************************************************************
# //------------------------------------------------------------------------------
proc main {}  {

  #set ::NEWEST 1 ;# !!!!!!!!!!!!!!!!!!! OK !!!!

  global argc argv argv0

  puts ""
  
  #   if (argc < 2 ) 
  #     exit (EXIT_SUCCESS);
  
  set mode [lindex $argv 0] ;# имя выч. задачи
  
  #   if      (! strcmp (mode, "_1")) _1_main (argc, argv);
  #   else if (! strcmp (mode, "_2")) _2_main (argc, argv); 
  #   else {
  #     printf ("\n");
  #     printf ("ERROR mode = %s \n", mode);
  #     printf ("\n");
  #   }
  
  if     {$mode == "_1"}     { _1_main } \
  elseif {$mode == "_2"}     { _2_main } \
  elseif {$mode == "_NEWEST"} { 
    set ::NEWEST 1
    _1_main 
  } \
  \
  else {
    puts ""
    puts "ERROR mode = $mode"
    puts ""
  }

  puts ""
  
}
# //-----------------------------------------------------------------------------

# g_all5.tl _1       11 10 10
# g_all5.tl _NEWEST  11 10 10

# //-----------------------------------------------------------------------------

main

# //-----------------------------------------------------------------------------
# //------------------------------------------------------------------------------
# ******************************************************************************
