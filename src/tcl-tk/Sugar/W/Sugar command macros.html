<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='Tclers wiki'>
<meta name='author' content=''>
<link rel='icon' href='/img/favicon.ico'>
<title>Sugar command macros</title>

<link rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'>
<link rel='stylesheet' href='/css/nikit.css' type='text/css'>
<link rel='stylesheet' href='/css/sh_style.css' type='text/css'>
<link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.31.0/css/theme.bootstrap_3.min.css' type='text/css'>
<script src='//cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js'></script>
</head>
<body onload='sh_highlightDocument(); nikitUser();'>
<nav class='navbar navbar-fixed-top navbar-inverse'>
<div class='container'>
<div class='navbar-header'>
<button type='button' class='navbar-toggle' data-toggle='collapse' data-target='#myNavbar'>
<span class='icon-bar'></span>
<span class='icon-bar'></span>
<span class='icon-bar'></span>
</button>
<ul class='nav navbar-nav'>
<li class='dropdown'>
<a class='dropdown-toggle' data-toggle='dropdown' href='#'>&nbsp;Tcler&#39;s Wiki<span class='caret'></span></a>
<ul class='dropdown-menu scrollable-menu' role='menu'><li><a href='/welcome'>Home</a></li>
<li><a rel='nofollow' href='/recent'>Changes</a></li>
<li><a rel='nofollow' href='/_random'>Random page</a></li>
<li><a rel='nofollow' href='/_new'>New page</a></li>
</ul>
</li>
</ul>
</div>
<div class='collapse navbar-collapse' id='myNavbar'>
<ul class='nav navbar-nav'>
<li class='dropdown' id='li_idPageEdit' style='display:none'>
<a class='dropdown-toggle' data-toggle='dropdown' href='#'><span id=name_idPageEdit>Page</span><span class='caret'></span></a>
<ul class='dropdown-menu scrollable-menu' role='menu'><li><a rel='nofollow' href='/_edit/Sugar+command+macros?A=1'>Comment</a></li>
<li><a rel='nofollow' hidden='true' href='/_edit/Sugar+command+macros'>Edit</a></li>
<li><a rel='nofollow' href='/_upload/Sugar+command+macros'>Upload</a></li>
<li><a rel='nofollow' href='/ref/Sugar+command+macros'>References</a></li>
<li><a rel='nofollow' href='/history/Sugar+command+macros'>History</a></li>
<li><hr></li>
<li><a href='#972c74412158887fef0c8be6926be40bba89e58fa905a9159cf754d77023980a'>&nbsp;&nbsp;&nbsp; NOTE </a>
</li>
</ul>
</li>
<li class='dropdown' id='li_idPageNoEdit' style='display:none'>
<a class='dropdown-toggle' data-toggle='dropdown' href='#'><span id=name_idPageNoEdit>Page</span><span class='caret'></span></a>
<ul class='dropdown-menu scrollable-menu' role='menu'><li><a rel='nofollow' href='/ref/Sugar+command+macros'>References</a></li>
<li><a rel='nofollow' href='/history/Sugar+command+macros'>History</a></li>
<li><hr></li>
<li><a href='#972c74412158887fef0c8be6926be40bba89e58fa905a9159cf754d77023980a'>&nbsp;&nbsp;&nbsp; NOTE </a>
</li>
</ul>
</li>
<li><a href="/page/Tcl+Tutorial+Lesson+0">Tutorial</a></li>
<li><a href="/page/Articles">Articles</a></li>
<li class='dropdown'>
<a class='dropdown-toggle' data-toggle='dropdown' href='#'>&nbsp;Help<span class='caret'></span></a>
<ul class='dropdown-menu scrollable-menu' role='menu'><li><a rel='nofollow' href='/page/Help'>Page Markup</a></li>
<li><a rel='nofollow' href='/page/How+do+Wiki+Categories+work'>Wiki Categories</a></li>
<li><a rel='nofollow' href='/page/Contents'>Topics</a></li>
<li><a rel='nofollow' target='_blank' href='https://chiselapp.com/user/stevel/repository/nikit/ticket'>Report Problems</a></li>
<li><a rel='nofollow' href='/privacy'>Privacy</a></li>
<li><a rel='nofollow' href='/license'>License</a></li>
</ul>
</li>
</ul>
<ul class='nav navbar-nav navbar-right'>
<li class='dropdown'>
<a class='dropdown-toggle' data-toggle='dropdown' href='#'><span id=name_SMenu>User</span><span class='caret'></span></a>
<ul class='dropdown-menu' id='ul_SMenu'>
</ul>
</li>
</ul>
<form class='navbar-form navbar-right' method='post' action='/search' id='searchform'>
<input name='Q' type='text' class='form-control' placeholder='Search...' />
<input type="hidden" name="sites" value="wiki.tcl-lang.org" />
</form>
</div>
</div>
</nav>
<div class='container'>
<div class='row'>
<div class='col-xs-12'>
<h2>Sugar command macros</h2>
</div>
</div>
<div class='row'>
<div class='col-xs-12'>
<h3 id='972c74412158887fef0c8be6926be40bba89e58fa905a9159cf754d77023980a' class='mkup_h2'> NOTE </h3><pre class='mkup_pre'> The API changed in two ways, you should be aware of this if you want to try with the current release of
 sugar what is shown in this tutorial.

 First Change - Now macros are expanded only inside procedures defined with ::sugar::proc
 Second Change - Now macros get a list of arguments like normal procedures, but the first argument is
                 the macro name itself. All the macros in this tutorial will work substituting the 'argv'
                 argument with 'args'.</pre><UL class='mkup_UL'><li class='mkup_li'>Section 0 - <b class='mkup_b'><a class='mkup_a mkup_known' href='/page/Sugar'>Sugar</a></b></li><li class='mkup_li'>Section 1 - <b class='mkup_b'><a class='mkup_a mkup_known' href='/page/Sugar+command+macros'>Sugar command macros</a></b> (what you are reading)</li><li class='mkup_li'>Section 2 - <b class='mkup_b'><a class='mkup_a mkup_known' href='/page/Sugar+syntax+macros'>Sugar syntax macros</a></b></li><li class='mkup_li'>Section 3 - <b class='mkup_b'><a class='mkup_a mkup_known' href='/page/Sugar+transformers'>Sugar transformers</a></b></li></UL><p class='mkup_p'><b class='mkup_b'>What is a Tcl macro</b>.</p><p class='mkup_p'>A macro is an operator implemented by transformation. Macros are procedures that generate a Tcl program at compile time, and substitute it where the programmer used their name as command.</p><p class='mkup_p'>It's a simple concept if explained by examples.</p><p class='mkup_p'>Suppose you want to write a <span class='mkup_tt'>clear</span> command that sets the <i class='mkup_i'>varName</i> to a null string. It could be Implemented using <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/upvar'>upvar</a></span>, like this:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_0' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_0' class='sh_tcl sh_sourceCode'>proc clear varName {
    upvar 1 $varName var
    set var {}
}</pre></div><p class='mkup_p'>Every time the user type</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_1' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_1' class='sh_tcl sh_sourceCode'>clear myvar</pre></div><p class='mkup_p'>When <span class='mkup_tt'>clear</span> is called, the <span class='mkup_tt'>$myvar</span> of the caller is set to to the <a class='mkup_a mkup_known' href='/page/empty+string'>empty string</a>.</p><p class='mkup_p'>As an alternative to call a procedure that is able to alter the caller's execution environment, we may want to automatically substitute every occurrence of the command <span class='mkup_tt'>clear varname</span> with <span class='mkup_tt'>set varname {}</span>.</p><p class='mkup_p'>So basically we want that when we write</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_2' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_2' class='sh_tcl sh_sourceCode'>clear myvar</pre></div><p class='mkup_p'>in a program, it is substitute with</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_3' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_3' class='sh_tcl sh_sourceCode'>set myvar {}</pre></div><p class='mkup_p'>as if the programmer had really typed <span class='mkup_tt'>set myvar {}</span> instead of <span class='mkup_tt'>clear myvar</span>. That's the goal of the simplest form of a <a class='mkup_a mkup_known' href='/page/Sugar'>Sugar</a>'s macro.</p><p class='mkup_p'>The definition of a new macro is very similar to the creation of a procedure. The following is the implementation of [clear] as a macro:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_4' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_4' class='sh_tcl sh_sourceCode'>sugar::macro clear argv {
    list set [lindex $argv 1] {{}}
}</pre></div><p class='mkup_p'>It means: &quot;If you encounter a command called <span class='mkup_tt'>clear</span> inside the source code, call the following procedure putting all the parts of which the command is composed in <span class='mkup_tt'>$argv</span>, and substitute the occurrence of the clear command and arguments, with what the procedure will return.&quot;</p><p class='mkup_p'>Again, with other words:</p><p class='mkup_p'>So, what happens is that when a procedure is compiled, for every occurrence of the <span class='mkup_tt'>clear</span> command inside the procedure, the above procedure is called, with <span class='mkup_tt'>$argv</span> set to a list that represents the arguments used to call the macro (including the macro name itself as first argument). The result value of the function, that should be a list of the same form, is substituted in place of the original macro call.</p><p class='mkup_p'>To make the example more concrete, see the following code:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_5' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_5' class='sh_tcl sh_sourceCode'>proc foobar {
    set x 10
    clear x
}</pre></div><p class='mkup_p'><b class='mkup_b'>Before compiling the procedure</b>, Tcl will call the <span class='mkup_tt'>clear</span> procedure with <span class='mkup_tt'>$argv</span> set to <span class='mkup_tt'>clear x</span>. That procedure returns <span class='mkup_tt'>set x {{}}</span>, This return value will be substituted in place of &quot;clear x&quot;.</p><p class='mkup_p'>After the proc was defined, we can use <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/info+body'>info body</a></span> to see what happened:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_6' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_6' class='sh_tcl sh_sourceCode'>info body proc</pre></div><p class='mkup_p'>will output</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_7' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_7' class='sh_tcl sh_sourceCode'>set x 10
set x {}</pre></div><p class='mkup_p'><span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/Sugar'>Sugar</a></span> makes it possible to use a macro like <span class='mkup_tt'>clear</span> as if it it was a Tcl procedure, and the macro is called at compile time to produce the procedure that replaces it.</p><p class='mkup_p'>But Tcl has <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/uplevel'>uplevel</a></span> and <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/upvar'>upvar</a></span>, so what are macros useful for? Fortunately they allow for many interesting things not possible at all otherwise. The following example shows the first big advantage of macros:</p><p class='mkup_p'><b class='mkup_b'>1) Macros makes Tcl faster, without forcing the user to inline code by hand.</b></p><p class='mkup_p'>When <span class='mkup_tt'>clear</span> is implemented as macro, it runs 3 times faster in my Tcl 8.4.</p><p class='mkup_p'>Also, <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/upvar'>upvar</a></span> is one of the biggest obstacles to the ability of the Tcl compiler to optimize Tcl <a class='mkup_a mkup_known' href='/page/bytecode'>bytecode</a>, it's not impossible that at some point Tcl will be able to run much faster if the user will ensure a given procedure is never the target of <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/upvar'>upvar</a></span>.</p><p class='mkup_p'>Simple commands that involve the use of <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/upvar'>upvar</a></span> can be even more simple to write as macros. The following are four examples:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_8' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_8' class='sh_tcl sh_sourceCode'># [first $list] - expands to [lindex $list 0]
sugar::macro first argv {
    list lindex [lindex $argv 1] 0
}

# [rest $list] - expands to [lrange $list 1 end]
sugar::macro rest argv {
    list lrange [lindex $argv 1] 1 end
}

# [last $list] - expands to [lindex $list end]
sugar::macro last argv {
    list lindex [lindex $argv 1] end
}

# [drop $list] - expands to [lrange $list 0 end-1]
sugar::macro drop argv {
    list lrange [lindex $argv 1] 0 end-1
}</pre></div><p class='mkup_p'><a class='mkup_a mkup_known' href='/page/Sugar'>Sugar</a> supports three types of macros. We are dealing with the simplest and more common macros: command macros.</p><p class='mkup_p'>The other two types, syntax macros, and transformers, will be covered later. For now let's go to create a more complex macro.</p><p class='mkup_p'><b class='mkup_b'>A more complex example</b></p><p class='mkup_p'>Good macros do source code transformation in a smart way, they turn a form that is undestood by the programmer into code that is also understood by the compiler, that's hard to type and use in raw form without the macro support, but optimal otherwise.</p><p class='mkup_p'>Ideally a macro should expand to a single command call (possibly including many other nested), and should not expand to code that magically creates variables at runtime to store intermediate results all the times it can be avoided (because there may be collisions with variables in the function, or created by other bad macros. Btw, in the TODO list of sugar there is a way to generate unique local variable names).</p><p class='mkup_p'>If the macro is well written, then the programmer can use it like any other command without to care much.</p><p class='mkup_p'>We will see a more real example of macro that implements a very efficient <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/lpop'>lpop</a></span> operator. It accepts only one argument, the name of a variable, and returns the last element of the list stored inside the given variable. As side effect, <span class='mkup_tt'>lpop</span> removes the last element from the list. (it's something like the complement of <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/lappend'>lappend</a></span>).</p><p class='mkup_p'>A pure-Tcl implementation is the following:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_9' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_9' class='sh_tcl sh_sourceCode'>proc lpop listVar {
    upvar 1 $listVar list
    set res [lindex $list end]
    set list [lrange $list 1 end]
    return $res
}</pre></div><p class='mkup_p'>This version of <span class='mkup_tt'>lpop</span> is really too slow. In fact when <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/lrange'>lrange</a></span> is called, it creates a new list object even if the original one stored in the <span class='mkup_tt'>$list</span> variable is going to be freed and replaced by the copy. To modify the list in-place is far better.</p><p class='mkup_p'>The <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/lrange'>lrange</a></span> implementation is able to perform this optimization if the object in &quot;not shared&quot; (if you don't know about this stuff try to read the Wiki page about the <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/K'>K</a></span> operator before to continue)</p><p class='mkup_p'>So it's better to write the proc using the <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/K'>K</a></span> operator. The lrange line should be changed to this:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_10' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_10' class='sh_tcl sh_sourceCode'>set list [lrange [K $list [set list {}]] 1 end]</pre></div><p class='mkup_p'>With <span class='mkup_tt'>K</span> being:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_11' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_11' class='sh_tcl sh_sourceCode'>proc K {x y} {
    return $x
}</pre></div><p class='mkup_p'>But even to call <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/K'>K</a></span> is costly in terms of performace, so why not inline it also? Doing it requires changing the previous lrange line to this:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_12' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_12' class='sh_tcl sh_sourceCode'>set list [lrange [lindex [list $list [set list {}]] 0] 1 end]</pre></div><p class='mkup_p'>That's really a mess to read, but works at a different speed, and even more important, at a different time complexity!.</p><p class='mkup_p'>With a macro for <span class='mkup_tt'>lpop</span>, we can go even faster, and the code is easier to maintain and read. Macros are allowed to expand to commands containing other macros, recursively. This means that we can write a macro for every single step of <span class='mkup_tt'>lpop</span>. We need the <span class='mkup_tt'>first</span> <span class='mkup_tt'>last</span> and <span class='mkup_tt'>drop</span> macros already developed, and a macro for <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/K'>K</a></span>:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_13' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_13' class='sh_tcl sh_sourceCode'>sugar::macro K argv {
    foreach {x y} $argv break
    list first [list $x $y]
}</pre></div><p class='mkup_p'>Note that for speed, we used <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/foreach'>foreach</a></span> instead of two calls to <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/lindex'>lindex</a></span>. But remember that macros <b class='mkup_b'>don't have to be fast in the generation</b> of the expanded code.</p><p class='mkup_p'><span class='mkup_tt'>K $x $y</span> expands to <span class='mkup_tt'>first [list $x $y]</span>, which expands to <span class='mkup_tt'>lindex [list $x $y] 0</span>.</p><p class='mkup_p'>We have one last problem. Even after the optimization and the use of <span class='mkup_tt'>K</span> inline, the procedure above required a local variable 'res' to save the last argument of the list before to modify it, and use <span class='mkup_tt'>$res</span> later as return value for the procedure. We don't want to create local vars into the code that calls the <span class='mkup_tt'>lpop</span> macro, nor do we want to expand to more than a single command. The <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/K'>K</a></span> operator can help us to do so:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_14' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_14' class='sh_tcl sh_sourceCode'>set res [lindex $list end]
set list [lrange [lindex [list $list [set list {}]] 0] 1 end]
return $res</pre></div><p class='mkup_p'>leading to:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_15' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_15' class='sh_tcl sh_sourceCode'>K [lindex $list end] [set list [lrange [lindex [list $list [set list {}]] 0] 1 end]]</pre></div><p class='mkup_p'>That's ok, but what an unreadable code! Thanks to macros we can abstract from the fact that to call procedures is slow, so we just write:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_16' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_16' class='sh_tcl sh_sourceCode'>[K [last $list] [set list [rest [K $list [set list {}]]]]]</pre></div><p class='mkup_p'>Will not win the clean-code context this year, but it's much better than the previous. Ok... now we want a macro that, every time we type <span class='mkup_tt'>lpop $list</span>, will expand in the above line:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_17' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_17' class='sh_tcl sh_sourceCode'>sugar::macro lpop argv {
    set varname [lindex $argv 1]
    set argv [list K \
        {[last $%varname%]} \
        {[set list [drop [K $%varname% [set %varname% {}]]]]}
    ]
    foreach i {1 2} {
        lset argv $i [string map [list %varname% $varname] [lindex $argv $i]]
    }
    return $argv
}</pre></div><p class='mkup_p'>There are few things to note about this code. The macro returns a list, where every element is a token of a Tcl command in the source code. This does not mean we have to transform in lists even arguments that happens to represent a script. Also note that the input list of the macro is just a list of tokens that are *exactly* what the user typed they in the source code, verbatim. What follows is that the tokens are already quoted and valid representations of a procedure argument. We don't need to care about the fact that they must be interpreted as a single argument as we sould when generating code for <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/eval'>eval</a></span>.</p><p class='mkup_p'>This allows the macro developer to use templates for macros, in fact the <span class='mkup_tt'>lpop</span> macro is just using a three argument template, and the final foreach will substitute the arguments that needs to refer to the variable name, with that name. You don't have to care what that variable name is. It can be a complex string formed by more commands, vars, and so on <span class='mkup_tt'>[like][this]$and-this</span>. If it was a single argument in the source code, it will be in the macro after the expansion.</p><p class='mkup_p'>Another interesting thing to note is that we don't really have to return every token as a different element of the list. In pratice we can return it even as a single-element list. The rule is that the macro expander will care to put an argument separator like a tab, or a space, for every element of the list, and put a command separator like newline or <span class='mkup_tt'>;</span> at the end. If we put spaces ourself, we can just return a single element list.</p><p class='mkup_p'>So, the <span class='mkup_tt'>lpop</span> macro can also by written in this way:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_18' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_18' class='sh_tcl sh_sourceCode'>sugar::macro lpop argv {
    set varname [lindex $argv 1]
    set cmd [format {
        K [last $%varname%] [set list [drop [K $%varname% [set %varname% {}]]]]
    } $varname $varname $varname]
    return [list $cmd]
}</pre></div><p class='mkup_p'>This is much more simple and clean, and actually it's possible to use this style. The difference is that returning every token as a different element of a list makes <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/Sugar'>Sugar</a></span> macros able to left the indentation of the original code unaltered. This is helpful both to take procedure error's line numbers correct, and to see a good-looking output of <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/info+body'>info body</a></span>. But as long as most macros are about commands that are just typed in the same line together with all the arguments, for many macros is just a matter of tastes.</p><p class='mkup_p'>If you are implementing control structures that are:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_19' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_19' class='sh_tcl sh_sourceCode'>indented in {
    this way
}</pre></div><p class='mkup_p'>It's another question, and it's better to return every token as a list element.</p><p class='mkup_p'><b class='mkup_b'>Number of argument and other static checks in macros</b></p><p class='mkup_p'>Macros expand to code that will raise an error if the number of arguents is wrong in most cases, but it's possible to add this control inside the macro. Actually it's a big advantage of macros because they are able to signal a bad number of arguments at run time: this can help to write applications that are more reliable. It's even possible to write a macro that expands to exactly what the user typed in, but as side effect does a static check for bad number (or format) of arguments:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_20' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_20' class='sh_tcl sh_sourceCode'>sugar::macro set argv {
   if {[llength $argv] != 3 || [llength $argv] != 2} {
       error &quot;Bad number of arguments for set&quot;
   }
   return $argv
}</pre></div><p class='mkup_p'>This macro returns <span class='mkup_tt'>$argv</span> itself, so it's an identity transformation, but will raise errors for <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/set'>set</a></span> with a bad number of arguments even for code that will never be reached in the application. Note that the previous macro for set is a bit incomplete: to get it right we should add checks for arguments that starts with <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/%7B%2A%7D'>{*}</a></span>, for this reason <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/Sugar'>Sugar</a></span> will provide a function to automatically search for a bad number of arguments in some next version.</p><p class='mkup_p'>Note that <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/%7B%2A%7D'>{*}</a></span> introduces for the first time the possibility for a command to get a number of arguments that is non evident reading the source code but computed at runtime. Actually, <span class='mkup_tt'>{*}</span> is an advantage for static checks because prior to it, the way to go was <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/eval'>eval</a></span>, that does totally &quot;hide&quot; the called command postponing all the work at run-time. With <span class='mkup_tt'>{*}</span> it's always possible to say from the source code that a command is called with *at least* N arguments. Still, to add new syntax to Tcl will probably not play well with macros and other form of source code processing.</p><p class='mkup_p'>Identity macros are very powerful to perform static syntax checks, they can not only warn on bad number of arguments, but with the type of this arguments. See for example the following identity macro for &quot;string is&quot;:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_21' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_21' class='sh_tcl sh_sourceCode'>proc valid_string_class class {
    set classes {alnum alpha ascii control boolean digit double false graph integer lower print punct space true upper wordchar xdigit}
    set first [string index $class 0]
    if {$first eq {$}} {return 1}
    if {$first eq {[}} {return 1}
    if {[lsearch $classes $class] != -1} {return 1}
    return 0
}

sugar::macro string argv {
    if {[lindex $argv 1] eq {is} &amp;&amp; [llength $argv] &gt; 2} {
        if {![valid_string_class [lindex $argv 2]]} {
            puts stderr &quot;Warning: invalid string class in procedure [sugar::currentProcName]&quot;
        }
    }
    return $argv
}</pre></div><p class='mkup_p'>Thanks to this macro it's possible to ensure that errors that like to write <span class='mkup_tt'>string is number</span> instead <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/string+is'>string is</a> integer</span> are discovered at compile-time. In this respect macros can be seen as a programmable static syntax checker for Tcl. We will see how &quot;syntax macros&quot; are even more useful in this respect. This is the second feature that macros add to Tcl:</p><p class='mkup_p'><b class='mkup_b'>2) Macros are a powerful programmable static checker for Tcl scripts.</b></p><p class='mkup_p'>Actually I think it's worth to use macros even only for this during the development process, and than flush they away.</p><p class='mkup_p'><b class='mkup_b'>Conditional compilation</b></p><p class='mkup_p'>That's small and neat: we can write a simple macro that expands to some code only if a global variable is set to non-zero. Let's write this macro that we call [debug].</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_22' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_22' class='sh_tcl sh_sourceCode'>sugar::macro debug argv {
   if {$::debug_mode} {
       list if 1 [lindex $argv 1]
   } else {
       list
   }
}</pre></div><p class='mkup_p'>Than you can use it in your application like if it was a conditional:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_23' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_23' class='sh_tcl sh_sourceCode'># Your application ...
debug {
    set c 0
}
while 1 {
    debug {
        incr c
        if {$c &gt; 100} {
            error &quot;Too many iteractions...&quot;
        }
    }
    .... do something ....
}</pre></div><p class='mkup_p'>if the value of <span class='mkup_tt'>$::debug_mode</span> is true, all the <span class='mkup_tt'>debug {someting}</span> commands are compiled as <span class='mkup_tt'>if 1 {something}</span>. Otherwise, they will not be compiled at all.</p><p class='mkup_p'>That's the simplest example, you can write similar macros like <span class='mkup_tt'>ifunix</span>, <span class='mkup_tt'>ifwindows</span>, <span class='mkup_tt'>ifmac</span>, or even to expand to different procedures call if a given command is called with 2, 3 or 4 arguments. The limit is the immagination.</p><p class='mkup_p'><b class='mkup_b'>New control stuctures</b></p><p class='mkup_p'>Not all the programming languages allow to write new control structures. Tcl is one of the better languages that don't put the programmer inside a jail, but not all the programming languages that allow to write new control structures are able to make them efficient.</p><p class='mkup_p'>Tcl macros can make new control structures as fast as <a class='mkup_a mkup_known' href='/page/bytecode'>byte-compiled</a> control structures, because user defined ones are usually syntax glue for code transformations. Being macro transformers that translates a from to another, that's a good fit for macros.</p><p class='mkup_p'>Here is a macro for the <span class='mkup_tt'>?:</span> operator.</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_24' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_24' class='sh_tcl sh_sourceCode'># ?: expands
#   ?: cond val1 val2
# to
#   if $cond {format val1} {format val2}
sugar::macro ?: argv {
    if {[llength $argv] != 4} {
        error &quot;Wrong number of arguments&quot;
    }
    foreach {_ cond val1 val2} $argv break
    list if $cond [list [list format $val1]] [list [list format $val2]]
}</pre></div><p class='mkup_p'>The macro's comment shows the expansion performed. Being it translated to an <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/if'>if</a></span> command, it's as fast as a Tcl builtin.</p><p class='mkup_p'><b class='mkup_b'>How macros knows what's a script?</b></p><p class='mkup_p'>In Tcl there are no types, nor special syntaxes for what is code and what is just a string, so you may wonder why macros are not expanded in the following code:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_25' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_25' class='sh_tcl sh_sourceCode'>puts {
    set foo {1 2 3}; [first $foo]
}</pre></div><p class='mkup_p'>But they are expanded in this:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_26' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_26' class='sh_tcl sh_sourceCode'>while 1 {
    set foo {1 2 3}; [first $foo]
}</pre></div><p class='mkup_p'>I guess this is one of the main problems developers face designing a macro system for Tcl, and even one of the better helpers of the idea that a good macro system for Tcl is impossible because you can't say what is code and what isn't.</p><p class='mkup_p'><a class='mkup_a mkup_known' href='/page/Sugar'>Sugar</a> was designed to address this problem in the simplest possible of the ways: because it can't say if an argument is a script or not, macro expansion is not performed in arguments, so in theory <a class='mkup_a mkup_known' href='/page/Sugar'>Sugar</a> will not expand the code that's argument to <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/puts'>puts</a></span>, nor <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/while'>while</a></span>.</p><p class='mkup_p'>But of course, in the real world for a macro system to be usable, macros should be expanded inside the <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/while'>while</a></span>, and not expanded in <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/puts'>puts</a></span>, so the idea is that for commands that you know accept a script as an argument, you write a macro that returns the same command but with script arguments macro-expanded. It is very simple and in pratice this works well. For example that's the macro for <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/while'>while</a></span>:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_27' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_27' class='sh_tcl sh_sourceCode'>sugar::macro while argv {
    lset argv 1 [sugar::expandExprToken [lindex $argv 1]]
    lset argv 2 [sugar::expandScriptToken [lindex $argv 2]]
}</pre></div><p class='mkup_p'>That's the macro for <a class='mkup_a mkup_known' href='/page/if'>if</a>:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_28' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_28' class='sh_tcl sh_sourceCode'>sugar::macro if argv {
    lappend newargv [lindex $argv 0]
    lappend newargv [sugar::expandExprToken [lindex $argv 1]]
    set argv [lrange $argv 2 end]
    foreach a $argv {
        switch -- $a {
            else - elseif {
                lappend newargv $a
            } 
            default {
                lappend newargv [sugar::expandScriptToken $a]
            }
        }
    }
    return $newargv
}</pre></div><p class='mkup_p'>As you can see, <a class='mkup_a mkup_known' href='/page/Sugar'>Sugar</a> exports an API to perform expansion in Tcl scripts and Expr expressions. There are similar macros for <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/switch'>switch</a></span>, <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/for'>for</a></span>, and so on. If you write a new conditional or loop command with macros, you don't need it at all because the macro will translate to code that contains some form of a well known built-in conditional or loop command, and we already have macros for this (remember that macros can return code with macros).</p><p class='mkup_p'>If you write any other command that accept as arguments a Tcl script or expr expression, just write a little macro for it to do macro expansion. This has a nice side effect:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_29' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_29' class='sh_tcl sh_sourceCode'>proc nomacro script {
    uplevel 1 $script
}</pre></div><p class='mkup_p'>Don't write a macro for nomacro, and you have a ready-to-use command that works as a barrier for macro expansion.</p><p class='mkup_p'>Continue with section 2 - <b class='mkup_b'><a class='mkup_a mkup_known' href='/page/Sugar+syntax+macros'>Sugar syntax macros</a></b></p><hr class='mkup_hr'><p class='mkup_p'><a class='mkup_a mkup_known' href='/page/WHD'>WHD</a>: This is very cool, but I have to ask--why not allow macros to have a standard Tcl argument list? That is, </p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_30' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_30' class='sh_tcl sh_sourceCode'>sugar::macro mymacro args {...}</pre></div><p class='mkup_p'>Gives the behavior you describe here, while</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_31' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_31' class='sh_tcl sh_sourceCode'>sugar::macro mymacro {a b c} {...}</pre></div><p class='mkup_p'>explicitly creates a macro that takes three arguments and will generate a standard error message if you supply some other number?</p><hr class='mkup_hr'><p class='mkup_p'><a class='mkup_a mkup_known' href='/page/SS'>SS</a>: This can be a good idea, being always possible to use <span class='mkup_tt'>args</span> as only argument to have the current behaviour. I used a single list as input mainly because the same macro can have more then a name, and in order to have the same interface for both command macros and syntax macros. For example:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_32' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_32' class='sh_tcl sh_sourceCode'>sugar::macro {* + - /} argv {
    list expr [list [join [lrange $argv 1 end] &quot; [lindex $argv 0] &quot;]]
}</pre></div><p class='mkup_p'>Will handle <span class='mkup_tt'>* + - /</span> with the same code. Macros with more than a name may in extreme cases even give different meanings for arguments in the same position. Btw there is 'args' for this case. So I can change the API to something like this:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_33' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_33' class='sh_tcl sh_sourceCode'>sugar::macro {name arg1 arg2 ...} {...}</pre></div><p class='mkup_p'>That's like a Tcl proc, but with the name that was used to call the macro as the first argument. For syntax macros, this format actually may not make a lot of sense, but there is still <span class='mkup_tt'>args</span>. I'll include this change in the next version if I'll not receive feedbacks against it. Thanks for the feedback WHD.</p><p class='mkup_p'><a class='mkup_a mkup_known' href='/page/WHD'>WHD</a>: I think that on the whole I prefer the previous syntax for command macros; the macro can always have an implicit argument that is the macro name. For example,</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_34' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_34' class='sh_tcl sh_sourceCode'># Identity macro
sugar::macro {+ - * /} {args} { return &quot;$macroname $args&quot; }</pre></div><p class='mkup_p'><a class='mkup_a mkup_known' href='/page/JMN'>JMN</a>: I'd just like to add my vote for removing the macroname as first argument syntax. From my hacking about, it seems easy to make it implicitly available more or less as WHD suggests. (I don't *think* I broke anything.. )</p><hr class='mkup_hr'><p class='mkup_p'><a class='mkup_a mkup_known' href='/page/SS'>SS</a>: For a different question about the sugar API, I wonder if Tclers interested in this macro system feel better about the current redefinition of <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/proc'>proc</a></span>, or if it's better to provide a <span class='mkup_tt'>sugar::proc</span> that's exactly like <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/proc'>proc</a></span> but with macro expansion.</p><p class='mkup_p'>If the API will remain the current with <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/proc'>proc</a></span> redefined, I'll add in the wrapper an option <span class='mkup_tt'>-nomacro</span> that will just call the original command. Please add your name with optional motivation below.</p><p class='mkup_p'>Yes, I think it's better to wrapper the real <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/proc'>proc</a></span>:</p><UL class='mkup_UL'><li class='mkup_li'>Put your name here if you are for this solution.</li></UL><p class='mkup_p'>No, I want macro expansion only using <span class='mkup_tt'>sugar::proc</span>:</p><UL class='mkup_UL'><li class='mkup_li'><a class='mkup_a mkup_known' href='/page/SS'>SS</a> (avoid to waste CPU time for procs that don't use macros, this can be a big difference if you <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/package+require'>package require</a></span> sugar before Tk or other big packages)</li><li class='mkup_li'><a class='mkup_a mkup_known' href='/page/DKF'>DKF</a>: Avoiding overriding the real <a class='mkup_a mkup_known' href='/page/proc'>proc</a> allows packages to use sugar if they want without surprising packages that don't expect it. Packages that do want it can just do [<a class='mkup_a mkup_known' href='/page/namespace+import'>namespace import</a> ::sugar::proc] into their own private workspace.</li></UL><p class='mkup_p'><a class='mkup_a mkup_known' href='/page/WHD'>WHD</a>: Since you have to override the standard control structures to make macros work, it seems to me that what you really need is a pair of commands:</p><div class='sh_sourceCode'><button class='copybtn btn pull-right' data-clipboard-target='#mkup_code_35' title='Click to copy code snippet to clipboard'><span class='glyphicon glyphicon-copy' aria-hidden='true'></span></button><pre id='mkup_code_35' class='sh_tcl sh_sourceCode'>sugar::configure -enabled 1

# Macros expanded in body
proc myproc {a b c} {....}

# Macros expanded in expression and body
while {$a &gt; $b} {....}

sugar::configure -enabled 0

# Macros no long expanded.</pre></div><p class='mkup_p'><a class='mkup_a mkup_known' href='/page/SS'>SS</a>: Actually <a class='mkup_a mkup_known' href='/page/Sugar'>Sugar</a> overrides nothing! (so it will expand all at compile time, no run-time overhead). It does expansion inside control structures just using macros for <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/while'>while</a></span> and so on. In this page this is better explained in the section: <b class='mkup_b'>How a macro knows what's a script?</b>. So to override <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/proc'>proc</a></span>, or to provide a private proc-like command is just a matter of design (or tastes), all will work in both the cases.</p><hr class='mkup_hr'><p class='mkup_p'><a class='mkup_a mkup_unknown' href='/_new?newpagename=alpha%5Ftcler'>alpha_tcler</a> 2016-04-06: The library should allow easily to choose if I want macros inside ::sugar::proc or used elsewhere . Secondly, the examples should be corrected ( the args replacing argv). Great work , macros make TCL a first class LISP equivalent language.</p><p class='mkup_p'><a class='mkup_a mkup_known' href='/page/PYK'>PYK</a> 2016-04-06: Now other <a class='mkup_a mkup_known' href='/page/Lisp'>Lisp</a> languages just need to grow <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/uplevel'>uplevel</a></span>, <span class='mkup_tt'><a class='mkup_a mkup_known' href='/page/upvar'>upvar</a></span>, <a class='mkup_a mkup_known' href='/page/coroutine'>coroutines</a>, explicit <a class='mkup_a mkup_known' href='/page/tailcall'>tailcalls</a>, and <a class='mkup_a mkup_known' href='/page/interp'>safe interpreters</a>, in order to become first-class Tcl-equivalent languages :p If you really want to go down the macro rabbit hole, check out <a class='mkup_a mkup_known' href='/page/procstep'>procstep</a>.</p><hr><div class='mkup_centered'><table class='mkup_categories'><tr><td class='mkup_td'><a class='mkup_a' href='/page/Category+Dev%2E+Tools'>Category Dev. Tools</a></td><td class='mkup_td'><a class='mkup_a' href='/page/Sugar'>Sugar</a></td></tr></table></div>
</div>
</div>
<div class='row'>
<div class='col-xs-12'>
<div class='Footer'>Updated 2020-09-21 07:34:38</div>
</div>
</div>
</div>

<script src='https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.31.0/js/jquery.tablesorter.combined.js'></script>

<script src='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js'></script>
<script type='text/javascript' src='/scripts/nikit.js'></script>
<script type='text/javascript' src='/scripts/sh_main.js'></script>
<script type='text/javascript' src='/scripts/sh_tcl.js'></script>
<script type='text/javascript' src='/scripts/sh_c.js'></script>
<script type='text/javascript' src='/scripts/sh_cpp.js'></script>

<script src='https://hcaptcha.com/1/api.js'></script>
<script>var clipboard = new ClipboardJS('.copybtn', {
  text: function(trigger) {
    return document.querySelector(trigger.getAttribute('data-clipboard-target')).textContent + '\n';
  }
});
sort_tables();
</script>
</body>
</html>
