# -*-   mode: tcl  ; coding: koi8   -*- ----------------------------------------

#!/bin/sh
# the next line restarts using tclsh \
exec wish "$0" "$0 $@"

#------------------------------------------------------------------------------

# TkHearts by Steven A, released under the GPL.
#
# version 0.80 has introduced a nice weighted AI feature to select myHigh,
# myLow, (this leaves quite a lot of room for tweaking!) and has looked at stopping
# the player from collecting all tricks (shooting).
#
# Todo:
# Hmmm - tried making the widget bigger, but it looks ugly as the card spots
#   become visible and break up the clean hand appearance
# Add option for alternative rules.
# See also "Ai todo".
#
# Hearts, based on the card game shipped with MS Windows
# version 0.24 copyright Mike Griffiths, Feb 17th 2005

# some common procs for spider, hearts and tktk

package require Tk

#------------------------------------------------------------------------------
proc lreverse {list} {

  set result {}
  foreach i $list {
    set result [linsert $result 0 $i]
  }

  return $result
}
#------------------------------------------------------------------------------
proc initSubWindow {w title transient} {

  # Initilaises a toplevel window offscreen and withdrawn
  # (to allow the user to pack it before centering and being drawn)

  # I tried to use bind <FocusIn|Enter> to raise the window,
  # but using "grab" stops this command taking effect.
  # Additionally, using grab is the only way I know of to disable menus

  catch {destroy $w}
  toplevel $w
  wm title $w $title
  wm withdraw $w
  wm geometry $w +2000+2000

  if {$transient} {
    wm transient $w .

    bind . <FocusIn> "raise $w ; focus -force $w"
  }
}
#------------------------------------------------------------------------------

proc grabSubWindow {w} {

  # There is an obscure bug in the grab code that means grab shouldn't be used till window
  # is drawn, so put grab here

  global data

  if { $data(platform) == "unix"} {
    grab set $w
  }
}
#------------------------------------------------------------------------------
proc closeSubWindow {w} {
  bind . <FocusIn> ""
  grab release $w

  destroy $w
}
#------------------------------------------------------------------------------
proc closeDialog {w {cmd ""}} {

  closeSubWindow $w
  .c configure -state normal
  if { $cmd != "" } {
       uplevel #0 $cmd
     }
}
#------------------------------------------------------------------------------
proc center {win} {

  # Center window $win on the screen

  set w [winfo reqwidth $win]
  set h [winfo reqheight $win]
  set parent [winfo parent $win]

  if {"$parent" == "" } {
    set sh [winfo screenheight $win]
    set sw [winfo screenwidth $win]
    set reqX [expr {($sw-$w)/2}]
    set reqY [expr {($sh-$h)/2}]
  } else {
    scan [wm geometry $parent] "%dx%d+%d+%d" a b c d
    set reqX [expr $c + ($a-$w)/2]
    set reqY [expr $d + ($b-$h)/2]
  }
  if {$reqX < 0} {set reqX 0}
  if {$reqY < 0} {set reqY 0}

  wm geometry $win +$reqX+$reqY
  update idletasks

  return;
}
#------------------------------------------------------------------------------
proc exitGame {{quick yes}} {

  global p

  if {$quick == 0} {
    set ans [tk_messageBox -type yesno -icon question \
	  -title "$p(name) - Confirm Exit" \
	  -message "Confirm quit Game"]
    if { $ans == "no" } return
  }

  saveOptions
  exit
}
#------------------------------------------------------------------------------
proc showCardBack {} {

  global cardback data p

  set thisCmd [lindex [info level 0] 0]
  if { [info exists dialog(cmd)] && !($dialog(cmd) == "" || $dialog(cmd) == $thisCmd) } {
       return; # already got another dialog up
  }
  set dialog(cmd) $thisCmd
  set dialog(win) .cardbacks
  set w $dialog(win)

  initSubWindow $w "$p(name) - Playing Cards" 1

  wm protocol $w WM_DELETE_WINDOW "closeDialog $w"
  # set .c disabled, to stop cards reacting
  .c configure -state disabled

  set i 3
  set list [list 1 2 3 0]
  set frame -1
  loadCardbacks
  foreach x [lsort [array names cardback]] {
    set i [lindex $list $i]
    if { $i == "0" } {
      incr frame
      pack [frame $w.fr$frame] -side top -fill both
    }
    lappend data(cardbackIMG) \
      [set this [image create photo -data $cardback($x)]]
    radiobutton $w.fr$frame.$i -text $x -image $this -compound top \
      -variable data(cardback) -value $x -indicatoron false -selectcolor LightSteelBlue \
      -command {::img::back configure -data $cardback($data(cardback));update} \
      -offrelief flat -borderwidth 3
    pack $w.fr$frame.$i -side left -padx 4 -pady 6
  }

  pack [frame $w.frBtn] -side bottom -expand 1 -fill x
  pack [button $w.frBtn.ok -command "closeDialog $w" -text "OK" -width 8] \
    -side left -anchor center -padx 5 -pady 8 -fill none -expand 1

  update
  center $w

  wm deiconify $w
  wm resizable $w 0 0
  update
  grabSubWindow $w
  
  return;
}
#------------------------------------------------------------------------------
proc saveOptions {} {

  global data p
  
  catch {file attributes $p(config) -hidden 0} ;# unable to open hidden files for writing!
  
  set hFile [open $p(config) w]
  
  puts $hFile "# Automatically created - do not edit"
  
  set list {speed scores name,0 name,1 name,2 name,3 diff,1 diff,2 diff,3 canvas_bg cardback pause autoraise}
  
  foreach i $list {
    puts $hFile "set data($i) \"$data($i)\""
  }
  
  close $hFile
  catch {file attributes $p(config) -hidden 1}
    
}
#------------------------------------------------------------------------------
proc shuffleList {list} {

  # l is a list of pairs e.g. {{card1 random1} {card2 random2}...}
  # which gets sorted by the random numbers (index 1)
  # doing it twice^H^H^H^H^H more  works better

  foreach j {1 2 3 4} {
    set l {}
    foreach i $list {
      lappend l "$i [expr rand()*rand()]"
    }

    set list {}
    foreach i [lsort -real -index 1 $l] {
      lappend list [lindex $i 0]
    }

  }

  return $list
}
#------------------------------------------------------------------------------
### &&& is this best S.A. ?
#------------------------------------------------------------------------------
proc setinter {arg1 arg2} {

  # setinter [set cards$suit] {t j q k a}
  set list ""
  foreach x $arg1 {
    if { [lsearch -exact $arg2 $x] != "-1" } {
      lappend list $x
    }
  }

  # S.A.  return [lsort -unique $list];
  return $list
}
#------------------------------------------------------------------------------
proc setinterN {arg1 arg2} {

  set N 0
  foreach x $arg1 {
    if { [lsearch -exact $arg2 $x] != "-1" } {
      incr N
    }
  }

  return $N
}
#------------------------------------------------------------------------------
proc setdiff {arg1 arg2} {

  set list ""
  foreach x $arg1 {
	if { [lsearch -exact $arg2 $x] == "-1" } {
	  lappend list $x
	}
  }

  return [lsort -unique $list];
}
#------------------------------------------------------------------------------
proc showColor {} {

  global data p

  set choice [tk_chooseColor -parent . \
    -title "$p(name) - Background Colour" -initialcolor $data(canvas_bg)]
  if {"$choice"!=""} {
    .c configure -background "$choice"
    set data(canvas_bg) "$choice"
  }

}
#------------------------------------------------------------------------------

proc showColor2 {} {
  global data p

  set choice [tk_chooseColor -parent . \
    -title "$p(name) - Panel Colour" -initialcolor $data(canvas_bg2)]
  if {"$choice"!=""} {
    .c.f configure -background "$choice"
    .c.f.l configure -background "$choice"
    ::img::marker put $choice -to 0 0 70 95
    set data(canvas_bg2) "$choice"
  }
}

#------------------------------------------------------------------------------
proc initIcons {} {

  # unfortunately we have to write these bitmaps to a file to use them

  if {[catch {set fid [open "/tmp/icon_bitmap" w]}]} {
    # f***ing windows is f***d
    return
  }

  puts $fid {
  #define icon_bitmap_width 48
  #define icon_bitmap_height 48
  static unsigned char icon_bitmap_bits[] = {
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00,
     0x00, 0x00, 0x80, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x80, 0x70, 0x00, 0x00,
     0x00, 0x00, 0x40, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x60, 0x80, 0x07, 0x00,
     0xff, 0xff, 0xff, 0x1f, 0x0e, 0x00, 0x01, 0x00, 0x00, 0x10, 0x3c, 0x00,
     0x09, 0x00, 0x00, 0x10, 0x70, 0x00, 0x0d, 0x00, 0x00, 0x10, 0xc0, 0x01,
     0x1d, 0x00, 0x00, 0x10, 0x80, 0x03, 0x15, 0x00, 0x00, 0x10, 0x00, 0x0e,
     0x09, 0x00, 0x00, 0x10, 0x00, 0x3c, 0x1d, 0x00, 0x00, 0x10, 0x00, 0x70,
     0x3f, 0x00, 0x00, 0x10, 0x00, 0xc0, 0x3f, 0xf0, 0x01, 0xd0, 0x01, 0xc0,
     0x1d, 0xf8, 0x03, 0xd0, 0x01, 0xc0, 0x1d, 0xfc, 0x07, 0xd0, 0x01, 0x60,
     0x01, 0xfc, 0x07, 0xd0, 0x01, 0x70, 0x01, 0xfc, 0x07, 0xd0, 0x01, 0x30,
     0x01, 0xf8, 0x03, 0xd0, 0x01, 0x18, 0x01, 0xfb, 0x1b, 0xd0, 0x03, 0x18,
     0x81, 0xff, 0x3f, 0xd0, 0x03, 0x0c, 0x81, 0xff, 0x7f, 0xd0, 0x03, 0x0c,
     0xc1, 0xff, 0x7f, 0xd0, 0x03, 0x06, 0xc1, 0xff, 0x7f, 0xd0, 0x01, 0x06,
     0xc1, 0xff, 0x7f, 0x50, 0x00, 0x03, 0x81, 0xff, 0x7f, 0x10, 0x80, 0x01,
     0x81, 0xff, 0x3f, 0x10, 0x80, 0x01, 0x01, 0xe7, 0x1d, 0x10, 0xc0, 0x00,
     0x01, 0xf0, 0x03, 0x10, 0xc0, 0x00, 0x01, 0xf8, 0x07, 0x12, 0x60, 0x00,
     0x01, 0xf8, 0x07, 0x13, 0x62, 0x00, 0x01, 0xf8, 0x07, 0x97, 0x32, 0x00,
     0x01, 0x00, 0x80, 0x54, 0x11, 0x00, 0x01, 0x00, 0x00, 0x52, 0x19, 0x00,
     0x01, 0x00, 0x00, 0xd3, 0x0c, 0x00, 0x01, 0x00, 0x80, 0xd7, 0x0c, 0x00,
     0x01, 0x00, 0xc0, 0xdf, 0x06, 0x00, 0x01, 0x00, 0x80, 0x97, 0x06, 0x00,
     0x01, 0x00, 0x00, 0x13, 0x03, 0x00, 0x01, 0x00, 0x00, 0x30, 0x01, 0x00,
     0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
  }
  close $fid
  set fid [open "/tmp/icon_mask" w]
  puts $fid {
  #define cards_section_mask_width 48
  #define cards_section_mask_height 48
  static unsigned char cards_section_mask_bits[] = {
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00,
     0x00, 0x00, 0x80, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7f, 0x00, 0x00,
     0x00, 0x00, 0xc0, 0xff, 0x01, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x07, 0x00,
     0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00,
     0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03,
     0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f,
     0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
     0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f,
     0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f,
     0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,
     0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07,
     0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01,
     0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
     0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00,
     0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00,
     0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00,
     0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00,
     0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00,
     0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00,
     0xfe, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
  }
  close $fid

  wm iconbitmap . @/tmp/icon_bitmap
  wm iconmask   . @/tmp/icon_mask
}
#------------------------------------------------------------------------------
#
#------------------------------------------------------------------------------

#source "images.tcl"

source "d_hear.im"



#------------------------------------------------------------------------------
proc initHearts {} {
  global p data

  wm withdraw .
  set data(title_const) "$p(name) $p(version)"

  . configure -menu [menu .m -tearoff 0]
  .m add cascade -label "Game" -underline 0 -menu [menu .m.g -tearoff 0]
    .m.g add command -label "New Game" -underline 0 -command {newGameHearts} 
    .m.g add command -label "Score" -underline 0 -command showScores 
    .m.g add command -label "Quit" -underline 1 -command {exitGame} 
    wm protocol . WM_DELETE_WINDOW {exitGame}

  .m add cascade -label "Options" -underline 0 -menu [menu .m.o -tearoff 0]
    .m.o add command -label "Game Options" -underline 0 -command showOptions 
    .m.o add command -label "Playing Cards" -underline 0 -command showCardBack 
    .m.o add command -label "Background Colour" -underline 0 -command showColor 

  .m add cascade -label "Help" -underline 0 -menu [menu .m.help -tearoff 0]
    .m.help add command -label "Help Topics" -underline 0 -command showHelp
    .m.help add command -label "Changes" -underline 0 -command {showHelp 3}
    .m.help add command -label "About" -underline 0 -command {showHelp 4}

    if { $data(platform) != "unix" } {
      .m.help add separator
      .m.help add command -label "Show Console"  -command {console show} -underline 0
    }


  canvas .c -width $data(tw) -height $data(th) \
    -background $data(canvas_bg) -highlightthickness 0
  .c bind player0 <ButtonPress-3> {set ::data(belowCard) [.c find above \
      [set ::data(raiseCard) [.c find withtag current]]] ; .c raise $::data(raiseCard)}
  .c bind player0 <ButtonRelease-3> {.c lower $::data(raiseCard) $::data(belowCard)}

  pack .c -side top -anchor nw -pady 2
  label .status -relief groove -borderwidth 1 -anchor w \
                -text "Welcome to Hearts" -font $data(font_default)
  pack .status -ipadx 5 -fill x
  
  update
  center .
  wm deiconify .
  update
  wm resizable . 0 0
  raise .
  focus -force .
  
  bind . <F1> showHelp
  bind . <KeyPress-q> {exitGame}
  bind . <KeyPress-n> {newGameHearts quick}
  bind . <Control-d> {toggledebug}
}
#------------------------------------------------------------------------------

proc newGameHearts {{force 0}} {
  global data p

  if { $data(playing) && $force == 0} {
    set ans [tk_messageBox -message "Start a new game?" -title $p(name) \
			 -type yesno -icon question]
    if { $ans == "no" } { return }
  }

  set data(doing) none

  .c delete all

  set data(playing) 1
  set data(round) 0
  set data(score,0) 0
  set data(score,1) 0
  set data(score,2) 0
  set data(score,3) 0
  chkTitle

  deal
  
  # get the color for names, and pick a font
  # set nameCol [revCol [.c cget -background]]
  # or, on second thoughts....
  set nameCol "white"
  set nameFont [font actual Helvetica -displayof .]
  set fontH [font metrics $nameFont -displayof . -linespace]

  set cardW [image width ::img::back]
  set cardH [image height ::img::back]

# &&&
  set pos(x,0) [expr $data(tb_base) - 8]
  set pos(y,0) [expr $data(t1) + $cardH]
  set pos(a,0) se

  set pos(x,1) [expr $data(t2) + 3]
  set pos(y,1) [expr $data(tr_base) - 3]
  set pos(a,1) sw

  set pos(x,2) [expr $data(t3) - 3 + $cardW]
  set pos(y,2) [expr $data(tr_base) + 5 + ($data(ts)*$data(lr_diff)) + $cardH]
  set pos(a,2) ne

  set pos(x,3) [expr $data(tb_base) + 5 + ($data(ts)*$data(tb_diff)) + $cardW]
  set pos(y,3) 15
  set pos(a,3) nw

  foreach {who} [list 0 1 2 3] {
    .c create text $pos(x,$who) $pos(y,$who) -tags [list name name$who] \
       -text $data(name,$who) -fill $nameCol -anchor $pos(a,$who)
  }
}
#------------------------------------------------------------------------------

proc revCol {n} {
  # return the inverse of color $n

  set list [winfo rgb . $n]

  set red [lindex $list 0]
  set green [lindex $list 1]
  set blue [lindex $list 2]
  set first [format "#%04x%04x%04x" $red $green $blue];  

  # invert it
  set first [string tolower $first]
  set inverse [string map "0 f 1 e 2 d 3 c 4 b 5 a 6 9 7 8 8 7 9 6 a 5 b 4 c 3 d 2 e 1 f 0" $first]
  return $inverse;

}
#------------------------------------------------------------------------------

proc suitValue {card} {
  return [string range $card 1 1]
}
#------------------------------------------------------------------------------

proc numValue {card} {

  # returns a numerical value for the rank

  set card [string range $card 0 0]

  # return value
  return [lsearch [list FAKE FAKE 2 3 4 5 6 7 8 9 t j q k a] $card];

}
#------------------------------------------------------------------------------

proc sortPlayerCards {{which "0 1 2 3"}} {
  global data

  # now we need to sort them, by suit and then by face value
  foreach x $which {
    set data(cards,$x) [lsort -command sortByCard $data(cards,$x)]
  }
}
#------------------------------------------------------------------------------

proc sortByRank {a b} {

  set a [numValue [string range $a 0 0]]
  set b [numValue [string range $b 0 0]]
  if { $a < $b } {
    return -1;
  } elseif { $a > $b } {
    return 1;
  } else {
    return 0;
  }

}
#------------------------------------------------------------------------------

proc sortByCard {a0 b0} {

  # split into face value and suit value
  set a(face) [numValue $a0]
  set b(face) [numValue $b0]

  set a(suit) [lsearch {c d s h} [string range $a0 end end]]
  set b(suit) [lsearch {c d s h} [string range $b0 end end]]

  if { [set ans [sortByCardSub $a(suit) $b(suit)]] == "0" } {
    return [sortByCardSub $a(face) $b(face)];
  } else {
    return $ans;
  }

}
#------------------------------------------------------------------------------

proc sortByCardSub {a b} {

  if { $a < $b } {
    return -1;
  } elseif { $a > $b } {
    return 1;
  } else {
    return 0;
  }
}
#------------------------------------------------------------------------------

proc deal {} {
  global data

  set cards [shuffleList $data(allcards)]
  set data(lastCards) $cards
  set data(cards,0) [lrange $cards 0 12]
  set data(cards,1) [lrange $cards 13 25]
  set data(cards,2) [lrange $cards 26 38]
  set data(cards,3) [lrange $cards 39 51]
  # now sort them, by suit then by face
  sortPlayerCards

  set data(points,0) {}
  set data(points,1) {}
  set data(points,2) {}
  set data(points,3) {}
  set data(lastwinners) {}

  set data(hearts) 0

  # FIGURES FOR TOP/BOTTOM PLAYERS
  set base $data(tb_base)
  set diff $data(tb_diff)

  # draw the player (0)'s cards
  set lc $data(cards,0)
  for {set i 0} {$i < 13} {incr i} {
    .c create image [expr {$base+($i*$diff)}] $data(t1) \
       -image ::img::[lindex $lc $i] -anchor nw \
       -tags [list card player0 cardNum[lindex $lc $i] down]
  }

  # draw the top AI (3)'s cards
  set lc $data(cards,3)
  for {set i 0} {$i < 13} {incr i} {
    .c create image [expr {$base+($i*$diff)}] $data(t2) \
       -image [getImage [lindex $lc $i]] -anchor nw \
       -tags [list card player3 cardNum[lindex $lc $i] down]
  }

  # FIGURES FOR LEFT/RIGHT PLAYERS
  set base $data(tr_base)
  set diff $data(lr_diff)

  # draw the left AI (1)'s cards
  set lc $data(cards,1)
  for {set i 0} {$i < 13} {incr i} {
    .c create image $data(t2) [expr {$base+($i*$diff)}] \
       -image [getImage [lindex $lc $i]] -anchor nw \
       -tags [list card player1 cardNum[lindex $lc $i] down]
  }

  # draw the right AI (2)'s cards
  set lc $data(cards,2)
  for {set i 0} {$i < 13} {incr i} {
    .c create image $data(t3) [expr {$base+($i*$diff)}] \
       -image [getImage [lindex $lc $i]] -anchor nw \
       -tags [list card player2 cardNum[lindex $lc $i] down]
  }

  # set up binding, etc
  set data(round) [lindex "1 2 3 4 1" $data(round)] ;# set internal record to this round
  if { [lsearch [list 1 2 3] $data(round)] != "-1" } {
	set data(doing) pass1
	.c bind player0 <Button-1> doCardUpDown
	.c bind player0 <Enter>    doCardUp
	.c bind player0 <Leave>    doCardDown
	set dir [lindex "XXX Left Right Across" $data(round)]
	set dirL [string tolower $dir]
	setStatus "Select three cards to pass $dirL to $data(name,$data(round))"
	# create a button to allow them to pass the cards
	makeButton "Pass $dir" doPassCards disabled
	# We also need the 'AI' to choose cards for each of the other players
	foreach x [list 1 2 3] {
	  # chooseAICardsUp-$data(diff,$x) $x
	  AIchooseCardsUp $x
	}
  } else {
	# we're on round 4
	startPlay
  }
}
#------------------------------------------------------------------------------


proc getImage {card} {
  # if in debug mode, return the cards front, instead of back
  global data

  if {$data(debug)} {
    set return ::img::$card
  } else {
    set return ::img::back
  }
}
#------------------------------------------------------------------------------

proc toggledebug {} {
  global data

  set data(debug) [expr !$data(debug)]
  foreach x "$data(cards,1) $data(cards,2) $data(cards,3)" {
    .c itemconfig [.c find withtag cardNum$x] -image [getImage $x]
  }
  update
}
#------------------------------------------------------------------------------

proc makeButton {text {cmd {}} {state normal}} {
  global data

  # make a button .c.btn for the canvas
  set w .c.btn
  catch {destroy $w}
  button $w -text $text -command $cmd -state $state \
    -padx 5 -pady 2 -font $::data(font_button)
# &&&
  set btnX [expr {$data(tw)/2-([winfo reqwidth .c.btn]/2)}]
  set btnY [expr {$data(th)/2-([winfo reqheight .c.btn]/2)}]
  .c create window $btnX $btnY -window .c.btn -anchor nw -tags "passBtn"

}
#------------------------------------------------------------------------------

#############
# Ai todo:
#
# if have Qspades, we can take some liberties and possibly short suit self
# eg (player leads small spade - we have 4s qs ks, should play ks ?
# if we are the third player, and have no choice but to win it, (and qs gone), play high
# separate myLow into myLowPlay myLowLead
# if QS gone and hearts unbroken can lead high if want
# get rid of other suits before playing hearts (kind of done)
# if lead a card and noone had the suit, try diff suit!
# ...more

# these rules are parsed by proc AIgetBestCard - in this order - to make decisions

set ai(rules) {

  { {$first} play HIGH }
  { {$down==0} play LOW }
  { {$shooting && $hasSuit && $data(suit) != "s" && ($down == 1 || [llength $pot_scoring] > 0) && [numValue $myHigh] > [numValue $data(lead)]} play HIGHSHOT }
  { {[lsearch -regexp $pot {[ka]s}] > -1 && $have_qs } play qs}
  { {$shooting && !$have_qs} play LOW }
  { {$hasSuit && $down == 3 && [llength $pot_scoring] == 0 && $lowestcard < 7} play HIGH }
  { {$hasSuit && $myHighSafe != "" && $down != "0"} play HIGHSAFE }
  { {$hasSuit && $down == 2 && $myHighSafe == "" && $lowestcard > 7  } play HIGH }
  { {$hasSuit && $down < 3} play LOW }
  { {$hasSuit} play HIGH }
  { {!$hasSuit && $have_qs} play qs }
  { 1 play HIGH } }


# Note ai(high|low) patterns must have the card to play matching in the FIRST group
# ie {h  10 {{{a k q j} 0} {{t 9 8 7} 1 } {{6 5 4 3 2} 0}}} is no good, instead
#    {h  10 {{{t 9 8 7} 1 } {{a k q j} 0} {{6 5 4 3 2} 0}}}

set ai(high) {

  {s 100 {{{a k} 1+} {{j t 9 8 7 6 5 4 3 2} 0 }} }
  {s  80 {{{a k} 1+} {{j t 9 8 7 6 5 4 3 2} 1 }} }
  {s  60 {{{a k} 1+} {{j t 9 8 7 6 5 4 3 2} 2 }} }
  {s  20 {{{a k} 1+} {{j t 9 8 7 6 5 4 3 2} 3 }} }
  {s  10 {{{a k} 1+} {{j t 9 8 7 6 5 4 3 2} 4+}} }

  {{c d}  30 {{{a k q j} 1} {{t 9 8 7 6 5 4 3 2} 0 }}}
  {{c d}  25 {{{a k q j} 1} {{t 9 8 7 6 5 4 3 2} 1 }}}
  {{c d}  15 {{{a k q j} 1} {{t 9 8 7 6 5 4 3 2} 2 }}}
  {{c d}   8 {{{a k q j} 1} {{t 9 8 7 6 5 4 3 2} 3+}}}

  {{c d}  30 {{{a k q j} 2+} {{t 9 8 7 6 5 4 3 2} 0 }}}
  {{c d}  28 {{{a k q j} 2+} {{t 9 8 7 6 5 4 3 2} 1 }}}
  {{c d}  10 {{{a k q j} 2+} {{t 9 8 7 6 5 4 3 2} 2 }}}
  {{c d}   7 {{{a k q j} 2+} {{t 9 8 7 6 5 4 3 2} 3+}}}

  {h  15 {{{t 9 8 7} 2+} {{a k q j} 0} {{6 5 4 3 2} 0}}}
  {h  10 {{{t 9 8 7} 1 } {{a k q j} 0} {{6 5 4 3 2} 0}}}
  {h   6 {{{6 5 4 3 2} 1} {{a k q j} 0} {{t 9 8 7} 0 }}}

  {h  50 {{{a k q j} 1} {{t 9 8 7 6 5 4 3 2} 0 }}}
  {h  30 {{{a k q j} 1} {{t 9 8 7 6 5 4 3 2} 1 }}}
  {h  15 {{{a k q j} 1} {{t 9 8 7 6 5 4 3 2} 2 }}}
  {h  10 {{{a k q j} 1} {{t 9 8 7 6 5 4 3 2} 3+}}}

  {h  70 {{{a k q j} 2} {{t 9 8 7 6 5 4 3 2} 0 }}}
  {h  50 {{{a k q j} 2} {{t 9 8 7 6 5 4 3 2} 1 }}}
  {h  40 {{{a k q j} 2} {{t 9 8 7 6 5 4 3 2} 2 }}}
  {h  15 {{{a k q j} 2} {{t 9 8 7 6 5 4 3 2} 3+}}}

  {h  90 {{{a k q j} 3+} {{t 9 8 7 6 5 4 3 2} 0 }}}
  {h  80 {{{a k q j} 3+} {{t 9 8 7 6 5 4 3 2} 1 }}}
  {h  50 {{{a k q j} 3+} {{t 9 8 7 6 5 4 3 2} 2 }}}
  {h  15 {{{a k q j} 3+} {{t 9 8 7 6 5 4 3 2} 3+}}}

}

# if adding more spades test here, make sure to look at changing the ai(low) proc below

set ai(low) {
  {s -10 {{{2 3 4 5 6 7 8 9 t j} 1 } {{k a} 2}}}
  {s  -5 {{{2 3 4 5 6 7 8 9 t j} 2 } {{k a} 2}}}
  {s  30 {{{2 3 4 5 6 7 8 9 t j} 3 } {{k a} 2}}}
  {s  50 {{{2 3 4 5 6 7 8 9 t j} 4+} {{k a} 2}}}
  {s  -5 {{{2 3 4 5 6 7 8 9 t j} 1 } {{k a} 1}}}
  {s   0 {{{2 3 4 5 6 7 8 9 t j} 2 } {{k a} 1}}}
  {s  20 {{{2 3 4 5 6 7 8 9 t j} 3 } {{k a} 1}}}
  {s  50 {{{2 3 4 5 6 7 8 9 t j} 4+} {{k a} 1}}}
  {s  50 {{{2 3 4 5 6 7 8 9 t j} 1+} {{k a} 0}}}

  {{c d h} 25 {{{2 3 4 5} 1+} {{6 7 8 9} 0 } {{t j q k a} 0}}}
  {{c d h}  5 {{{2 3 4 5} 1 } {{6 7 8 9} 1 } {{t j q k a} 0}}}
  {{c d h} 17 {{{2 3 4 5} 2 } {{6 7 8 9} 1 } {{t j q k a} 0}}}
  {{c d h} 20 {{{2 3 4 5} 3+} {{6 7 8 9} 1 } {{t j q k a} 0}}}
  {{c d h}  3 {{{2 3 4 5} 1 } {{6 7 8 9} 2 } {{t j q k a} 0}}}
  {{c d h}  7 {{{2 3 4 5} 2 } {{6 7 8 9} 2 } {{t j q k a} 0}}}
  {{c d h} 20 {{{2 3 4 5} 3+} {{6 7 8 9} 2+} {{t j q k a} 0}}}

  {{c d h}  5 {{{2 3 4 5 6} 1} {{t j q k a} 1}}}
  {{c d h}  7 {{{2 3 4 5 6} 2} {{t j q k a} 1}}}
  {{c d h} 10 {{{2 3 4 5 6} 3} {{t j q k a} 1}}}
  {{c d h}  0 {{{2 3 4 5 6} 1} {{t j q k a} 2}}}
  {{c d h}  1 {{{2 3 4 5 6} 2} {{t j q k a} 2}}}
  {{c d h}  6 {{{2 3 4 5 6} 3} {{t j q k a} 2}}}
  {{c d h}  0 {{{2 3 4 5 6} 1} {{8 9 t j q k a} 3+}}}
  {{c d h}  1 {{{2 3 4 5 6} 2} {{8 9 t j q k a} 3+}}}
  {{c d h}  6 {{{2 3 4 5 6} 3} {{8 9 t j q k a} 3+}}}
}

set ai(text,0) Easy
set ai(discard,0) {1 2 6}
set ai(play,0) {
  { {$first} play HIGH }
  { {[lsearch -regexp $pot {[ka]s}] > -1 && [lsearch $cards qs] > -1} play qs}
  { {$hasSuit && $down == 3 && [llength $pot_scoring] == 0} play HIGH }
  { {$hasSuit && $myHighSafe != ""} play HIGHSAFE }
  { {$hasSuit && $down < 3} play LOW }
  { {$hasSuit} play HIGH }
  { {$down==0} play LOW }
  { {!$hasSuit && [lsearch $cards qs] > -1} play qs }
  { 1 play HIGH } }
  # these rules are from tkhearts-0.60

set ai(text,1) Average
set ai(discard,1) {1 3 4 6}
set ai(play,1) $ai(rules)

set ai(text,2) Hard
set ai(discard,2) {3 4 5 6}
set ai(play,2) $ai(rules)

#------------------------------------------------------------------------------
proc AIgetBestCard {who} {

  # first   : boolean (is this the first (with 2c) round?)
  # hasSuit : boolean (do we have the suit lead ?)
  # smart   : boolean (difficultly == 2)
  # qs_down : boolean (queen spades has been played)
  # have_qs : boolean (do we have qs (and we can play it))
  # hearts_played: boolean (have hearts been played)
  # down    : how many cards are already down (0 - 3)
  # pot     : 4 element enumerated list for cards down eg: {} 2s 5s {} 
  # cards   : list of your cards which are candidates to be played (low to high)
  # high    : the highest card in play which follows suit
  # lowestcard: numerical value of lowest card
  # scoringcards: scoring cards in players hand (low to high)
  # shooting: player is going for all tricks
  # myLow   : card used for 'LOW'
  # myHigh  : card used for 'HIGH'
  # myHighSafe  : card used for 'HIGHSAFE'
  # pot_scoring : list of scoring cards in pot
  # cards_left  : all players unplayed cards
  # cards[h|c|d|s] : list of cards value in each suit eg: cardsh is {2 3 7 a}

  global data ai

  set cards $data(cards,$who)

  # lead two-clubs if have to
  if { [lsearch $cards 2c] != "-1" } { return "2c" }

  set smart [expr $data(diff,$who) == 2]
  set first [expr {$data(doing)=="play1"}]
  set pot $data(pot)
  set down [expr {4-[llength [lsearch -all $pot {}]]}]
  set pot_scoring [setinter $pot {2h 3h 4h 5h 6h 7h 8h 9h th jh qh kh ah qs}]
  set lowestcard [numValue [lindex [lsort -command sortByRank $cards] 0]]

  # now reduce "$cards" to those we are ~allowed~ to play

  if { (([lsearch -regexp $cards {^.[^h]$}] != "-1" && (!$data(hearts)) && !$down) || $first ) } {
    set hearts_played 0
    set cards [setdiff $cards {2h 3h 4h 5h 6h 7h 8h 9h th jh qh kh ah}]
  } else {
    set hearts_played 1
  }

  if { $first } {
    set cards [setdiff $cards qs]
  }

  set hasSuit 0
  if { $down != "0" } {
    set tmp [lsearch -inline -all -regexp $cards "^.$data(suit)$"]
    if { [llength $tmp] > 0 } {
	  set hasSuit 1
	  set cards $tmp
    }
    unset tmp
  }

  set have_qs "[expr [lsearch $cards "qs"] != -1]"

  set scoringcards [lsort -command sortByRank \
	[setinter {2h 3h 4h 5h 6h 7h 8h 9h th jh qh kh ah} $cards]]

  if {$have_qs} {
    lappend scoringcards "qs"
  }

  set cards_left "$data(cards,0) $data(cards,1) $data(cards,2) $data(cards,3)"

  set qs_down "[expr [lsearch $cards_left "qs"] == -1]"

  set high {}
  foreach x $pot {
    if { $x != "" && [string match *$data(suit) $x] } {
      lappend high $x
    }
  }
  set high [lindex [lsort -command sortByRank $high] end]

  # we can play any spades less than queen safely (if no hearts played)
  if {$smart && $data(suit) == "s" && !$qs_down && [llength $pot_scoring] == "0"} {
    set high qs
  }

  set cards [lsort -command sortByRank $cards]

  ### determine if player is going for all tricks
  #.. should really nail this down sometime

  if {"$data(points,1)$data(points,2)$data(points,3)" == ""} {
    set e_won_2 [expr {[lrange "$data(lastwinners)" 0 1] == [list 0 0] }]
    set e_won_3 [expr {"$data(lastwinners)" == "0 0 0" }]
    set e_highlead [expr {[numValue $data(lead)] > 11 }]
    set e_nospade [expr {[suitValue $data(lead)] != "s"}]
    # set expr5 [expr {[llength "$data(points,0)"] > 0 }]
    set shooting [expr {($e_won_2 && $e_highlead) || ($e_won_3 && $e_nospade)}]
  } else {
    set shooting 0
  }

  if {$shooting} {
    puts "SHOOTING"
  }

  # sort out cardsh, cardsd, cardsc, cardss
  foreach s {c d s h} { set cards$s {} }
  foreach card $cards {
    scan $card "%1s%1s" v s
    lappend cards$s $v
  }

  set myLow [lindex $cards 0]
  set myHigh [lindex $cards end]

  # myHighSafe is largest card (following suit) which is lower than "$high" (if any)
  set myHighSafe ""
  if { $hasSuit } {

    foreach y [lsort -decreasing -command sortByRank $cards] {
      if { [numValue $y] < [numValue $high] } {
        set myHighSafe $y
        break;
      }
    }

    # we don't want to set "qs" as myHigh unless have to
    if {$myHigh == "qs" && [llength $cards] > 1} {
      set myHigh [lindex [lreplace $cards end end] end]
    }
    if {$myLow == "qs" && [llength $cards] > 1} {
      set myLow [lindex $cards 1]
    }

  } else {
    # don't have suit
    if {$smart} {
      
      # structure of ai(low) is: SUIT WEIGHT {list of {SET, NUMBER} pairs to match}
      # if "cards" match all the PAIRs in the appropiate NUMBERs, then , according to
      # WEIGHT, we reassign myLow. Same for myHigh later.
      
      set n 0 ; # currently unused
      set highest 0
      set highest_set {}

      # reselect myLow

      foreach i $ai(low) {
	foreach {suit weight tests} $i {
	  incr n

	  # don't use the normal spades tests if Qs down or we have it
	  if {$suit == "s" && ($qs_down || $have_qs)} {continue}

	  foreach s $suit {
	    set match 1
	    foreach test $tests {
	      set set [lindex $test 0]
	      set num [lindex $test 1]
	      if {[string range $num 1 1] == "+"} {
		if {[setinterN [set cards$s] $set] < [string range $num 0 0] } {set match 0}
	      } else {
		if {[setinterN [set cards$s] $set] != $num } {set match 0}
	      }
	    }  
	    if {$match} {
              puts "lll suit $s, weight $weight, pattern $tests matches: [set cards$s]"
	      if {$weight > $highest} {
		set highest $weight
		set highest_set [lsort -command sortByRank [setinter [lindex [lindex $tests 0] 0] [set cards$s]]]
                # if spades, no hearts down, safe to play high spade (< Queen), else play a low one
                if {$s == "s" && !$hearts_played && !$qs_down} {
                  puts "lll suit SPADE setting myLow to end of $highest_set"
                  set myLow [lindex $highest_set end]$s
                } else {
                  puts "lll suit $s, setting myLow to start of $highest_set"
                  set myLow [lindex $highest_set 0]$s
                }
	      }
	    }
	  }
	}
      }

      # reselect myHigh

      set highest 0
      set highest_set {}

      if {$down > 0} {
	foreach i $ai(high) {
	  foreach {suit weight tests} $i {
	    incr n

	    # don't worry about the spades tests if qs gone
	    if {$suit == "s" && $qs_down} {continue}

            foreach s $suit {
	      set match 1
	      foreach test $tests {
		set set [lindex $test 0]
		set num [lindex $test 1]
		if {[string range $num 1 1] == "+"} {
		  if {[setinterN [set cards$s] $set] < [string range $num 0 0] } {set match 0}
		} else {
		  if {[setinterN [set cards$s] $set] != $num } {set match 0}
		}
	      }  
	      if {$match} {
                puts "hhh suit $s, weight $weight, pattern $tests matches: [set cards$s]"
		if {$weight > $highest} {
		  set highest $weight
		  set highest_set [lsort -command sortByRank [setinter [lindex [lindex $tests 0] 0] [set cards$s]]]
                  puts "hhh suit $s, setting myHigh to end of $highest_set"
		  set myHigh "[lindex $highest_set end]$s"
		}
	      }
            }
	  }
	}
      }
      # special rules go here
      # ... if we have qs, we can take some liberties with myLow (undone)

      # eg 2,5,7 clubs, 6 hearts -> play 6 hearts
      if {[numValue $myHigh] < 10 && \
          "$scoringcards" != "" && \
          [llength [set cards[suitValue $myHigh]]] > 2 } {
        set myHigh [lindex $scoringcards end]
        puts "special 1"
      }

      # if shooting, dont play a heart stimpy!
      if {$shooting && [suitValue $myLow] == "h" } {
        set tmp {}
        foreach i $cards {
          if {[suitValue $i] != "h"} {
            lappend tmp $i
          }
        }
        if {"$tmp" != "" } {set myLow [lindex $tmp 0] }
      } 
    }
  }

  foreach x $ai(play,$data(diff,$who)) {

    foreach {expr cmd play} $x {break;}

    switch $play {
	  LOW { set card $myLow }
	 HIGH { set card $myHigh }
     HIGHSHOT { set card $myHigh }
     HIGHSAFE { set card $myHighSafe }
      default { set card $play }
    }

    if $expr {
      puts "    rule is: $expr, play $play"
      if {$play == "HIGHSHOT"} {
	puts "SHOT"
	set data(lastwinners) 1
      }
      return $card;
    }
  }

  # [Mike is a girl programmer, and reckons] just in case...
  return [lindex $cards 0];
}
#------------------------------------------------------------------------------
proc AIchooseCardsUp {who} {

  # choose 3 cards to discard

  global data ai

  # ai(discard,diff) is a list of rule to apply.
  # Currently have rules 1 2 3 4 5 (5 should be the safety)

  # variables here:
  #	discard:	cards 3 cards to discard
  #	cards:		players cards
  #	cards{c|d|s|h}	value of players cards in that suit ordered small to high

  set cards $data(cards,$who)
  set discard {}
  foreach suit {c d s h} {
    set cards$suit {}
  }
  foreach card $cards {
    scan $card "%1s%1s" v s
    lappend cards$s $v
  }
  foreach rule $ai(discard,$data(diff,$who)) {
     if {[llength $discard] > 2 } {break}

     switch -- $rule {
     1  { # discard queen spades

        set whereQ [lsearch $cardss q]
        if {$whereQ > -1} {
          lappend discard qs
          set cardss [setdiff $cardss q]
          set cards  [setdiff $cards qs]
	}  

        }
      2 { # get rid of high hearts, spades

        set suit s
	    foreach c [lreverse [setinter [set cards$suit] {k a}]] {
	      if {[llength $discard] > 2} { break } 
	      lappend discard $c$suit
	      set cards$suit [setdiff [set cards$suit] $c]
	      set cards  [setdiff $cards $c$suit]
            }
        set suit h
	    foreach c [lreverse [setinter [set cards$suit] {t j q k a}]] {
	      if {[llength $discard] > 2} { break } 
	      lappend discard $c$suit
	      set cards$suit [setdiff [set cards$suit] $c]
	      set cards  [setdiff $cards $c$suit]
            }
        }
     3  { # remove high spades, hearts if no low
        set suit s
          ### if we have 2s 3s 4s Qs As, do we want to chuck Qs, As
          # set lowspades [setinter [set cards$suit] {2 3 4 5 6 7 8 9 t j}]
          # set highspades [setinter [set cards$suit] {k a q}]
	  if {[llength [setinter [set cards$suit] {2 3 4 5 6 7 8 9 t j}]] < 4} {
	    foreach c [lreverse [setinter [set cards$suit] {k a q}]] {
	      if {[llength $discard] > 2} { break } 
	      lappend discard $c$suit
	      set cards$suit [setdiff [set cards$suit] $c]
	      set cards  [setdiff $cards $c$suit]
            }
	  } 
        set suit h
	  if {[llength [setinter [set cards$suit] {2 3 4 5 6 7}]] < 3} {
	    foreach c [lreverse [setinter [set cards$suit] {t j q k a}]] {
	      if {[llength $discard] > 2} { break } 
	      lappend discard $c$suit
	      set cards$suit [setdiff [set cards$suit] $c]
	      set cards  [setdiff $cards $c$suit]
            }
	  } 
        }
     4  { # try to short suit self in diamonds, clubs
	foreach suit {c d} {
	  set num_discards_left [expr 3 - [llength $discard]]
	  set num_cards_in_suit [llength [set cards$suit]]
	  if {$num_cards_in_suit <= [expr 1 + $num_discards_left] \
	      && $num_cards_in_suit > 0} {
	    while {[llength $discard] < 3 && [llength [set cards$suit]] > 0} {
	      set c  [lindex [set cards$suit] end]
	      lappend discard $c$suit
	      set cards$suit [setdiff [set cards$suit] $c]
	      set cards  [setdiff $cards $c$suit]
            }
	  } 
	}

        }
     5  { # get rid of large cards
	  # sort list <<c N> <d M> <s O> <h P>> so we know wich suit is least represented
	  set l {}
	  foreach suit {c d s h} {
	    lappend l [list $suit [llength [set cards$suit]]]
	  }

	  foreach pair [lsort -integer -index 1 $l] {
	    set suit [lindex $pair 0]
            if {$suit == "s"} {
              set highcards {q k a} 
            } else {
              set highcards {t j q k a} 
            }
	    foreach c [lreverse [setinter [set cards$suit] $highcards]] {
	      if {[llength $discard] > 2 || [llength [set cards$suit]] == 0 } { break } 
	      lappend discard $c$suit

	      set cards$suit [setdiff [set cards$suit] $c]
	      set cards  [setdiff $cards $c$suit]
	    }
	  }
	

        }
     6 { # get rid of large cards
	 # same as (5), but shred all cards
	  set l {}
	  foreach suit {c d s h} {
	    lappend l [list $suit [llength [set cards$suit]]]
	  }

	  foreach pair [lsort -integer -index 1 $l] {
	    set suit [lindex $pair 0]
	    foreach c [lreverse [setinter [set cards$suit] {2 3 4 5 6 7 8 9 t j q k a}]] {
	      if {[llength $discard] > 2 || [llength [set cards$suit]] == 0 } { break } 
	      lappend discard $c$suit
	      set cards$suit [setdiff [set cards$suit] $c]
	      set cards  [setdiff $cards $c$suit]
	    }
	  }
        }
     }
  }

  set move [lindex [list {} "15 0" "-15 0" "0 15"] $who]
  foreach x $discard {
    .c dtag cardNum$x down
    .c addtag up withtag cardNum$x
    eval .c move cardNum$x $move
  }

}
#------------------------------------------------------------------------------

#############
#------------------------------------------------------------------------------
proc doPassCards {} {

  global data
  
  # turn off binding
  .c bind player0 <Button-1> {}

  switch -- $data(round) {
    "1"  {set dirs "1 3 0 2"}
    "2"  {set dirs "2 0 3 1"}
    "3"  {set dirs "3 2 0 1"}
  }

  foreach x [list 0 1 2 3] {
    set up($x,ids) [.c find withtag "player$x&&up"] ;# ids
    set up($x,faces) {} ;# face values
    foreach y $up($x,ids) {
      lappend up($x,faces) [set val [fullValue $y]]
      .c dtag $y player$x
      set pos [lsearch $data(cards,$x) $val]
      set data(cards,$x) [lreplace $data(cards,$x) $pos $pos]
    }
  }

  foreach x [list 0 1 2 3] {
    set recip [lindex $dirs $x]
    foreach y $up($x,faces) {
      lappend data(cards,$recip) $y
      .c addtag player$recip withtag cardNum$y
    }
  }
  sortPlayerCards

  # here we reimage the cards as some have been 
  # swapped to player and are now face up and vice-versa
  foreach x $data(cards,0) {
    .c itemconfig [.c find withtag cardNum$x] -image ::img::$x
  }
  foreach x "$data(cards,1) $data(cards,2) $data(cards,3)" {
    .c itemconfig [.c find withtag cardNum$x] -image [getImage $x]
  }

  # &&&
  set base1 $data(tb_base)
  set diff1 $data(tb_diff)
  set base2 $data(tr_base)
  set diff2 $data(lr_diff)
  for {set i 0} {$i < 13} {incr i} {
    .c coords [set c cardNum[lindex $data(cards,0) $i]] [expr {$base1+($i*$diff1)}] $data(t1)
    .c raise $c
    .c coords [set c cardNum[lindex $data(cards,3) $i]] [expr {$base1+($i*$diff1)}] $data(t2)
    .c raise $c
    .c coords [set c cardNum[lindex $data(cards,1) $i]] $data(t2)  [expr {$base2+($i*$diff2)}] 
    .c raise $c
    .c coords [set c cardNum[lindex $data(cards,2) $i]] $data(t3) [expr {$base2+($i*$diff2)}]
    .c raise $c
  }

  set moves [list "0 -15" "15 0" "-15 0" "0 15"]
  foreach x [list 0 1 2 3] {
    foreach y [.c find withtag "player$x && up"] {
      eval .c move $y [lindex $moves $x]
    }
  }

  set data(doing) "accept"
  makeButton "Accept Cards" doAcceptCards
  setStatus "Click \"Accept Cards\" to continue"
}
#------------------------------------------------------------------------------

proc doAcceptCards {} {
  global data

  # here, we need to:
  #   a) set all cards "down" not "up", and move 'em to the right spot
  #   b) set up the bindings for the first round
  #   c) fire off the AI to move, if the player doesn't have the 2 of clubs

  foreach x [.c find withtag "player0 && up"] {
    .c dtag $x up
    .c addtag down withtag $x
    .c move $x 0 15
  }
  foreach x [.c find withtag "player1 && up"] {
    .c dtag $x up
    .c addtag down withtag $x
    .c move $x -15 0
  }
  foreach x [.c find withtag "player2 && up"] {
    .c dtag $x up
    .c addtag down withtag $x
    .c move $x 15 0
  }
  foreach x [.c find withtag "player3 && up"] {
    .c dtag $x up
    .c addtag down withtag $x
    .c move $x 0 -15
  }

  destroy .c.btn ;# remove the "accept" button
  update
  after [getDelay 300 200]
  startPlay

}
#------------------------------------------------------------------------------

proc startPlay {{where ""}} {
  global data

  set data(doing) play2
  set data(pot) [list {} {} {} {}]
  set data(suit) {}

  if {$where == ""} {
    # find who has two clubs
    foreach x [list 0 1 2 3] {
      if { [lindex $data(cards,$x) 0] == "2c" } {
	set where $x;
	set data(doing) play1
      }
    }
  }
  if { $where == "0" } {
    doPlayersTurn
  } else {
    runAI $where
  }

}
#------------------------------------------------------------------------------

proc runAI {who} {
  global data

  # Start running the AI (ie, computer players start throwing out cards for this round)
  # from player $who (1, 2 or 3). When we get to player 3, we stop for the human
  # player to take his turn, then carry on at player 1. Stop when everyone's had a go.

  ### setStatus "Waiting for $data(name,$who) to move..."
  ### set time [lindex [shuffleList [list 200 220 250 300 320 350 500]] 0]
  ### after $time
  update

  # for all the cards $who, see what an AI of his intelligence would play
  set card [AIgetBestCard $who]
  set len [llength $data(cards,$who)]
  # and actually play it
  doPlayCard $card $who
  doNextPlayer $who

}
#------------------------------------------------------------------------------

proc doNextPlayer {last} {
  global data

  if { [lsearch $data(pot) {}] == "-1" } {
    doEndRound
  } else {
    after [getDelay 50 200]
    if { $last == "2" } {
      doPlayersTurn
    } else {
      runAI [lindex [list 1 3 XXX 2] $last]
    }  
  }
}
#------------------------------------------------------------------------------

proc doPlayCard {value who} {
  global data

  puts "*** $data(name,$who) plays $value"

  if { $who != 0 } {
    scan $value "%1s%1s" v1 v2
    set text "$data(name,$who) plays the [spellValue $v1] of [spellSuit $v2]s"
    setStatus $text
  }
  .c raise cardNum$value
  .c addtag inPlay withtag cardNum$value
  .c itemconfigure cardNum$value -image ::img::$value ;# show AI cards
  doMoveCard .c cardNum$value $who
  set pos [lsearch $data(cards,$who) $value]
  if { [string range $value end end] == "h" } {
    set data(hearts) 1
  }
  set data(cards,$who) [lreplace $data(cards,$who) $pos $pos]
  set data(pot) [lreplace $data(pot) $who $who $value]
  if { $data(suit) == "" } {
    set data(suit) [string range $value end end]
    set data(lead) $value
  }
}
#------------------------------------------------------------------------------

proc doPlayersTurn {} {
  global data

  .c bind player0 <Button-1> doPlayersTurnSub

  if {$data(doing) == "play1" && $data(pot) == {{} {} {} {}} } {
    setStatus "Click the Two of Clubs to begin the round"
  } else {
    setStatus "Select a card to play"
  }
}
#------------------------------------------------------------------------------

proc doPlayersTurnSub {} {
  global data

  # Use 'current' tag to tell which card was clicked (thanks RS!)

  set card [.c find withtag current]
  set v(full) [fullValue $card]
  scan $v(full) "%1s%1s" v(face) v(suit)

  set played [expr {4-[llength [lsearch -all $data(pot) {}]]}]
  set hasNonHearts [expr {[llength [lsearch -all -glob $data(cards,0) "?h"]] != [llength $data(cards,0)]}]

  if { $played == "0" && $data(doing) == "play1" && $v(full) != "2c" } {
    set valid 0
    set msg "You must lead with the Two of Clubs"
  } elseif { $played == "0" && $v(suit) == "h" && !$data(hearts) && $hasNonHearts} {
    set valid 0
    set msg "Hearts has not been broken. Choose another suit"
  } else {
    set hasSuit [expr {[lsearch -glob $data(cards,0) "?$data(suit)"]!="-1"}]
    if { $hasSuit && $v(suit) != $data(suit) } {
      set valid 0
      set msg "You must follow suit; play a [spellSuit $data(suit)]."
    } elseif { $data(doing) == "play1" && ($v(suit) == "h" || \
        $v(full) == "qs") } {
      set valid 0
      set msg "You cannot play a Point Card in the first round."
    } else {
      set valid 1
    }
  }

  if { $valid } {
    # play the card
    .c bind player0 <Button-1> {}
    .c dtag $card player0
    setStatus "$data(name,0) plays the [spellValue $v(face)] of [spellSuit $v(suit)]s"
    doPlayCard $v(full) 0
    doNextPlayer 0
  } else {
    doErrorClick $card $msg
  }

}
#------------------------------------------------------------------------------
proc doEndRound {} {

  global data

  ### wait for a button click before proceeding if data(pause) set
  if {$data(pause)} {
    set currently $data(doing)
    set data(doing) paused
    setStatus "Press button 1 to continue"
    bind .c <Button-1> "set data(doing) $currently"
    update
    # this is a little unresponsive !
    tkwait variable data(doing)
    bind .c <Button-1> ""
  }

  # everyone player has played a card; sort scores, check if all cards
  # dealt have been played (and show scores if they have).

  # find who scored highest
  set pot $data(pot)
  foreach x [lsort -decr [setdiff "0 1 2 3" [lsearch -all -glob $pot "?$data(suit)"]]] {
           set pot [lreplace $pot $x $x]
  }
  set pot [lsort -command sortByRank $pot]
  set high [lindex $pot end]
  set player [lsearch $data(pot) $high] ;# $player (0-3) played the highest card
  set data(lastwinners) [lrange "$player $data(lastwinners)" 0 2]

  puts ""
  puts "*** hand won by $data(name,$player). pot is $data(pot) **"
  puts ""

  setStatus ""

  # tally up points
  foreach x $data(pot) {
           if { $x == "qs" || [string range $x end end] == "h" } {
                lappend data(points,$player) $x
              }
          }

  # move pot off the table
  switch -- $player {
    0 {set x   0 ; set y  15}
    1 {set x -15 ; set y   0}
    2 {set x  15 ; set y   0}
    3 {set x   0 ; set y -15}
  }

  .c lower inPlay

  after [getDelay 400 200]

  for {set i 0} {$i < 33} {incr i} {
    .c move inPlay $x $y
    update
    after [getDelay 1 2]
  }

  .c delete inPlay

  set cardsLeft [llength $data(cards,0)]

  after [getDelay 100 100]

  if { $cardsLeft > 0 } {
    startPlay $player
    return;
  }

  ### this round is over

  # show scoring cards &&&
  # Algorithm is the same as dealing cards in "proc deal"
  # but include an offset to center allign the cards

  set diff $data(tb_diff)

  # player's cards 

  set lc [lsort -command sortByCard $data(points,0)]
  set lc_len [llength $lc]
  if {$lc_len < 14} {set tmp 13.0} else {set tmp 14.0}
  # ^^^ funky code to allow for having 14 cards next to name instead of 13

  set base [expr $data(tb_base) + ($tmp-$lc_len)/2 * $diff]

  for {set i 0} {$i < $lc_len} {incr i} {
    .c create image [expr {$base+($i*$diff)}] $data(t1) \
	      -image ::img::[lindex $lc $i] -anchor nw -tags showscore
   }

  # top AI's cards

  set lc [lsort -command sortByCard $data(points,3)]
  set lc_len [llength $lc]
  if {$lc_len < 14} {set tmp 13.0} else {set tmp 12.0}
  set base [expr $data(tb_base) + ($tmp-$lc_len)/2 * $diff]

  for {set i 0} {$i < $lc_len} {incr i} {
    .c create image [expr {$base+($i*$diff)}] $data(t2) \
	      -image ::img::[lindex $lc $i] -anchor nw -tags showscore
  }

  set diff $data(lr_diff)

  # left AI's cards

  set lc [lsort -command sortByCard $data(points,1)]
  set lc_len [llength $lc]
  if {$lc_len < 14} {set tmp 13.0} else {set tmp 14.0}
  set base [expr $data(tr_base) + ($tmp-$lc_len)/2 * $diff]

  for {set i 0} {$i < $lc_len} {incr i} {
       .c create image 15 [expr {$base+($i*$diff)}] \
                 -image ::img::[lindex $lc $i] -anchor nw -tags showscore
      }

  # right AI's cards

  set lc [lsort -command sortByCard $data(points,2)]
  set lc_len [llength $lc]
  if {$lc_len < 14} {set tmp 13.0} else {set tmp 12.0}
  set base [expr $data(tr_base) + ($tmp-$lc_len)/2 * $diff]

  for {set i 0} {$i < $lc_len} {incr i} {
    .c create image $data(t3) [expr {$base+($i*$diff)}] \
	      -image ::img::[lindex $lc $i] -anchor nw -tags showscore
  }

  ### end show scoring cards
       
  foreach x [list 0 1 2 3] {
    if { [llength $data(points,$x)] == "14" } {
      set not $x
      break;
    }
  }

  if { [info exists not] } {
    foreach x [setdiff "0 1 2 3" $not] {
      set last [lindex $data(score,$x) end]
      incr last 26
      lappend data(score,$x) $last
    }
    set last [lindex $data(score,$not) end]
    lappend data(score,$not) $last
  } else {
    foreach x [list 0 1 2 3] {
      set last [lindex $data(score,$x) end]
      set points [llength $data(points,$x)]
      if { [lsearch $data(points,$x) "qs"] != "-1" } {
	incr points 12
      }
      incr last $points
      lappend data(score,$x) $last
    }
  }

  foreach x [list 0 1 2 3] {
    set data(cards,$x) $data(points,$x)
  }
  sortPlayerCards
  # display player cards. Problem here is they won't necessarily have
  # 13 cards, but we do want them centered on the screen.
  # And the current code for showing a player's hand uses hard-coded values,
  # based on the fact there're always 13 cards to start with...


  foreach x [list 0 1 2 3] {
    if { [lindex $data(score,$x) end] >= $data(winAt) } {
      set data(playing) 0
      showScores
      return;
    }
  }

  showScores {.c delete showscore ; deal}

}
#------------------------------------------------------------------------------

proc getDelay {min multiplier} {

  return [expr int((2 - $::data(speed)) * $multiplier) + $min]

}
#------------------------------------------------------------------------------

proc doErrorClick {card msg} {
  global data

  set binding [.c bind player0 <Button-1>]
  .c bind player0 <Button-1> {}
  set picture [.c itemcget $card -image]
  .c itemconfigure $card -image ::img::back
  set text [.status cget -text]
  setStatus $msg
  update
  after 300 ".c itemconfigure $card -image $picture ; .c bind player0 <Button-1> $binding"
  set data(statusAfter) [after [getDelay 500 300] [list setStatus $text]]

}
#------------------------------------------------------------------------------
proc setStatus {text} {

  global data

  if { [info exists data(statusAfter)] && $data(statusAfter) != "" } {
    set this $data(statusAfter) ; set data(statusAfter) ""
    foreach x $this {
      after cancel $this
    }
  }

  .status configure -text $text
}
#------------------------------------------------------------------------------
proc spellSuit {short} {

  set which [lsearch "c d h s" $short]
  incr which

  return [lindex "$short Club Diamond Heart Spade" $which];
}
#------------------------------------------------------------------------------
proc spellValue {val} {

  switch -- $val {
           a {set ret Ace}
           2 {set ret Two}
           3 {set ret Three}
           4 {set ret Four}
           5 {set ret Five}
           6 {set ret Six}
           7 {set ret Seven}
           8 {set ret Eight}
           9 {set ret Nine}
           t {set ret Ten}
           j {set ret Jack}
           q {set ret Queen}
           k {set ret King}
     default {set ret $val}
  }

  return $ret;
}
#------------------------------------------------------------------------------
proc doMoveCard {c item who} {

  set steps 15

  # base measurements, for the center of the screen
  set tox 230
  set toy 162
  # adjust depending on which side the card comes from
  switch $who {
      0 {incr toy 22; #incr tox -5}
      1 {incr tox -22; #incr toy 5}
      2 {incr tox 22; #incr toy -5}
      3 {incr toy -22; #incr tox 5}
  }

  set time [getDelay 1 5]

  scan [$c coords $item] "%s %s" origx origy

  if { ![info exists origx] } {
    puts "Error! \[[info level 0]\] / [$c coords $item]"
    parray ::data *,$who
  }

  ### move card
  set dx [expr ($tox - $origx)/($steps)]
  set dy [expr ($toy - $origy)/($steps)]

  # do (steps - 1) moves in loop, then the final move alone (to end up exactly on spot)
  for {set i 1} {$i < $steps} {incr i} {
    $c move $item $dx $dy
    update idletasks
    after $time
  }
  scan [$c coords $item] "%s %s" nowx nowy
  $c move $item [expr $tox - $nowx] [expr $toy - $nowy]
  update idletasks
  after $time

}
#------------------------------------------------------------------------------
proc fullValue {id} {

  set tags [.c gettags $id]
  set tag [lindex $tags [lsearch -glob $tags cardNum*]]
  return [string range $tag end-1 end];

}
#------------------------------------------------------------------------------

# these three procs are a mess ! and the "update"s are important...

#------------------------------------------------------------------------------
proc doCardUpDown {} {

  global data

  # get the card's id
  set card [.c find withtag current]
  if { $card == "" } {
    error "Error finding card in 'doCardUpDown'!"
  }

  if { [lsearch [.c gettags $card] up] != "-1" } {
    .c dtag $card "up"
    .c addtag "down" withtag $card
    .c move $card 0 20
    set data(currentHigh) {}
    update
  } elseif { [llength [.c find withtag "player0 && up"]] == "3" } {
    bell -displayof .
  } else {
    .c dtag $card down
    .c addtag up withtag $card
    if { $card == $data(currentHigh) } {
      .c move $card 0 -15
    } else {
      .c move $card 0 -20
    }
    update
  }

  if { [llength [.c find withtag "player0 && up"]] == "3" } {
    .c.btn configure -state normal
  } else {
    .c.btn configure -state disabled
  }

}
#------------------------------------------------------------------------------
proc doCardUp {} {

  # raise card a little to acknowledge focus
  global data

  if { ! $data(autoraise) } return

  set card [.c find withtag current]
  set data(currentHigh) $card
  if { [lsearch [.c gettags $card] up] != "-1" || $card == {} } {return}
  .c move $card 0 -5
  update
}
#------------------------------------------------------------------------------

proc doCardDown {} {
  global data

  if { ! $data(autoraise) } return

  set card [.c find withtag current]
  if { [lsearch [.c gettags $card] up] != "-1" \
       || $card != $data(currentHigh) } {return}
  .c move $card 0 5
  set data(currentHigh) {}
  update
}
#------------------------------------------------------------------------------

proc showOptions {} {
  global p data speed tmpOpt ai

  set thisCmd [lindex [info level 0] 0]
  if { [info exists dialog(cmd)] && !($dialog(cmd) == "" || $dialog(cmd) == $thisCmd) } {
    return; # already got another dialog up
  }
  set dialog(cmd) $thisCmd
  set dialog(win) .options
  set w .options

  initSubWindow $w "$p(name) - Options" 1

  set destroyCmd [list closeDialog $w [list setNewOptions 1]]
  set cancelCmd [list closeDialog $w [list setNewOptions 0]]
  wm protocol $w WM_DELETE_WINDOW $cancelCmd
  .c configure -state disabled
  bind $w <Return> $destroyCmd

  foreach x [list name,0 name,1 name,2 name,3 speed scores pause autoraise] {
        set tmpOpt($x) $data($x)
  }

  pack [frame $w.top] -side top
  pack [frame $w.btm] -pady 10

  set tmpOpt(aiVals) {}
  foreach x [lsort -int [string map [list text, {}] [array names ai text,*]]] {
    lappend tmpOpt(aiVals) $ai(text,$x)
  }

  pack [frame $w.top.title] -side top

  pack [label $w.top.title.image1 -image ::img::heart ] -side left -padx 30
  # pack [label $w.top.title.image2 -image ::img::heart ] -side right -padx 30
  # pack [label $w.top.title.text -text TkHearts -font $data(font_large) ] -side right

  # set aai [labelframe $w.top.ai -borderwidth 0 -labelanchor n ]  
  set aai [labelframe $w.top.ai -borderwidth 0 -labelanchor n ]  

  # Player's name widget
  pack [frame $aai.0] -side top -padx 2 -pady 12 -anchor nw

  pack [label $aai.0.lName -width 11 -anchor w -text "Player "] -side left
  pack [entry $aai.0.eName -textvariable tmpOpt(name,0) \
    -validatecommand {expr {[string length %P] <= 11}} \
    -invalidcommand {bell -displayof %W} -validate key -width 12] -side left


  set i 0
  foreach x [list 1 3 2] {
    incr i
    pack [frame $aai.$x] -side top -padx 2 -pady 3
    pack [label $aai.$x.lName -width 11 -anchor w -text "Computer $i"] \
      -side left
    pack [entry $aai.$x.eName -textvariable tmpOpt(name,$x) \
      -validatecommand {expr {[string length %P] <= 11}} \
      -invalidcommand {bell -displayof %W} \
      -validate key -width 12] -side left
    pack [label $aai.$x.lDiff -text "Skill"] -side left -padx 10
    pack [spinbox $aai.$x.sDiff -values $tmpOpt(aiVals) \
      -state normal -width 11 \
      -textvariable tmpOpt(aiDiff,$x)] -side left
    $aai.$x.sDiff set $ai(text,$data(diff,$x))
  }

  pack $aai -side top -pady 5 -padx 10

  # ok steve - new radio button widgets all round

  # these frames just align the radio widgets nicely (I hope)
  frame $w.btm.left -width 100
  frame $w.btm.right -width 100

  foreach \
  i {{Card Speed} {Pause Each Hand} {Scores in Title} {Autoraise}} \
  j {{2 1 0} {1 0} {1 0} {1 0}} \
  k {speed pause scores autoraise} \
  l {{Fast Med Slow} {Yes No} {Yes No} {Yes No}} {
    pack [label $w.btm.left.$k -text "${i}" -width 15 -anchor w] -side top -pady 4 -fill x -anchor w

    # frame the radiobuttons
    pack [frame $w.btm.right.$k] -side top -pady 4 -anchor w

    foreach x $j y $l {
      radiobutton $w.btm.right.$k.$x -width 4 -variable tmpOpt($k) -value $x -text $y
      pack $w.btm.right.$k.$x -side left -fill x
    }
  }
  # tweak the spacing a little
  $w.btm.right.speed.1 configure  -width 5

  pack $w.btm.left -side left -fill x -anchor w -ipadx 5 -padx 10
  pack $w.btm.right -side right -fill x -anchor e -ipadx 5

  pack [frame $w.btn] -side bottom
  pack [button $w.btn.ok -command $destroyCmd -text "OK" \
    -width 8 -default active] -side left -pady 8 -padx 30
  pack [button $w.btn.cancel -command $cancelCmd -text "Cancel" \
    -width 8] -side right -pady 8 -padx 30

  update
  center $w
  wm deiconify $w
  update
  grabSubWindow $w
  wm resizable $w 0 0
  raise $w
  focus -force $w
  
  return;

}
#------------------------------------------------------------------------------

proc setNewOptions {set} {
  global tmpOpt data

  if { $set } {
    # update options
    foreach x [list name,0 name,1 name,2 name,3 speed scores pause autoraise] {
      set data($x) $tmpOpt($x)
    }

    chkTitle
	    
    foreach x {0 1 2 3} {
      .c itemconfig name$x -text $data(name,$x)
    }
	      
    foreach x [list 1 2 3] {
      set data(diff,$x) [lsearch $tmpOpt(aiVals) $tmpOpt(aiDiff,$x)]
    }
  }

  # now remove temporary changes
  unset tmpOpt

}
#------------------------------------------------------------------------------

proc chkTitle {} {

  global data p

  if {$data(scores)} {
    set data(title) "$p(name)  -  [lindex $data(score,0) end]    [lindex $data(score,1) end]    [lindex $data(score,3) end]    [lindex $data(score,2) end]"
  } else {
    set data(title) $data(title_const)
  }
  wm title . $data(title)
}
#------------------------------------------------------------------------------

proc showScores {{cmd ""}} {
  global p data dialog

  set thisCmd [lindex [info level 0] 0]
  if { [info exists dialog(cmd)] && !($dialog(cmd) == "" || $dialog(cmd) == $thisCmd) } {
       return; # already got another dialog up
     }
  set dialog(cmd) $thisCmd
  set dialog(win) .scores
  set w $dialog(win)
  
  # see which place we're in for the window title
  set myScore [lindex $data(score,0) end]
  set allScores $myScore
  lappend allScores [lindex $data(score,1) end]
  lappend allScores [lindex $data(score,3) end]
  lappend allScores [lindex $data(score,2) end]
  set allScores [lsort -integer $allScores]
  set bestScore [lindex $allScores 0]
  set worstScore [lindex $allScores end]
  set place [lsearch $allScores $myScore]
  set place [string map "0 First 1 Second 2 Third 3 Last" $place]

  initSubWindow $w "Scores -- $place Place" 1

  set destroyCmd [list closeDialog $w $cmd]
  wm protocol $w WM_DELETE_WINDOW $destroyCmd
  .c configure -state disabled

  # hmmm - no overstrike fonts in wish8.5b1

  set tmp [label .nameThatWontBeUsed]
  set lFont [$tmp cget -font]
  catch {destroy $tmp}
  set font [font actual "[font actual $lFont] -weight bold"]
  set font2 [font actual "[font actual $font] -overstrike 1"]
  set width 85
  pack [frame $w.top] -side top -fill both

  set title {}
  foreach x {0 1 3 2} {
    pack [frame $w.top.player$x] -side left -fill y
    set highest [lindex $data(score,$x) end]
    if { $highest == $bestScore } {
      # $worstScore >= $data(winAt) ???
      set color($x) blue
      set color2($x) blue
    } else {
      set color($x) black
      set color2($x) black
    }                
    pack [label $w.top.player$x.name -foreground $color($x) -font $font \
	  -text $data(name,$x) -width $width -justify center \
	  -compound top -image ::img::blank] \
      -anchor nw -side top -fill x
    set round 0
    # first pack the overstruck previous scores (except 0)
    if { [llength $data(score,0)] > 2 } {
      foreach y [lrange $data(score,$x) 1 end-1] {
	pack [label $w.top.player$x.r$round -foreground $color($x) \
	      -font $font2 -text $y -width $width \
	      -justify center -compound top \
	      -image ::img::blank] \
	  -anchor nw -side top -fill x
        incr round
      }
    }

    set score [lindex $data(score,$x) end]

    # now pack the latest score in normal font
    pack [label $w.top.player$x.r$round -foreground $color2($x) \
	  -font $font -text $score \
	  -width $width -justify center -compound top \
	  -image ::img::blank] \
      -anchor nw -side top -fill x
  }

  chkTitle

  pack [button $w.top.ok -text "OK" -command $destroyCmd -width 8 -default active] \
    -side left -padx 5 -anchor center
  bind $w <Return> $destroyCmd

  if { $worstScore >= $data(winAt) } {
    pack [label $w.btm -text "Game over! You came in $place place."] \
      -side bottom
    setStatus "Game over! You came in $place Place."
  } else {
    setStatus "Close the Scores dialog to continue playing."
  }

  update
  center $w
  wm deiconify $w
  update
  grabSubWindow $w
  wm resizable $w 0 0
  raise $w
  focus -force $w

  return;

}

#------------------------------------------------------------------------------
proc initHelp {} {

  global help p data tcl_patchLevel

  # restructured mikes nice (but god-forsaken) help widget with 0.90 &&&
  # hmmm - my set-up is a little confusing i guess -
  # each help text ("k") is just a list of {text format text format ....}
  # where format is the text "tag" that determines any special formatting

  foreach {i j k} {

    0 Overview {

{Hearts is an fun card game for four players... Or one player and three AIs (Artificial Intelligences).} {} \n\n {}

{The game is played in rounds in which the whole deck is dealt.  Playing hands where the highest card following suit wins, players try to win as few scoring cards as possible.  These are the Hearts suit for 1 point each, and the Queen of Spades for 13 points.} {} \n\n {}

{Additional rounds are played until someone has 100 points, when the game is over, and the player with the lowest score wins.} {} \n\n {}
}

    1 "How To Play" {

{At the start of the first, second and third rounds, select three cards to pass to your opponent (left, right, and then across). On the fourth round, no cards are passed. To select a card, click on it. To deselect a card, simply click it again.} {} \n\n {}

{The player with the Two of Clubs begins the round.} {} \n\n {}

{Moving clockwise around the table, every player plays one card.  You must play a card of the same suit, if you have one. If not, you can play any card, with the exception that a) you cannot play a point card on the first hand of a round, and b) you cannot lead a Heart unless one has been played previously in the round, or you have no other cards left.} {} \n\n {}

{Whoever plays the highest card of the same suit as that which opened the hand collects all the cards. He or she gains one (1) point for every Heart in the hand, and thirteen (13) points for the Queen of Spades.} {} \n\n {}

{Play continues like this until all cards have been played. A new round is then started; this continues until any player ends a round with 100 points or more, when the game ends. Whoever has the lowest score at this time is the winner.} {} \n {} }

    2 "Scoring & Tips" {

"As mentioned in " {}
"How to Play" "link goto1"
", all Hearts are worth one (1) point, and the Queen of Spades is worth thirteen (13) points. The exception to this rule is that, if you collect all the point cards - the Queen of Spades and all the Hearts - every other player on the game scores twenty six (26) points, and you don't score any. This is called " {}
"Shooting the Moon" "italic"
". Shooting the Moon is easier to do if your hand contains a large number of point cards.\n\n" {}

"Avoid taking hands which contain point cards.\n\n" {}

"In rounds that start by passing cards to other players, get rid of the highest valued cards you have first (aces, kings, etc). Then, during the game, try to get rid of your higher valued cards early on, while it's more likely that other players will be able to follow suit, and won't be able to drop in a point card.\n\n" {}

"Keep track of which cards have been played, as best you can. In particular, look out for whether the Queen of Spades has been played yet, and whether Hearts has been broken (whether a Heart has been played yet in this round).\n" {} }

    3 Changes {

"0.90 - Restructured Help and About widgets, made the logo bitmap transparent." indent \n {}
"0.87 - Seem to have the auto raise feature working :-> Made the help widget fonts a little bigger." indent \n {}
"0.86 - Re-did Mike's god-awful indentation. Some code tidy up thinking about resizing the game. Bug fix for double clicking on an illegal card. Added a spider card-back." indent \n {}
"0.85 - Added a little program icon for window managers, Changed the card-back widget to work automatically." indent \n {}
"0.80 - Tweaked and removed bugs from new AI. Confined the end of round click to the canvas. Centre allign the end of round cards display and changed the Game Overview a little. Created a new heart picture." indent \n {}
"0.75 - Stopped player from 'shooting', and improved the 'Rules' again. Centre allign the end of round cards display and changed the Game Overview a little." indent \n {}
"0.70 - Start implementing new AI for selecting myHigh, myLow, and found a little bug in the 'down==3 -> play HIGH' rule. Restructured the Options widget, including an option to show the scores in the title bar." indent \n {}
"0.60 - Bit of code rewrite as spider is now separate again. Changed the menus around a little, disabled the Confirm Quit dialog, and overhauled the About widget." indent \n {}
"0.51 - Two unlikely bugfixes for wayward right clicking, and this is also the first release incorporating tkspider!" indent \n {}
"0.50 - Multiple score colors at the end removed.  Correctly show if the player should lead the two of clubs. Overhauled the game speed, card step logic and the name widgets. Fixed the bug that computer won't ever play hearts first and ... started to overhaul the AI. Added pause after hand feature." indent \n {}
"0.40 - Added a debug feature to see the computer's cards. Implemented better card discard AI." indent \n {}
"0.30 - Made new card backs." indent \n {}
"0.28 - Don't display the overstruck zeros in the score. Move the initial player-name dialog into the options menu. Gave the heart gif a little tweak. Fixed up the AI ordering issues (I hope)." indent \n {}
"0.27 - Scoring cards at end of round are displayed." indent \n {}
"0.26 - Window code changes, options menu and colour chooser, a few bug fixes. Mike added an AI fix." indent \n\n {}

{The below changes are from Mike's original Hearts program} {} \n\n {}

"0.24 - Fixed error in help-file found by Olier Raby. Also updated the 'Last Modified' date, which I hadn't done for v0.23." indent \n {}
"0.23 - You're now asked for your name when you open the program, and then a game starts automatically. Also, a number of options are now saved when you close the program, in \.hearts\ (unix) or \hearts.ini\ (other platforms). The code for these changes was written by Olier Raby - thank you for sharing it :)" indent \n {}
"0.22 - Fixed bug in doEndRound, when someone has all the point cards (Queen of Spades and all the Hearts). Found by Gerald Lester." indent \n {}
"Added Heart image into Options dialog, to fill some empty space and make it more attractive" indent2 \n {}
"0.21 - Added help-files" indent \n {}
"0.20 - Options dialog now does validation on the entry widgets, to keep AI names at most 15 characters long. This is to help avoid them needing two lines to fit on the screen, since it's a whole lot of hassle to implement right that I don't need :)" indent \n {}
"0.19 - Fixed scoring bugs found by \[Anon] on the Wiki." indent \n {}
"Scoring changes (buggy, but fixed in 0.19, see below)" indent2 \n {}
"AIs are now numbered 0-2 (not 1-3) for \[lindex] purposes" indent2 \n {}
"Status bar is now set via a \[setStatus] proc, rather than by directly configuring the widget, so that delayed calls to set it via \[after] can be cancelled." indent2 \n {}
"There's no longer a delay (previously 350ms) between the right AI playing a card, and the player bindings being set (in doNextPlayer)." indent2 \n {}
"0.18 - Added Options dialog." indent \n {}
"Removed \[hastag] proc - it was only used once, so I just used it's (one-line) body directly in the spot where it was being called. Marginally increases the speed." indent2 \n {}
"0.17 - Added Button-3 event that raises a player's card, so you can see the whole thing." indent \n {}
"0.16 - Added more status bar messages, so it doesn't appear to hang at the end of a round/game." indent \n {}
"Minor changes to score dialog's appearance (to allow less red, and to add overstriking of scores from previous rounds)" indent2 \n {}
"0.15 - Added a variable, $data(winAt), which stores the number of points needed to lose the game. Saves changing it in multiple places for debugging things." indent \n {}
"Removed lots of old debugging calls to \[puts], and fixed the OK button on the Scores dialog to have \-default active\, instead of \-state active" indent2 \n {}
"0.14 - The Scores dialog now shows scores over 100 in red, at game end (suggsted by RDT)." indent \n {}
"0.13 - Bug in the AIchooseCardsUp proc fixed where, with multiple \[lreplace] calls, the later ones were getting list indexes that no longer existed" indent \n {}
"0.12 - Introduced a third (and final?) AI, slightly better than the last in avoiding the Queen of Spades" indent \n {}
"0.11 - Changes to the AI, because the way the new system was set up sucked ;)" indent \n {}
"0.10 - Changed the way the AI works, so that all that's needed to define which cards get put up at the start of a round is a simple list of glob patterns (ie, '*a *k *q *j *t ... *2' to go from highest to lowest)." indent \n {}
"0.9  - Fixed bug mentioned in 0.8 (99% sure - extra \[puts] left in just in case, for now). Also fixed a bug in the score dialog that made it say the game was over if someone scored more than 10 points - it should be more than 99, but I'd changed it once to check it worked and never set it back." indent \n {}
"Also updated the 'About' dialog to acknowledge contributions from people who I'd thus far left off due to forgetfulness." indent2 \n {}
"0.8  - Added 'debugging' \[puts] in doMoveCard, to try and catch the bug found by rdt. (If origx isn't set, it prints the arguments it was called with, and the results of the \[\$c coords \$item] (where \$origx should come from)." indent \n {}
"0.7  - AIs could play a Heart on the first round. Bug found by \[rdt]." indent \n {}
"0.6  - The main window is now centered on startup, and isn't resizable." indent \n {}
"Small internal change to the code for \transient\ windows, to better handle error cases (which shouldn't be possible, but better safe than sorry), and to deactivate .c instead of removing the bindings on the tags - same effect, but less chance of it going wrong somewhere later." indent2 \n {}
"0.5  - Added a dialog for selecting which cardback you want to use." indent \n {}
"\package require Tk\ also added by Brian Theado \[http://mini.net/tcl/561]." indent \n {}
"Also removed a card-back image I didn't like, and added 2 more (to make 8 in total, better for displaying the 'select card back' screen): a red pattern, and a Tcl Powered one." indent2 \n {}
"Changed the way the card backs are stored - the cardback array is now set via a proc (so that it can be unset to free memory, but set again later); later, you'll be able to select/change the cardback image at any time. The cardback() array's keys no longer need to be incrementing integers for random selection, either, so the images can be named." indent2 \n {}
"0.4  - Temporary (and, as it turned out, buggy) score dialog removed, and replaced with a proper one." indent \n {}
"0.3  - First playable version. Basic level AI only, and a poor score dialog, but the game works. Also added displaying the four player's names on the canvas, by their cards." indent \n {}
"Game starts if an AI has the 2 of clubs, but fails when it's the (human) player's turn." indent2 \n {}
"Beginning of AI so the other players can also pick cards." indent2 \n {}
"0.2  - you can now pick which three cards to pass on." indent \n {}
"0.1  - Initial version, shows the canvas and deals cards, but nothing else." indent \n {} }

4 About {}

} {
      set help($i) ""
      set help(title,$i) "$j"
      set help(text,$i) "$k"
  } 

  # end foreach
  # now mix the variables into the about / change

  set help(text,4) [list "$p(name) $p(version) ($p(date)) by Steven A (with feedback from Mike). Available at the $p(web).\n\n" {} "Based on: Hearts $p(mike_release) was written by Mike Griffiths. Code, ideas, feedback, etc, were gratefully received from: Richard Suchenwirth, Vince Darley, Gerald Lester, and especially R. Dale Thomas. Thanks! $p(mike_email)\n\n" {} "Tcl Version $tcl_patchLevel.\n" {} ]

}
#------------------------------------------------------------------------------
proc showHelpTopic {w {topic {}}} {
  global help

  # show a specific help topic in the window
  # $w is toplevel, $w.t is the text frame

if { $topic != {}} {
  $w.l selection clear 0 end
  $w.l selection set $topic
  $w.l activate $topic
}

  $w.t configure -state normal
  $w.t delete 1.0 end
  set helpFile [$w.l curselection]
  $w.t insert end $help(title,$helpFile) title
  $w.t image create end -image ::img::logo -align center -padx 20
  $w.t insert end "\n\n"
  foreach {text tags} $help(text,$helpFile) {
    $w.t insert end $text $tags
  }
  $w.t configure -state disabled

}
#------------------------------------------------------------------------------
proc showHelp {{topic 0}} {

  global p help data

  set w .help

  if { [winfo exists $w] } {
    showHelpTopic  $w $topic
    wm deiconify $w
    raise $w
    focus $w
    return
  }

  initSubWindow $w "$p(name) - Help" 0

  pack [listbox $w.l -selectmode single -font $data(font_default) -width 12] \
    -expand 0 -fill y -side left -anchor nw
  bind $w.l <<ListboxSelect>> "showHelpTopic $w"
  pack [text $w.t -width 40 -height 22 -yscrollcommand "$w.s set" \
                  -wrap word -font $data(font_default) -padx 5 -pady 8] \
        -expand 1 -fill both -side left -anchor nw
  $w.t tag configure "title" -font $data(font_large) -justify center
  $w.t tag configure "indent" -lmargin2 15
  $w.t tag configure "indent2" -lmargin1 8 -lmargin2 20
  $w.t tag configure "italic" -font "[font actual [$w.t cget -font]] -slant italic"
  $w.t tag configure "link" -font "[font actual [$w.t cget -font]] -underline 1" \
                            -foreground blue 
  $w.t tag bind link <Enter> "%W configure -cursor hand2"
  $w.t tag bind link <Leave> "%W configure -cursor {}"
  pack [scrollbar $w.s -command "$w.t yview"] -fill y -side left -anchor ne

  # populate list, show index topic
  foreach x [lsort [array names help -regexp {^[0-9]+$}]] {
    $w.l insert end $help(title,$x)
    $w.t tag bind goto$x <Button-1> "showHelpTopic $w $x"
  }

  bind $w <KeyPress-q> "destroy $w"
  focus $w
  update
  center $w
  wm deiconify $w
  showHelpTopic $w $topic
  $w.t configure -state disabled

}
#------------------------------------------------------------------------------
# main #
#------------------------------------------------------------------------------

set p(name)       "TkHearts"
set p(version)    "0.90"
set p(date)       "20 October 2007"
set p(web)        "Sourceforge TkGames Project (http://tkgames.sf.net)"
set p(mike_email) "talvo@talvo.com"
set p(mike_release) "0.24 (17 February 2005)"

set data(canvas_bg)  SkyBlue2 ;# Mike likes #000077770000
set data(canvas_bg2) grey     ;# Mike likes #000088880000 or Light "grass" green
set data(cardback)   Traditional

# minus indicates size is pixels, not points (more consistant across win/unix)

set data(font_default)   {Arial -16}
set data(font_medium) {Arial -18}
set data(font_large) {Arial -20}
set data(font_large_bold) {Arial -20 bold}
set data(font_button)    {Helvetica -14}
set data(platform)       $tcl_platform(platform)

# Known bugs, as yet unfixed, and things still to add:
# - Keyboard bindings.
# - hitting "n" for newgame n the middle of a round .. doesn't work properly

set data(speed)   1 ;# either 0|1|2
set speed(0,name) Slow
set speed(1,name) Medium
set speed(2,name) Fast

set data(debug) 0
set data(pause) 0  ;# pause between hands
set data(scores) 0 ;# show scores in title
set data(autoraise) 1 ;# give cards a bump on focus

set data(name,0) Player1
set data(name,1) Computer1
set data(name,2) Computer3
set data(name,3) Computer2

set data(diff,1) 0 
set data(diff,2) 1
set data(diff,3) 2

set data(score,0) 0
set data(score,1) 0
set data(score,2) 0
set data(score,3) 0

set data(points,0) {}
set data(points,1) {}
set data(points,2) {}
set data(points,3) {}

set data(cards,0) {}
set data(cards,1) {}
set data(cards,2) {}
set data(cards,3) {}

set data(currentHigh) {}
set data(playing) 0
set data(round)   0  
    # 1 = pass left
    # 2 = pass right
    # 3 = pass up
    # 4 = don't pass, just play
set data(doing) none 
    #   (see proc doCardClick) possible values:
    #   pass   = passing cards to other players (select/deselect cards)
    #   accept = accepting cards passed to us; no bindings
    #   play1  = first round; 2 of clubs only
    #   play2  = click a card to send it
    #   paused = waiting for button click at end of hand
    #   none   = no bindings
    #   ???    = ???

# Hmmm... I was intending to make the game larger, but it doesn't look so nice
# with the cards spaced out as the card detail gets revealed and cluttered
# So maybe i'll go with automatically highlighting card under cursor ??

# set some tuneables for canvas card placement
# originally -width 530 -height 420, t1 = 309. t2 = 15, t3 = 444, ts = 12
# now               640         480       365       15       544       15

set data(tw) 530 ; # canvas width
set data(th) 420 ; # canvas height
set data(t1) 309 ; # player0's cards y coord
set data(t2) 15  ; #
set data(t3) 444 ; # player3's cards x coord
set data(ts) 12  ; # spacing

# originally (tb_base) 140 (tb_diff) 15 (tr_base) 72 (lr_diff) 15

set data(tb_base) 140
set data(tb_diff) 15

set data(tr_base) 72
set data(lr_diff) 15

set data(hearts) 0  ;# has hearts been broken?
set data(winAt) 100 ;# what score do you win at?

if { $data(platform) == "unix" } {
  set p(config) ~/.tkheartsrc
} else {
  set p(config) "d_hear.in"
}

catch {source $p(config)}

loadCardbacks

initIcons

if {![info exists cardback($data(cardback))]} { set data(cardback) Purple }

image create photo ::img::back -data $cardback($data(cardback))
array unset cardback

set data(allcards) {}
foreach x [image names] {
  if { [string match {::img::[a2-9tjqk][sdch]} $x] } {
    lappend data(allcards) [string range $x end-1 end]
  }
}
set data(allcards) [lsort $data(allcards)]

initHelp
initHearts
newGameHearts
update idletasks

#------------------------------------------------------------------------------
# 
#------------------------------------------------------------------------------

